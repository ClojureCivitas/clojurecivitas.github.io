[
  {
    "objectID": "ideas.html",
    "href": "ideas.html",
    "title": "Ideas",
    "section": "",
    "text": "Ideas, insights, and patterns in the Clojure world. This page collects evolving references rather than dated posts.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nCivitas Explorer\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nELK SVG\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nEclipse Layout Kernel\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "filter.html",
    "href": "filter.html",
    "title": "Filter",
    "section": "",
    "text": "Filter all notebooks.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 6, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nThe Z-Combinator Gambit\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nChris Houser, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nEclipse Layout Kernel\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nELK SVG\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nClean object printing by removing extraneous\n\n\n\n\n\n\n\n\nJun 5, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCivitas Explorer\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "idea/print/object/remove_extraneous.html",
    "href": "idea/print/object/remove_extraneous.html",
    "title": "Clean object printing by removing extraneous",
    "section": "",
    "text": "^{:clay {:title  \"Clean object printing by removing extraneous\"\n         :quarto {:author   :timothypratley\n                  :type     :post\n                  :date     \"2025-06-05\"\n                  :category :clojure\n                  :tags     [:print-method :objects]}}}\n(ns idea.print.object.remove-extraneous\n  (:require [clojure.string :as str])\n  (:import (clojure.lang MultiFn)\n           (java.io Writer)))\n\n\n(set! *warn-on-reflection* true)\n\n\ntrue\n\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(defn format-class-name ^String [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str (str/join \"$\" names))\n      (-&gt; s (str/split #\"\\.\") (last)))))\n\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(defn object-str ^String [x]\n  (str \"#object [\" (format-class-name (class-name x)) \"]\"))\n\n\n(defn object-writer [x ^Writer w]\n  (.write w (object-str x)))\n\n\n(defn pr-str* [x]\n  (let [original-method (get-method print-method Object)]\n    (try\n      (.addMethod ^MultiFn print-method Object object-writer)\n      (pr-str x)\n      (finally\n        (.addMethod ^MultiFn print-method Object original-method)))))\n\n\n(comment\n  (pr-str* pr-str*)\n  :-)\n\n\nsource: content/idea/print/object/remove_extraneous.clj"
  },
  {
    "objectID": "idea/graph/layout/elk.html",
    "href": "idea/graph/layout/elk.html",
    "title": "Eclipse Layout Kernel",
    "section": "",
    "text": "(defn ^ElkNode elk [g]\n  (-&gt; (json/write-str g)\n      (ElkGraphJson/forGraph)\n      (.toElk)))\n\n\n(defn unelk [^ElkNode g]\n  (-&gt; (ElkGraphJson/forGraph g)\n      (.toJson)\n      (json/read-str {:key-fn keyword})))\n\n\n(defn layout [g]\n  (let [g (elk g)]\n    (.layout (RecursiveGraphLayoutEngine.) g (BasicProgressMonitor.))\n    (unelk g)))\n\nExample\n\n(-&gt; {:id            \"root\",\n     :layoutOptions {:elk.algorithm         \"layered\"\n                     :elk.direction         \"DOWN\"\n                     :elk.hierarchyHandling \"INCLUDE_CHILDREN\"},\n     :children      [{:id       \"node1\",\n                      ;; node1 label is hidden under node2\n                      ;; can treat labels as nodes as a workaround,\n                      ;; or label outside/above, or something\n                      ;; groups label outside, nodes inside\n                      :labels   [{:text \"node1\"}]\n                      :width    50,\n                      :height   50,\n                      :children [{:id     \"node2\",\n                                  :labels [{:text \"node2\"}]\n                                  :width  20,\n                                  :height 20}]}\n                     {:id     \"node3\",\n                      :labels [{:text \"node3\"}]\n                      :width  50,\n                      :height 50}]}\n    (layout)\n    (elk-svg/render-graph)\n    (delay))\n\nnode1node2node3\nTODO: Maybe these are only for layered\n\n(def algorithm-k \"org.eclipse.elk.algorithm\")\n\n\n(def default-layout-algorithm \"org.eclipse.elk.layered\")\n\n\n(def default-layout-options\n  {\"org.eclipse.elk.algorithm\"                                    \"org.eclipse.elk.layered\"\n   \"org.eclipse.elk.direction\"                                    \"DOWN\"\n   \"org.eclipse.elk.hierarchyHandling\"                            \"INCLUDE_CHILDREN\"\n   \"org.eclipse.elk.interactive\"                                  true\n   \"org.eclipse.elk.layered.cycleBreaking.strategy\"               \"DEPTH_FIRST\"\n   \"org.eclipse.elk.layered.crossingMinimization.strategy\"        \"LAYER_SWEEP\"\n   \"org.eclipse.elk.layered.crossingMinimization.semiInteractive\" true\n   \"org.eclipse.elk.radial.compactor\"                             \"RADIAL_COMPACTION\"})\n\n\nsource: content/idea/graph/layout/elk.clj"
  },
  {
    "objectID": "idea/civitas/explorer.html",
    "href": "idea/civitas/explorer.html",
    "title": "Civitas Explorer",
    "section": "",
    "text": "(defn html [s content]\n  [:foreignObject {:x      (- s)\n                   :y      (- s)\n                   :width  (* 2 s)\n                   :height (* 2 s)}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width           \"100%\"\n                  :height          \"100%\"\n                  :text-align      :center\n                  :display         :flex\n                  :justify-content :center\n                  :align-items     :center\n                  :overflow        :visible}}\n    content]])\n\n\n(comment\n  (kind/hiccup [:div (for [i (range 10)]\n                       (/ i 0))]))\n\nOfficial Clojure DocumentationClojure for the Brave and TrueTransducers ExplainedClojureScript GuideReagent Documentationre-frame: A React FrameworkLuminus Web FrameworkTablecloth: Dataframe LibraryNotespace Live Notebookstech.ml Machine Learningdeps.edn ReferenceCIDER for Emacsshadow-cljs Build ToolKaocha Test RunnerSciCloj CommunityClojureCamp EventsClojureTV YouTubeClojurians SlackPracticalli TutorialsJVM Performance GuideComponent LibrarynREPL ProtocolDatomic DatabaseXTDB Documentation\n\n\nidtitleurlformattopicsleveldepends-onclj-docsOfficial Clojure Documentationhttps://clojure.org/guides/getting_startedreference[:core]\n0brave-clojureClojure for the Brave and Truehttps://www.braveclojure.com/interactive-book[:core :core/fp]\n1transducersTransducers Explainedhttps://www.youtube.com/watch?v=6mTbuzafcIIvideo[:core :core/fp]\n2[\"clj-docs\"]\nreagent-docsReagent Documentationhttps://reagent-project.github.io/library-docs[:web :web/frontend]\n1re-framere-frame: A React Frameworkhttps://day8.github.io/re-frame/library-docs[:web :web/frontend]\n2[\"reagent-docs\"]\nluminusLuminus Web Frameworkhttps://luminusweb.com/framework[:web :web/backend]\n2tableclothTablecloth: Dataframe Libraryhttps://github.com/scicloj/tableclothlibrary-docs[:data :data/analysis]\n1notespaceNotespace Live Notebookshttps://github.com/scicloj/notespaceinteractive-tool[:data :data/viz]\n2tech.mltech.ml Machine Learninghttps://github.com/techascent/tech.mllibrary-docs[:data :data/ml]\n3deps-edndeps.edn Referencehttps://clojure.org/reference/deps_and_clireference[:tooling]\n0ciderCIDER for Emacshttps://docs.cider.mx/tool-docs[:tooling :tooling/repl]\n1shadow-cljsshadow-cljs Build Toolhttps://shadow-cljs.github.io/docs/UsersGuide.htmltool-docs[:tooling :tooling/build]\n2sciclojSciCloj Communityhttps://scicloj.github.io/community[:community :community/orgs]\n0clojure-campClojureCamp Eventshttps://clojurecamp.berlin/community[:community :community/events]\n1clojure-tvClojureTV YouTubehttps://www.youtube.com/user/ClojureTVvideo-channel[:community :community/learning]\n0clojuriansClojurians Slackhttps://clojurians.net/community[:community :community/chat]\n0practicalliPracticalli Tutorialshttps://practical.li/tutorials[:community :community/learning]\n1jvm-tuningJVM Performance Guidehttps://clojure.org/reference/jvm_programmingguide[:systems :systems/production]\n3componentComponent Libraryhttps://github.com/stuartsierra/componentlibrary-docs[:systems :systems/design]\n2nreplnREPL Protocolhttps://nrepl.org/protocol[:systems :systems/tooling]\n2datomicDatomic Databasehttps://docs.datomic.com/cloud/database[:systems :systems/data :data/db]\n3clojurescriptClojureScript Guidehttps://clojurescript.org/reference[:core :web :tooling]\n1kaochaKaocha Test Runnerhttps://github.com/lambdaisland/kaochatool-docs[:tooling :tooling/testing]\n2xtdbXTDB Documentationhttps://xtdb.com/database[:systems :systems/data :data/db]\n3\n\n\n\nsource: content/idea/civitas/explorer.clj"
  },
  {
    "objectID": "libs.html",
    "href": "libs.html",
    "title": "Libraries and Tools",
    "section": "",
    "text": "Content related to Clojure libraries and tools. This section collects notebooks that aren’t time-sensitive posts.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nFlow to ELK data transformation\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nPrinting Objects in Clojure\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "lib/core/async/flow/visualization/flow_elk.html",
    "href": "lib/core/async/flow/visualization/flow_elk.html",
    "title": "Flow to ELK data transformation",
    "section": "",
    "text": "(defn id-for [x]\n  (cond (keyword? x) (str (symbol x))\n        (vector? x) (str/join \"_\" (map id-for x))\n        (string? x) x\n        :else (str x)))\n\nproblem: graph layout algorithms have different requirements complex: label placement may be important, handled by layout, different for parents complex: ports may be useful or unsupported problem: html nodes need to be measured for layout problem: my data is not the layout is not the view problem: arbitrary data is not transferred problem: visualizations are trees, graphs are not always trees\nidea: A standard view model for graphs (not trees) the view model should just be nodes and edges - port nodes with special properties - what about groups? nodes that have children - ordering parents have children… not a nesting – the viewmodel can calculate what are the parents of x, what are the children – nodes can have a parent identifier. we represent the relation not the hierarchy ** ELK models are hierarchy &lt;– problematic\nWhen do we care?\nA (parents #{B}) B (parents #{C}) C D (parents #{B, C})\n“Parents are an edge with a special property”\nB -&gt; A C -&gt; B C -&gt; D B -&gt; D\nWe represent them as groups\nTrick: layout with parent edges, don’t draw them, but do create borders. Problem: incorrect overlaps, can be solved with Veroni\nEverything is a node or edge, some logic to determine how it’s displayed, and ordering Can be general Output from layout algorithms will need to be transformed\nidea: Structural merge (like Reagent, respecting keys) can combine layout and data\nReagent: define component f (data)\n=&gt; f1 [ [:div {:key 1} “apples”] [:div {:key 2} “pear”] ]\n=&gt; f2 [ [:div {:key 2} “pears”] [:div {:key 1} “apples] ] compute the updates, with the keys: swap the dom elements and update pear to pears without the keys: replace everything\nStructural merge:\n(merge-structure {:a [{:key 1, :happy “yes”} {:key 2, :happy “no”}]} {:a [{:key 2, :happy “absolutely”}]}) =&gt; {:a [{:key 1, :happy “yes”} {:key 2, :happy “absolutely”}]}\n(merge-structure g (layout g)) =&gt; adds x and y, keeps my data.\ntree {:children [{:label … }]} layout {:children [{:label …, :x 1, :y 2}]\n(merge structure\n(merge-dissoc removals\n(merge-replace replacement\nsupporting functions (optional) {:a #(…)}\n\nsource: content/lib/core/async/flow/visualization/flow_elk.clj"
  },
  {
    "objectID": "lib/core/async/flow/visualization.html",
    "href": "lib/core/async/flow/visualization.html",
    "title": "Core Async Flow Visualization",
    "section": "",
    "text": "Visualizing core.async.flows\n\n(defn id-for [x]\n  (cond (keyword? x) (str (symbol x))\n        (vector? x) (str/join \"_\" (map id-for x))\n        (string? x) x\n        :else (str x)))\n\nwould be more interesting if we show the buffer state\n\n(defn conn-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ;; TODO: add channel state\n    ^:kind/table\n    {:row-maps (vec (for [[from to] conns]\n                      {:source (id-for from)\n                       :target (id-for to)}))}))\n\n\n(defn proc-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ^:kind/table\n    {:column-names [\"process\" \"start params\" \"in chans\" \"out chans\"]\n     :row-vectors  (for [[proc-key proc-chans] (group-by first all-proc-chans)]\n                     (let [{:keys [args proc]} (get procs proc-key)\n                           {:keys [desc]} proc\n                           {:keys [params ins outs]} desc]\n                       [(name proc-key)\n                        ^:kind/hiccup\n                        [:div\n                         (for [[k param] params]\n                           [:div\n                            [:div [:strong (name k)] \": \" (get args k)]\n                            [:div param]])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] ins]\n                                [:div [:strong (name k)] \": \" v])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] outs]\n                                [:div [:strong (name k)] \": \" v])]]))}))\n\n\n(defn elkg [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)\n        chans-as-ports true\n        with-content false]\n    {:id            \"G\"\n     :layoutOptions {:elk.algorithm         \"layered\"\n                     :elk.direction         \"DOWN\"\n                     :elk.hierarchyHandling \"INCLUDE_CHILDREN\"}\n     :children\n     (for [[proc-key proc-chans] (group-by first all-proc-chans)]\n       (let [{:keys [args proc]} (get procs proc-key)\n             {:keys [desc]} proc\n             {:keys [params ins outs]} desc\n             width 100\n             height 100\n             content (when with-content\n                       [{:id            (str (name proc-key) \"_content\")\n                         :width         (- width 5)\n                         :height        (- height 5)\n                         ;; nope, do it by id\n                         :layoutOptions {:content (str/join \\newline\n                                                            (for [[k param] params]\n                                                              (str (name k) \" (\" (get args k) \") \" param)))}}])\n             children (for [[_ chan :as proc-chan] proc-chans]\n                        {:id       (id-for proc-chan)\n                         :width    20\n                         :height   20\n                         :labels   [{:text (name chan)}]\n                         :children (vec (when with-content\n                                          [{:id            (str (id-for proc-chan) \"_content\")\n                                            :width         20\n                                            :height        20\n                                            ;; nope, do it by id\n                                            :layoutOptions {:content (str (name chan)\n                                                                          \\newline \\newline\n                                                                          (or (get outs chan)\n                                                                              (get ins chan)))}}]))})]\n         {:id            (id-for proc-key)\n          :width         100\n          :height        100\n          :layoutOptions {:org.eclipse.elk.nodeLabels.placement \"OUTSIDE V_TOP H_LEFT\"}\n          :labels        [{:text (name proc-key)}]\n          :children      (vec (concat content (when (not chans-as-ports) children)))\n\n          :ports\n          (vec (when chans-as-ports children))}))\n     :edges\n     (vec (for [[from to] conns]\n            {:id      (id-for [from to])\n             :sources [(id-for from)]\n             :targets [(id-for to)]}))}))\n\n\nsource: content/lib/core/async/flow/visualization.clj"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "An open effort to structure learning resources with meaningful connections.\nExplore the Clojure Civitas Website\n\n\n\n\nNavigate your own path through interconnected topics.\n\n\n\n\n\nWrite notebooks and place them in context, linking knowledge.\n\n\n\n\n\nThe best resources rise through collective refinement.\n\n\n\n\n\n\nYour perspective matters.\n\n\nAdd to or modify db.edn\n\n\n\nAdd a notebook in the /content folder.\nSee the Clay Documentation for information on how to interactively visualize the notebook as you write it.\n\n\n\nclojure -M:clay -a [:markdown]\nquarto preview site\n\n\n\nMerged pull requests are shown on the website via a workflow.\n\n\n\n\n\nExploramus, Communicamus, Crescimus We explore, we share, we grow.\n\nCivitas Clojure offers a hassle-free way to host and share your notebooks without the overhead of creating a new project each time. By providing a shared, well-organized platform, it lets you focus on your ideas and code while automatically publishing your work to GitHub Pages. This streamlines collaboration, increases visibility, and makes contributing simple and efficient—so you can spend less time on setup and more time creating.\nLearning technical subjects involves navigating complex webs of concepts. Currently, resources for learning Clojure exist as isolated articles, unconnected tutorials, or flat lists that do not capture how ideas relate to each other. This makes it difficult for learners to determine logical next steps or see how topics connect. Teachers and curriculum designers face similar challenges when trying to organize material in ways that reflect actual dependencies and alternatives.\nCivitas approaches this problem by implementing a structured knowledge base where resources are explicitly linked based on their conceptual relationships. The hexagonal grid interface provides a visual representation of these connections, allowing users to naturally discover related content. Each resource includes metadata to indicate prerequisites, alternatives, and deeper explorations.\nThis structure serves several practical purposes. Learners can see multiple valid paths through the material. Teachers can construct guided sequences while maintaining visibility of adjacent concepts. The community can improve resources incrementally by adding or refining connections. The system is designed to grow organically as new relationships are identified and documented.\nThe value lies not in any single feature, but in making the existing ecosystem of learning resources more navigable and interconnected.\n\n\n\n\nIt is not a goal to centralize Clojure knowledge creation. It is a goal to provide a welcoming pattern that works with other communities and users. ClojureCivitas can be used as a library to simplify publishing your own garden of content.\n\n\n\n\n\n\n\n\n\n\n\n\nDirectory\nDescription\n\n\n\n\nsrc\nCode for building a website and database\n\n\ncontent\nSource root for notebooks (Clojure and Markdown), images, data files\n\n\ncontent/idea\nThe idea namespace hosts explorations, concepts and insights\n\n\ncontent/lib\nThe lib namespace is tied to libraries, tools, and projects\n\n\nsite\nTemporary build target for the Quarto website\n\n\n\nShared images can go in content/images, but prefer images and data files as siblings to your namespace.\nThe difference between a posts and a page is identified by the presence or absence of date metadata.\nNamespace selection for notebooks follow standard Clojure namespace conventions to avoid conflicts. Choose namespaces that fit with the content-first hierarchy. Files are grouped by what they’re about (not who wrote them or where they were presented). Author, date, tags and categories are included in metadata and will be used for grouping, filter of views.\nDisambiguation: If a topic exists, qualify with additional context.\nCivitas invokes Clay to convert Clojure notebooks into Markdown files, placing them in the site directory. This site directory serves as a build folder for Quarto. Avoid adding files directly to site.\nStatic assets (such as images or data files) should be placed in the content directory. During the build process, any files in the content directory that are not Clojure files, are copied into the site directory. Quarto then builds the Markdown in site into HTML, which is placed in _site before deploying it to GitHub Pages.\nDuring development, Clay serves HTML from the temp directory, which is git ignored.\nGoal: Align with Clojure’s code organization while allowing organic, practical growth.\n\n\n\nFollow the Quarto convention of categories, tags, and keywords. Fixed categories; community, clojure, data, system, tooling, web. Tags; flexible, open-ended for finer-grained labeling (e.g. frontend, reagent). Keywords; for SEO or search indexing; typically fewer and focused on discoverability.\nTags and metadata are the preferred organization principle: Categories, Links, and Tags\nGoal: Constellations, not cabinets.\n\n\n\nA single deps.edn file is shared across all notebooks.\nPros:\n\nSimplifies website builds.\nWorks for authoring as well as building.\n\nCons:\n\nVersion conflicts must be manually resolved.\nOnly one version per dependency.\nNotebooks aren’t self-contained.\n\nFuture:\n\nSupport additional directories under standalone with their own deps.edn.\nRegression testing would help when versions update.\n\nGoal: Minimize friction in authoring while ensuring publishable reproducibility.\n\n\n\n\nCopyright © 2025 Timothy Pratley\nDistributed under the Eclipse Public License version 1.0."
  },
  {
    "objectID": "about.html#welcome-to-clojure-civitas",
    "href": "about.html#welcome-to-clojure-civitas",
    "title": "About",
    "section": "",
    "text": "An open effort to structure learning resources with meaningful connections.\nExplore the Clojure Civitas Website\n\n\n\n\nNavigate your own path through interconnected topics.\n\n\n\n\n\nWrite notebooks and place them in context, linking knowledge.\n\n\n\n\n\nThe best resources rise through collective refinement."
  },
  {
    "objectID": "about.html#contribute",
    "href": "about.html#contribute",
    "title": "About",
    "section": "",
    "text": "Your perspective matters.\n\n\nAdd to or modify db.edn\n\n\n\nAdd a notebook in the /content folder.\nSee the Clay Documentation for information on how to interactively visualize the notebook as you write it.\n\n\n\nclojure -M:clay -a [:markdown]\nquarto preview site\n\n\n\nMerged pull requests are shown on the website via a workflow."
  },
  {
    "objectID": "about.html#rationale",
    "href": "about.html#rationale",
    "title": "About",
    "section": "",
    "text": "Exploramus, Communicamus, Crescimus We explore, we share, we grow.\n\nCivitas Clojure offers a hassle-free way to host and share your notebooks without the overhead of creating a new project each time. By providing a shared, well-organized platform, it lets you focus on your ideas and code while automatically publishing your work to GitHub Pages. This streamlines collaboration, increases visibility, and makes contributing simple and efficient—so you can spend less time on setup and more time creating.\nLearning technical subjects involves navigating complex webs of concepts. Currently, resources for learning Clojure exist as isolated articles, unconnected tutorials, or flat lists that do not capture how ideas relate to each other. This makes it difficult for learners to determine logical next steps or see how topics connect. Teachers and curriculum designers face similar challenges when trying to organize material in ways that reflect actual dependencies and alternatives.\nCivitas approaches this problem by implementing a structured knowledge base where resources are explicitly linked based on their conceptual relationships. The hexagonal grid interface provides a visual representation of these connections, allowing users to naturally discover related content. Each resource includes metadata to indicate prerequisites, alternatives, and deeper explorations.\nThis structure serves several practical purposes. Learners can see multiple valid paths through the material. Teachers can construct guided sequences while maintaining visibility of adjacent concepts. The community can improve resources incrementally by adding or refining connections. The system is designed to grow organically as new relationships are identified and documented.\nThe value lies not in any single feature, but in making the existing ecosystem of learning resources more navigable and interconnected."
  },
  {
    "objectID": "about.html#embracing-alternatives",
    "href": "about.html#embracing-alternatives",
    "title": "About",
    "section": "",
    "text": "It is not a goal to centralize Clojure knowledge creation. It is a goal to provide a welcoming pattern that works with other communities and users. ClojureCivitas can be used as a library to simplify publishing your own garden of content."
  },
  {
    "objectID": "about.html#design",
    "href": "about.html#design",
    "title": "About",
    "section": "",
    "text": "Directory\nDescription\n\n\n\n\nsrc\nCode for building a website and database\n\n\ncontent\nSource root for notebooks (Clojure and Markdown), images, data files\n\n\ncontent/idea\nThe idea namespace hosts explorations, concepts and insights\n\n\ncontent/lib\nThe lib namespace is tied to libraries, tools, and projects\n\n\nsite\nTemporary build target for the Quarto website\n\n\n\nShared images can go in content/images, but prefer images and data files as siblings to your namespace.\nThe difference between a posts and a page is identified by the presence or absence of date metadata.\nNamespace selection for notebooks follow standard Clojure namespace conventions to avoid conflicts. Choose namespaces that fit with the content-first hierarchy. Files are grouped by what they’re about (not who wrote them or where they were presented). Author, date, tags and categories are included in metadata and will be used for grouping, filter of views.\nDisambiguation: If a topic exists, qualify with additional context.\nCivitas invokes Clay to convert Clojure notebooks into Markdown files, placing them in the site directory. This site directory serves as a build folder for Quarto. Avoid adding files directly to site.\nStatic assets (such as images or data files) should be placed in the content directory. During the build process, any files in the content directory that are not Clojure files, are copied into the site directory. Quarto then builds the Markdown in site into HTML, which is placed in _site before deploying it to GitHub Pages.\nDuring development, Clay serves HTML from the temp directory, which is git ignored.\nGoal: Align with Clojure’s code organization while allowing organic, practical growth.\n\n\n\nFollow the Quarto convention of categories, tags, and keywords. Fixed categories; community, clojure, data, system, tooling, web. Tags; flexible, open-ended for finer-grained labeling (e.g. frontend, reagent). Keywords; for SEO or search indexing; typically fewer and focused on discoverability.\nTags and metadata are the preferred organization principle: Categories, Links, and Tags\nGoal: Constellations, not cabinets.\n\n\n\nA single deps.edn file is shared across all notebooks.\nPros:\n\nSimplifies website builds.\nWorks for authoring as well as building.\n\nCons:\n\nVersion conflicts must be manually resolved.\nOnly one version per dependency.\nNotebooks aren’t self-contained.\n\nFuture:\n\nSupport additional directories under standalone with their own deps.edn.\nRegression testing would help when versions update.\n\nGoal: Minimize friction in authoring while ensuring publishable reproducibility."
  },
  {
    "objectID": "about.html#license",
    "href": "about.html#license",
    "title": "About",
    "section": "",
    "text": "Copyright © 2025 Timothy Pratley\nDistributed under the Eclipse Public License version 1.0."
  },
  {
    "objectID": "lib/core/async/flow/example/stats.html",
    "href": "lib/core/async/flow/example/stats.html",
    "title": "Core Async Flow Stats Example",
    "section": "",
    "text": "Core async flow stats example\nAdapted from https://github.com/puredanger/flow-example\n\n^:kind/video\n{:youtube-id   \"lXFwf3O4BVY\"\n :iframe-width \"100%\"}\n\n\n\n(defn stat-gen\n  \"Generates a random value between min (inclusive) and max (exclusive)\n  and writes it to out chan, waiting wait ms between until stop-atom is flagged.\"\n  ([out min max wait stop-atom]\n   (loop []\n     (let [val (+ min (rand-int (- max min)))\n           put (a/&gt;!! out val)]\n       ;(println \"stat-gen\" (System/identityHashCode stop-atom) val put (not @stop-atom))\n       (when (and put (not @stop-atom))\n         (^[long] Thread/sleep wait)\n         (recur))))))\n\n\n(defn source\n  \"Source proc for random stats\"\n  ;; describe\n  ([] {:params {:min  \"Min value to generate\"\n                :max  \"Max value to generate\"\n                :wait \"Time in ms to wait between generating\"}\n       :outs   {:out \"Output channel for stats\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:stat (a/chan 100)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [min max wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"transition\" transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (stat-gen (:stat in-ports) min max wait stop-atom))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   ;(println \"source transform\" in msg)\n   [state (when (= in :stat) {:out [msg]})]))\n\n\n(defn aggregator\n  ;; describe\n  ([] {:params   {:min \"Min value, alert if lower\"\n                  :max \"Max value, alert if higher\"}\n       :ins      {:stat \"Channel to receive stat values\"\n                  :poke \"Channel to poke when it is time to report a window of data to the log\"}\n       :outs     {:alert \"Notify of value out of range {:val value, :error :high|:low\"}\n       :workload :compute\n       })\n\n  ;; init\n  ([args] (assoc args :vals []))\n\n  ;; transition\n  ([state transition] state)\n\n  ;; transform\n  ([{:keys [min max vals] :as state} input-id msg]\n   (case input-id\n     :stat (let [state' (assoc state :vals (conj vals msg))\n                 msgs (cond\n                        (&lt; msg min) {:alert [{:val msg, :error :low}]}\n                        (&lt; max msg) {:alert [{:val msg, :error :high}]}\n                        :else nil)]\n             [state' msgs])\n     :poke [(assoc state :vals [])\n            {:clojure.core.async.flow/report (if (empty? vals)\n                                               [{:count 0}]\n                                               [{:avg   (/ (double (reduce + vals)) (count vals))\n                                                 :count (count vals)}])}]\n     [state nil])))\n\n\n(comment\n  ;; test aggregator alert case - no channels involved\n  (let [state {:min 1 :max 5 :vals []}\n        [state' msgs'] (aggregator state :stat 100)]\n    (assert (= msgs' {:alert [{:val 100, :error :high}]})))\n  )\n\n\n(defn scheduler\n  ;; describe\n  ([] {:params {:wait \"Time to wait between pokes\"}\n       :outs   {:out \"Poke channel, will send true when the alarm goes off\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:alarm (a/chan 10)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"scheduler transition\" transition state transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (loop []\n                 (let [put (a/&gt;!! (:alarm in-ports) true)]\n                   (when (and put (not @stop-atom))\n                     (^[long] Thread/sleep wait)\n                     (recur)))))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   [state (when (= in :alarm) {:out [true]})]))\n\n\n(defn printer\n  ;; describe\n  ([] {:params {:prefix \"Log message prefix\"}\n       :ins    {:in \"Channel to receive messages\"}})\n\n  ;; init\n  ([state] state)\n\n  ;; transition\n  ([state _transition] state)\n\n  ;; transform\n  ([{:keys [prefix] :as state} _in msg]\n   (println prefix msg)\n   [state nil]))\n\n\n(def config\n  {:procs {:generator  {:args {:min 0 :max 12 :wait 500} :proc (flow/process #'source)}\n           :aggregator {:args {:min 1 :max 10} :proc (flow/process #'aggregator)}\n           :scheduler  {:args {:wait 3000} :proc (flow/process #'scheduler)}\n           :notifier   {:args      {:prefix \"Alert: \"} :proc (flow/process #'printer)\n                        :chan-opts {:in {:buf-or-n (a/sliding-buffer 3)}}}}\n   :conns [[[:generator :out] [:aggregator :stat]]\n           [[:scheduler :out] [:aggregator :poke]]\n           [[:aggregator :alert] [:notifier :in]]]})\n\n\n(defn create-flow\n  []\n  (flow/create-flow config))\n\n\n(comment\n  (def f (create-flow))\n  (def chs (flow/start f))\n  (flow/resume f)\n  (flow/pause f)\n  (flow/stop f)\n\n  (def server (mon/start-server {:flow f}))\n  (mon/stop-server server)\n\n  @(flow/inject f [:aggregator :poke] [true])\n  @(flow/inject f [:aggregator :stat] [\"abc1000\"])          ;; trigger an alert\n  @(flow/inject f [:notifier :in] [:sandwich])\n\n  (def report-chan (:report-chan chs))\n  (flow/ping f)\n  (a/poll! report-chan)\n  (def error-chan (:error-chan chs))\n  (a/poll! error-chan)\n\n  (flow/stop f)\n  (a/close! stat-chan)\n\n  @(flow/inject f [:aggregator :poke] [true])\n\n  (require '[clojure.datafy :as datafy])\n  (datafy/datafy f)\n\n  (require '[clojure.core.async.flow-static :refer [graph]])\n  (graph f)\n\n  )\n\n\nsource: content/lib/core/async/flow/example/stats.clj"
  },
  {
    "objectID": "lib/core/async/flow/exploration.html",
    "href": "lib/core/async/flow/exploration.html",
    "title": "Core Async Flow Exploration",
    "section": "",
    "text": "Clojure’s async flows are Directed Acyclic Graphs (DAGs) of channel operations. The new flow-monitor can visualize these flows.\n\n\n\nBasic flow structure (processes, channels, connections)\nStatic visualization of a sample flow\nEvolution as the flow changes\n\n\n(def stats-flow\n  (flow/create-flow stats/config))\n\n\n(fv/proc-table stats-flow)\n\n\n\n\n\n\n\n\n\n\n\n\nprocess\nstart params\nin chans\nout chans\n\n\n\n\nnotifier\n\n\n\nprefix: Alert:\n\n\nLog message prefix\n\n\n\n\n\nin: Channel to receive messages\n\n\n\n\n\n\n\naggregator\n\n\n\nmin: 1\n\n\nMin value, alert if lower\n\n\n\n\nmax: 10\n\n\nMax value, alert if higher\n\n\n\n\n\nstat: Channel to receive stat values\n\n\npoke: Channel to poke when it is time to report a window of data to the log\n\n\n\n\nalert: Notify of value out of range {:val value, :error :high|:low\n\n\n\n\nscheduler\n\n\n\nwait: 3000\n\n\nTime to wait between pokes\n\n\n\n\n\n\n\n\nout: Poke channel, will send true when the alarm goes off\n\n\n\n\ngenerator\n\n\n\nmin: 0\n\n\nMin value to generate\n\n\n\n\nmax: 12\n\n\nMax value to generate\n\n\n\n\nwait: 500\n\n\nTime in ms to wait between generating\n\n\n\n\n\n\n\n\nout: Output channel for stats\n\n\n\n\n\n\n\n\n(fv/conn-table stats-flow)\n\n\n\n\n\n\nsource\ntarget\n\n\n\n\ngenerator_out\naggregator_stat\n\n\nscheduler_out\naggregator_poke\n\n\naggregator_alert\nnotifier_in\n\n\n\n\n\n\n(def chs (flow/start stats-flow))\n\ntrigger an alert\n\n(def report-chan (:report-chan chs))\n\n\n(flow/ping stats-flow)\n\n\n{:aggregator\n #:clojure.core.async.flow{:pid :aggregator,\n                           :status :paused,\n                           :state\n                           {:min 1,\n                            :max 10,\n                            :clojure.core.async.flow/pid :aggregator,\n                            :vals []},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}},\n                            :poke\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:alert\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}}},\n :generator\n #:clojure.core.async.flow{:pid :generator,\n                           :status :paused,\n                           :state\n                           {:min 0,\n                            :max 12,\n                            :wait 500,\n                            :clojure.core.async.flow/pid :generator,\n                            :clojure.core.async.flow/in-ports\n                            {:stat\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 100}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 100}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}},\n :notifier\n #:clojure.core.async.flow{:pid :notifier,\n                           :status :paused,\n                           :state\n                           {:prefix \"Alert: \",\n                            :clojure.core.async.flow/pid :notifier},\n                           :count 0,\n                           :ins\n                           {:in\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}},\n                           :outs {}},\n :scheduler\n #:clojure.core.async.flow{:pid :scheduler,\n                           :status :paused,\n                           :state\n                           {:wait 3000,\n                            :clojure.core.async.flow/pid :scheduler,\n                            :clojure.core.async.flow/in-ports\n                            {:alarm\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 10}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:alarm\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}}}\n\n\n(async/poll! report-chan)\n\n\nnil\n\n\n(def error-chan (:error-chan chs))\n\n\n(async/poll! error-chan)\n\n\nnil\n\n(flow/stop stats-flow) (async/close! stat-chan)\n@(flow/inject stats-flow [:aggregator :poke] [true])\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step lib.core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step lib.core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step lib.core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step lib.core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans\n {:ins\n  {[:aggregator :stat]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :poke]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:notifier :in]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}}},\n  :outs\n  {[:generator :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :alert]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}},\n   [:scheduler :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}}},\n  :error\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}},\n  :report\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}}}}\n\n\nsource: content/lib/core/async/flow/exploration.clj"
  },
  {
    "objectID": "lib/core/async/flow/exploration.html#what-well-explore",
    "href": "lib/core/async/flow/exploration.html#what-well-explore",
    "title": "Core Async Flow Exploration",
    "section": "",
    "text": "Basic flow structure (processes, channels, connections)\nStatic visualization of a sample flow\nEvolution as the flow changes\n\n\n(def stats-flow\n  (flow/create-flow stats/config))\n\n\n(fv/proc-table stats-flow)\n\n\n\n\n\n\n\n\n\n\n\n\nprocess\nstart params\nin chans\nout chans\n\n\n\n\nnotifier\n\n\n\nprefix: Alert:\n\n\nLog message prefix\n\n\n\n\n\nin: Channel to receive messages\n\n\n\n\n\n\n\naggregator\n\n\n\nmin: 1\n\n\nMin value, alert if lower\n\n\n\n\nmax: 10\n\n\nMax value, alert if higher\n\n\n\n\n\nstat: Channel to receive stat values\n\n\npoke: Channel to poke when it is time to report a window of data to the log\n\n\n\n\nalert: Notify of value out of range {:val value, :error :high|:low\n\n\n\n\nscheduler\n\n\n\nwait: 3000\n\n\nTime to wait between pokes\n\n\n\n\n\n\n\n\nout: Poke channel, will send true when the alarm goes off\n\n\n\n\ngenerator\n\n\n\nmin: 0\n\n\nMin value to generate\n\n\n\n\nmax: 12\n\n\nMax value to generate\n\n\n\n\nwait: 500\n\n\nTime in ms to wait between generating\n\n\n\n\n\n\n\n\nout: Output channel for stats\n\n\n\n\n\n\n\n\n(fv/conn-table stats-flow)\n\n\n\n\n\n\nsource\ntarget\n\n\n\n\ngenerator_out\naggregator_stat\n\n\nscheduler_out\naggregator_poke\n\n\naggregator_alert\nnotifier_in\n\n\n\n\n\n\n(def chs (flow/start stats-flow))\n\ntrigger an alert\n\n(def report-chan (:report-chan chs))\n\n\n(flow/ping stats-flow)\n\n\n{:aggregator\n #:clojure.core.async.flow{:pid :aggregator,\n                           :status :paused,\n                           :state\n                           {:min 1,\n                            :max 10,\n                            :clojure.core.async.flow/pid :aggregator,\n                            :vals []},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}},\n                            :poke\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:alert\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}}},\n :generator\n #:clojure.core.async.flow{:pid :generator,\n                           :status :paused,\n                           :state\n                           {:min 0,\n                            :max 12,\n                            :wait 500,\n                            :clojure.core.async.flow/pid :generator,\n                            :clojure.core.async.flow/in-ports\n                            {:stat\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 100}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 100}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}},\n :notifier\n #:clojure.core.async.flow{:pid :notifier,\n                           :status :paused,\n                           :state\n                           {:prefix \"Alert: \",\n                            :clojure.core.async.flow/pid :notifier},\n                           :count 0,\n                           :ins\n                           {:in\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}},\n                           :outs {}},\n :scheduler\n #:clojure.core.async.flow{:pid :scheduler,\n                           :status :paused,\n                           :state\n                           {:wait 3000,\n                            :clojure.core.async.flow/pid :scheduler,\n                            :clojure.core.async.flow/in-ports\n                            {:alarm\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 10}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:alarm\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}}}\n\n\n(async/poll! report-chan)\n\n\nnil\n\n\n(def error-chan (:error-chan chs))\n\n\n(async/poll! error-chan)\n\n\nnil\n\n(flow/stop stats-flow) (async/close! stat-chan)\n@(flow/inject stats-flow [:aggregator :poke] [true])\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step lib.core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step lib.core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step lib.core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step lib.core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans\n {:ins\n  {[:aggregator :stat]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :poke]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:notifier :in]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}}},\n  :outs\n  {[:generator :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :alert]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}},\n   [:scheduler :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}}},\n  :error\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}},\n  :report\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}}}}\n\n\nsource: content/lib/core/async/flow/exploration.clj"
  },
  {
    "objectID": "lib/clojure+/print/objects_and_protocols.html",
    "href": "lib/clojure+/print/objects_and_protocols.html",
    "title": "Printing Objects in Clojure",
    "section": "",
    "text": "Printing Objects in Clojure\nThe Clojure default for printing objects is noisy:\n\n(Object.)\n\n\n#object[java.lang.Object 0x4bbe1bd1 \"java.lang.Object@4bbe1bd1\"]\n\nThe syntax is #object[CLASS-NAME HASH toString())] and as you can see, the toString of an Object is CLASS-NAME@HASH. This can get pretty ugly:\n\n(async/chan)\n\n\n#object[clojure.core.async.impl.channels.ManyToManyChannel 0x2fa3d956 \"clojure.core.async.impl.channels.ManyToManyChannel@2fa3d956\"]\n\nclojure-plus provides print-methods to improve printing many things.\n\n(comment\n  (require 'clojure+.print)\n  (clojure+.print/install-printers!))\n\nOnce activated, we can print functions, atoms, namespaces, and more sensibly. Clojure Plus adds printers for many types, but no printer is provided for Object, which remains as Clojure’s default printing method. There are plenty of objects left over that print messily.\nIt’s not hard to provide an Object print-method:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object [\")\n  (.write w (.getName (class x)))\n  (.write w \"]\"))\n\n\n#object [clojure.lang.MultiFn]\n\n\n(async/chan)\n\n\n#object [clojure.core.async.impl.channels.ManyToManyChannel]\n\nMuch nicer! In my opinion this is a big improvement. Especially in the world of notebooks where we like to show things as we go, but also just keeping a tidy REPL or looking into data that contains objects.\n\n(stats/create-flow)\n\n\n#object [clojure.core.async.flow.impl$create_flow$reify__22679]\n\nHmmmm. not so nice. We’ll dig into this further below. But we also need to be aware that Clojure munges it’s names to make Java valid names. This matters for some things:\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class)\n    (.getName))\n\n\n\"lib.clojure_PLUS_.print.objects_and_protocols$eval26290$_PERCENT__PERCENT___26291$_PERCENT__PERCENT__PERCENT___26292\"\n\nWhoa, that’s pretty gross. We’d prefer to demunge the names at least.\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name))\n\n\n\"lib.clojure+.print.objects-and-protocols/eval26297/%%--26298/%%%--26299\"\n\nNotice the /evalNNNNN/ part? To create a function, Clojure creates a new class. The /evalNNNNN/ counts every time it evaluates. This is useful in the sense that it identifies the class for that evaluation. But we almost never care for that detail (more on that later). For the same reason our strangely named functions have --NNNNN appended to them, because they are sub evaluations of the top-level evaluation.\nLet’s do away with that noise for the moment:\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name)\n    (remove-extraneous))\n\n\n\"lib.clojure+.print.objects-and-protocols/%%/%%%\"\n\nLooking better, I can actually see the (strange) name of the functions.\n\n(defn format-class-name ^String [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str (str/join \"$\" names))\n      (-&gt; s (str/split #\"\\.\") (last)))))\n\n\n(-&gt; (((fn aaa [] (fn bbb [] (fn ccc [])))))\n    (class-name)\n    (format-class-name))\n\n\n\"aaa$bbb$ccc\"\n\nLet’s hook this up to the print-method for Object:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object [\")\n  (.write w (-&gt; (class-name x) (format-class-name)))\n  (.write w \"]\"))\n\n\n#object [MultiFn]\n\n\n*ns*\n\n\n#object [Namespace]\n\n\n(((fn aaa [] (fn bbb [] (fn ccc [])))))\n\n\n#object [aaa$bbb$ccc]\n\n\n(stats/create-flow)\n\n\n#object [create-flow$reify]\n\nWhat is this? It’s a reified object that implements protocols. We can see this by the $reify part at the end. The description is not terrible, at least we know where it was made, which hints that it must be a flow. Can we do better?\nAFAIK the only way to check what protocols an object satisfies is to call satisfies? for every possible protocol:\n\n(defn all-protocol-vars [x]\n  (-&gt;&gt; (all-ns)\n       (mapcat ns-publics)\n       (vals)\n       (keep #(-&gt; % meta :protocol))\n       (distinct)\n       (filter #(satisfies? @% x))))\n\nOn the one hand, this is concerning for performance. On the other hand, at my REPL I don’t care about that, it’s faster than I can notice. Leaving aside those concerns, it returns quite a long list…\n\n(def stats-flow\n  (stats/create-flow))\n\n\n(all-protocol-vars stats-flow)\n\n\n(#'charred.api/PToJSON\n #'portal.runtime.cson/ToJson\n #'clojure.spec.alpha/Specize\n #'clojure.core.reducers/CollFold\n #'clojure.core.async.flow.impl.graph/Graph\n #'clojure.core.protocols/Navigable\n #'clojure.core.protocols/Datafiable\n #'clojure.core.protocols/CollReduce\n #'clojure.core.protocols/InternalReduce\n #'clojure.core.protocols/IKVReduce\n #'hiccup.compiler/HtmlRenderer\n #'nrepl.bencode/BencodeSerializable\n #'reitit.impl/IntoString\n #'clj-yaml.core/YAMLCodec\n #'portal.runtime.jvm.editor/IResolve\n #'clojure.tools.reader.reader-types/PushbackReaderCoercer\n #'clojure.tools.reader.reader-types/ReaderCoercer\n #'clojure.java.io/IOFactory\n #'clojure.data.json/JSONWriter\n #'hiccup.util/ToString\n #'hiccup.util/URLEncode\n #'fipp.ednize/IEdn)\n\nBut notice that one of them; #'clojure.core.async.flow.impl.graph/Graph just feels like it is the one we care about most. Furthermore, it shares a similar namespace with the classname. Let’s try matching by the namespace…\n\n(defn var-ns-name [v]\n  (-&gt; (meta v) (:ns) (ns-name)))\n\n\n(defn ns-match? [p x]\n  (-&gt; (var-ns-name p)\n      (str/starts-with? (.getPackageName (class x)))))\n\n\n(defn protocol-ns-matches [x]\n  (filter #(ns-match? % x) (all-protocol-vars x)))\n\n\n(protocol-ns-matches stats-flow)\n\n\n(#'clojure.core.async.flow.impl.graph/Graph)\n\nNice. In my opinion this is more representative of the object. The #' out front is unnecessary and can be removed…\n\n(defn var-sym [v]\n  (let [m (meta v)]\n    (symbol (str (ns-name (:ns m))) (str (:name m)))))\n\n\n(defn protocol-ns-match-names [x]\n  (-&gt;&gt; (protocol-ns-matches x)\n       (map var-sym)))\n\n\n(protocol-ns-match-names stats-flow)\n\n\n(clojure.core.async.flow.impl.graph/Graph)\n\nThe other protocol of interest is Datafiable, because it indicates I can get a data representation if I would like to.\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step lib.core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step lib.core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step lib.core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step lib.core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans {}}\n\nI think this one is so helpful that it should always be shown on objects, regardless of their type of other protocols, as a hint that it is possible to get more information. I wouldn’t want to print them as data by default, because it would be too spammy. And checking Datafiable is much less of a performance concern.\n\n(satisfies? clojure.core.protocols/Datafiable stats-flow)\n\n\ntrue\n\nBut there is a big problem… everything is Datafiable…\n\n(satisfies? clojure.core.protocols/Datafiable (Object.))\n\n\ntrue\n\nSo there is no way for us to know whether datafy/datafy will do anything useful or not. Sad. But we can improve the print-method to show protocols, bearing in mind it is a performance concern.\nShowing the reified protocol isn’t a big improvement, and probably not worth the performance. Probably not worth including in clojure-plus.\nEven if we don’t care to improve reify (due to performance), I think the Object printer should still be improved to align with the other printers.\nAre we giving up anything? Remember we removed the unique identifiers like /evalNNNNN/. When would those be useful? Hold onto your hats! We are about to try to find an Object by a class-name:\n\n(defn find-class [class-name]\n  (try\n    (Class/forName class-name false (clojure.lang.RT/baseLoader))\n    (catch ClassNotFoundException _ nil)))\n\n\n(defn ddd [x] (inc x))\n\n\n(type (find-class (-&gt; ddd (class) (.getName))))\n\n\njava.lang.Class\n\nWhy would you want to do that? I don’t know, but it’s pretty cool you have to admit. What’s also interesting is that we can get all Clojure classes: https://danielsz.github.io/2021-05-12T13_24.html\n\n(defn class-cache []\n  (some-&gt; (.getDeclaredField clojure.lang.DynamicClassLoader \"classCache\")\n          (doto (.setAccessible true))\n          (.get nil)))\n\n\n(key (first (class-cache)))\n\n\n\"cognitect.transit$read_handler\"\n\nAnd we can find them in memory a similar way:\n\n(defn find-in-memory-class\n  \"Finds a class by name in the DynamicClassLoader's memory cache\"\n  [class-name]\n  (let [method (.getDeclaredMethod clojure.lang.DynamicClassLoader\n                                   \"findInMemoryClass\"\n                                   (into-array Class [String]))\n        _ (.setAccessible method true)]\n    (.invoke method nil (into-array Object [class-name]))))\n\nRight, but why would you want to do that? Honestly I can’t imagine a reason. All of that to say, do we really want those unique identifiers printed out? No! If we need to find them, we can always look them up another way. We don’t need them polluting our REPL output.\n\nsource: content/lib/clojure+/print/objects_and_protocols.clj"
  },
  {
    "objectID": "idea/scicloj/noj/intro/getting-started-noj.html",
    "href": "idea/scicloj/noj/intro/getting-started-noj.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "Transcript of Noj reload executable\nHello code champs, number ninjas and data divers!\nImagine being able to experiment with Clojure without needing to install tooling, set up editors, or even know about deps.edn Sounds like a dream, right? Well, dream no more—meet Noj’s new Code Reload Executable!\nWe can skip the Clojure tooling and editor setup, but we do need to install the recommended Adoptive Java. Now we download the latest Noj jar from the Scicloj Noj GitHub releases page. Let’s check the jar is in the Downloads directory, and that we have java installed by executing java -version.\nLaunch Noj using java -jar and the path to the jar file. Pro tip, if you press tab while typing a path, it will autocomplete. Noj is running, it created a directory called notebooks, and it recommends we create a Clojure file there.\nI’ll create my file with Notepad, being careful to create a .clj file rather than a text file. When I saved that file, a browser window opened. Let’s put them side by side. Every time I save the file, the notebook updates.\nIf I’m interested in one particular top-level form, I can narrow the output by adding ,, anywhere in the form. And removing it renders the full notebook. And check this out—comments are rendered as Markdown. How cool is that? What an easy way to get coding!\nNoj isn’t just a notebook—it’s a fully featured data science environment. It includes interesting datasets that can be queried and the results shown as tables or even better as charts.\nNoj makes experimenting with Clojure easier than ever. No setup headaches, no complicated tooling—just pure coding joy.\nUntil next time, Keep on coding"
  },
  {
    "objectID": "idea/graph/layout/elk_svg.html",
    "href": "idea/graph/layout/elk_svg.html",
    "title": "ELK SVG",
    "section": "",
    "text": "^{:clay {:title \"ELK SVG\"\n         :quarto {:author   :timothypratley\n                  :category :clojure\n                  :tags     [:graphs :svg :visualization]}}}\n(ns idea.graph.layout.elk-svg\n  (:require [clojure.string :as str]\n            [scicloj.kindly.v4.kind :as kind]))\n\n\n(def default-styles\n  {:edge-shape-stroke      \"black\"\n   :edge-shape-fill        \"none\"\n   :node-shape-stroke      \"black\"\n   :node-shape-fill        \"white\"\n   :node-label-stroke      \"none\"\n   :node-label-fill        \"black\"\n   :node-label-font-size   \"12px\"\n   :node-label-font-family \"sans-serif\"\n   :port-shape-stroke      \"black\"\n   :port-shape-fill        \"white\"})\n\n\n(defn edge-path [{:keys [sections]}]\n  (let [[a & more] (for [{:keys [startPoint bendPoints endPoint]} sections\n                         {:keys [x y]} (concat [startPoint] bendPoints [endPoint])]\n                     (str x \",\" y))]\n    (str \"M\" a \"L\" (str/join \" \" more))))\n\n\n(defn edge [{:as e :keys [id]}]\n  [:g {:id id}\n   [:path {:d          (edge-path e)\n           :stroke     (:edge-shape-stroke default-styles)\n           :fill       (:edge-shape-fill default-styles)\n           :marker-end \"url(#edgeShapeMarker)\"}]])\n\n\n(defn edge-defs []\n  [:marker {:id           \"edgeShapeMarker\"\n            :markerWidth  10\n            :markerHeight 10\n            :refX         6\n            :refY         3\n            :orient       \"auto\"\n            :markerUnits  \"strokeWidth\"}\n   [:path {:d    \"M0,0 L0,6 L6,3 z\"\n           :fill (:edge-shape-stroke default-styles)}]])\n\n\n(defn shape [{:keys [x y width height]}]\n  [:rect {:width  width\n          :height height\n          :stroke (:node-shape-stroke default-styles)\n          :fill   (:node-shape-fill default-styles)}])\n\nTODO: good? bad?\n\n(defn fo-div [width height content]\n  [:foreignObject {:width  width\n                   :height height}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width  \"100%\"\n                  :height \"100%\"}}\n    content]])\n\n\n(defn html-node [{:keys [width height layoutOptions]}]\n  [:foreignObject {:width  width\n                   :height height}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width  \"100%\"\n                  :height \"100%\"}}\n    (:content layoutOptions)]])\n\n\n(defn centered-label [{:keys [text width height]}]\n  [:foreignObject {:width  width\n                   :height height\n                   :style  {:overflow \"visible\"}}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:font-size       \"8px\"\n                  :display         \"flex\"\n                  :align-items     \"center\"\n                  :justify-content \"center\"\n                  :width           \"100%\"\n                  :height          \"100%\"}}\n    text]])\n\n\n(defn positioned-label [{:keys [x y text width height]}]\n  [:foreignObject {:x      (some-&gt; x (* 2.5))\n                   :y      (some-&gt; y (* 2.5))\n                   :width  width\n                   :height height\n                   :style  {:overflow \"visible\"}}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:font-size \"8px\"\n                  :width     \"100%\"\n                  :height    \"100%\"}}\n    text]])\n\n\n(defn node [{:as n :keys [id labels ports children edges x y layoutOptions]}]\n  [:g (merge\n        {:id id}\n        (when (and x y)\n          {:transform (str \"translate(\" x \", \" y \")\")}))\n   (if (:content layoutOptions)\n     (html-node n)\n     (shape n))\n   (concat\n     (for [l labels]\n       ;; TODO: is there a nicer way to default the size?\n       (if (seq children)\n         (positioned-label l)\n         (centered-label (merge l (select-keys n [:width :height])))))\n     ;; TODO: for ports need to adjust relative to node\n     (map node ports)\n     (map node children)\n     (map edge edges))])\n\n\n(defn render-graph [{:as g :keys [x y width height]}]\n  (kind/hiccup\n    [:svg {:viewBox (str (or x 0) \" \" (or y 0) \" \" width \" \" height)\n           :width   \"100%\"\n           :height  800}\n     [:defs (edge-defs)]\n\n     (node g)]))\n\n\nsource: content/idea/graph/layout/elk_svg.clj"
  },
  {
    "objectID": "idea/code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "href": "idea/code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "title": "The Z-Combinator Gambit",
    "section": "",
    "text": "Welcome back code champs, number ninjas, and data divers to our first episode of Beating Code Interviews with Stupid Stuff. People often send me emails asking, “How can I use lambda calculus to impress people?” Today, we find out.\n\n\n\nprogrammer staring at Z-combinator\n\n\nI have an interview with ZCorp lined up in 5 minutes, and our challenge is to only use anonymous functions. No defn, no loops, and definitely no self-reference. I’ll allow myself the occasional def for brevity, but beyond that, we’ll be running on pure lambda calculus.\n20 minutes later\n\nHey, sorry to keep you waiting. I just got out of a more important meeting. I’m kind of a big deal here at ZCorp. Why don’t you tell me a little bit about yourself?\n\nBorn of binary, raised on algorithms, I walk the path of lambda…\n\nRiiiight… Let’s just start with the warm-up problem. Show me how you would reverse a list.\n\nAh, the timeless list reversal. Deceptively simple, perilously deep. We must first define our purpose.\n\n(fn [SELF LIST])\n\n\n#object[idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$eval49700$fn__49701 0x16efa1ef \"idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$eval49700$fn__49701@16efa1ef\"]\n\n\nWe’re just writing a function, and it only needs to take a list…\n\nNot just any function, my friend, but one that knows itself. To know yourself is to find your fixed point.\n\n(def REV\n  (fn [SELF LIST]\n    (if (empty? LIST)\n      []\n      (conj (SELF SELF (rest LIST))\n            (first LIST)))))\n\n\n(REV REV [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nSELF is an input to itself, the logic of reversal.\n\nOk let’s just move on to the next problem, creating a Fibonacci sequence.\n\nOh no, our definition of reverse is intertwined with recursion. Let’s factor that out:\nWe need to lift our SELF\n\n(def REV'\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n((REV' REV') [1 2 3 4 5])\nerror\nOh, no… SELF doesn’t take LIST, it’s a function that returns a function that operates on LIST, and the argument to SELF is… SELF. Therefore, we need to give it (SELF SELF).\n\n(def REV''\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj ((SELF SELF) (rest LIST))\n              (first LIST))))))\n\n\n((REV'' REV'') [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nThat’s a confusing way to write it\n\nQuite right, because it’s not obvious what (SELF SELF) is. We need to extract it out. What we want is:\n\n(def REV-LOGIC\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n\nBelieve me when I say that is not what I meant…\n\nOh, right. Now SELF = (SELF SELF).\n\nNot what I meant, and also that sounds impossible.\n\nBut identity is the identity of itself:\n\n(identity 1)\n\n\n1\n\n=&gt; 1\n\n((identity identity) 1)\n\n\n1\n\n=&gt; 1\n\nO.K. sure, but that’s a special case.\n\n\n(((identity identity) (identity identity)) 1)\n\n\n1\n\n=&gt; 1\n\nThis is an identity crisis.\n\nWe just need to find the right conditions for (SELF SELF) = SELF.\n\n(REV-LOGIC REV-LOGIC)\n\n\n#object[idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__49715 0x648e1f21 \"idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__49715@648e1f21\"]\n\n\nWell, it’s a function! That much is clear…\n\nBut it doesn’t work, because (REV-LOGIC REV-LOGIC) =/= REV-LOGIC. Let’s try something easier:\n\n(def FIX\n  (fn [LOGIC]\n    ;; return something like identity where self application does not change it\n    #_FIXED))\n\nFIX takes the logic function, and makes a function such that (FIXED (FIX LOGIC)) = FIXED\n(FIXED FIXED) =&gt; FIXED which means that ((FIX LOGIC) (FIX LOGIC)) = (FIX LOGIC)\n\nRight, that sounds way easier… shaking head in disbelief\n\nExactly! Because we just reverse it: (FIX F) = ((FIX F) (FIX F))\n\nWhy did you call it FIX?\n\nWell, it was broken before right?\n\nI’m starting to think that you are the broken one.\n\n\n(def FIX\n  (fn [LOGIC]\n    ((FIX LOGIC) (FIX LOGIC))))\n\nBut FIX can still see itself. We need to parameterize the use of FIXED\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (FIXED FIXED)))\n     (fn [FIXED]\n       (LOGIC (FIXED FIXED))))))\n\nThere, I fixed it.\n\nWhat is fixed?\n\nFIXED is (FIXED FIXED), obviously.\n\nObviously. raises hands in dispair\n\nBecause (FIX F) = ((FIX F) (FIX F)), it was your idea to refactor remember?\n(FIX REV-LOGIC)\nstack overflow\n\nEverything looks to be inside out now.\n\nOh, you are right, we can’t pass (FIXED FIXED) as an argument because it will be evaluated first. Thanks for the tip.\n\nCan we fix it? slaps self\n\nInstead of calling (FIXED FIXED) we need a function that will create (FIXED FIXED) when it’s needed, after LOGIC gets called. LOGIC needs to take itself as it’s argument, so the function we pass to LOGIC should look very much like LOGIC, but of course without any actual logic in it.\n\nThat actually sounds logical.\n\nLOGIC is a function of itself, returning a function that acts on a value:\n\ndidn’t you say that (FIXED FIXED) = FIXED?\n\nYes but only after we FIX it. Fixing it requires us to go from FIXED to (FIXED FIXED) remember?\n\nAh sure…\n\nSo while we are fixing logic, let’s replace (LOGIC (FIXED FIXED)) with our deferring function.\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE))))\n     (fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE)))))))\n\nDid you know this is called continuation passing style?\n\nCSP?\n\nNo, that’s communicating subprocesses.\n\nThat’s confusing.\n\nIsn’t it!? Fortunately, we are about to be unconfused.\n\n(FIX REV-LOGIC)\n\n\n#object[idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__49715 0x74732aab \"idea.code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__49715@74732aab\"]\n\n\nAt least it didn’t blow up this time…\n\n\n((FIX REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nNice, that’s the right answer.\n\nEven nicer is that our fixed logic behaves like identity now:\n\n((REV-LOGIC (FIX REV-LOGIC)) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\n((REV-LOGIC (REV-LOGIC (FIX REV-LOGIC))) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nI can’t believe something so ridiculous actually works.\n\nYes it is ridiculous to have all those silly names. Let’s fix that:\n\n(def Z\n  (fn [F]\n    ((fn [X]\n       (F (fn [V] ((X X) V))))\n     (fn [X]\n       (F (fn [V] ((X X) V)))))))\n\nYou are not your variables. Rename them, rebind them. Your essence is invariant.\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nWait, we are meant to be doing Fibonacci, remember?\n\nWe are factoring out our LOGIC.\n\nIt looks to me like you doubled the code, that’s not great refactoring. Using single letters make it totally unreadable.\n\nHmmm you got me there, there does seem to be a lot of doubling. What if we had a function for f =&gt; (f f)\n\n(def REPLICATE \"Omega, the self-devouring serpent\"\n  (fn [F]\n    (F F)))\n\nThe replication of identity is itself.\n\n((REPLICATE identity) 1)\n\n\n1\n\n=&gt; 1\nBut test not the serpent lightly\n(REPLICATE REPLICATE)\nstack overflow\nThe replication of replication is eternal. Now we can clean up that duplication.\n\n(def Z\n  (fn [LOGIC]\n    (REPLICATE (fn [X]\n                 (LOGIC (fn [V] ((X X) V)))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nThat’s not really any clearer…\n\nVery well, we can keep extracting.\n\n(def DEFER \"Eta, the patient one\"\n  (fn [LOGIC]\n    (fn [VALUE]\n      ((REPLICATE LOGIC) VALUE))))\n\nIf the infinite is deferred, is it infinite?\n\n(def FOLD \"Zeta, weaver of logic, bringer of finitude\"\n  (fn [LOGIC]\n    (REPLICATE (fn [SELF]\n                 (LOGIC (DEFER SELF))))))\n\nOMEGA diverges, ZETA folds, LOGIC writes QED.\n\n((FOLD REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nThat’s much nicer, I’m so glad you suggested using longer names.\n\nCan we write Fibonacci, please?\n\nOh, that’s easy now!\n\n(def FIB-LOGIC\n  (fn [SELF]\n    (fn [[B A :as FIBS]]\n      (if (&gt; B 10)\n        FIBS\n        (SELF (concat [(+ A B) B] FIBS))))))\n\n\n((FOLD FIB-LOGIC) [1 1])\n\n\n(13 8 8 5 5 3 3 2 2 1 1 1)\n\n=&gt; (13 8 8 5 5 3 3 2 2 1 1 1)\n\nThat’s all backward!!\n\nOh, my mistake\n\n((FOLD REV-LOGIC) ((FOLD FIB-LOGIC) [1 1]))\n\n\n[1 1 1 2 2 3 3 5 5 8 8 13]\n\n=&gt; [1 1 1 2 2 3 3 5 5 8 8 13]\n\nYou can’t be serious… This is ridiculous. We’ll be here forever if you keep this up.\n\nI love that idea! An infinite sequence is exactly what we need…\n\n(def FIB-LOGIC-FOREVER\n  (fn [SELF]\n    (fn [A]\n      (fn [B]\n        (lazy-seq\n          (cons A ((SELF B) (+ A B))))))))\n\n\n(take 20 (((FOLD FIB-LOGIC-FOREVER) 1) 1))\n\n\n(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\n\n=&gt; (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\nThat’s so nice.\n\nOh look at the time! I have a more important meeting to go to! disconnects\n\nOuch, Rough. ZCorp never got back to me, so let’s update the scoreboard as a loss without a GG.\n\n\n\n\n\nInterviews\nWins\nGGs\n\n\n\n\n1\n0\n0\n\n\n\n\n\nThat’s all for today. Until next time, keep on coding.\n\nsource: content/idea/code_interview/beating/with_stupid_stuff/z_combinator_gambit.clj"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "About Blog Posts Ideas Libraries and Tools Filter"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nClean object printing by removing extraneous\n\n\n\n\n\n\n\n\nJun 5, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Visualization\n\n\n\n\n\n\n\n\nJun 3, 2025\n\n\nDaniel Slutsky, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Exploration\n\n\n\n\n\n\n\n\nJun 2, 2025\n\n\nDaniel Slutsky, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Stats Example\n\n\n\n\n\n\n\n\nJun 1, 2025\n\n\nAlex Miller, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nThe Z-Combinator Gambit\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nChris Houser, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 6, 2025\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  }
]