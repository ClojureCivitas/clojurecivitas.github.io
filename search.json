[
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html",
    "href": "scicloj/macroexpand/macroexpand_2025.html",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "",
    "text": "Since 2019, Scicloj has played a key role in supporting Clojure growth to new domains. In particular, it has nurtured a love for data science, scientific computing, and specialized use cases in Clojure-growing into a strong and supportive community.\nOne of many highlights of the journey is Noj, a toolkit designed to streamline data science workflows in Clojure. Its development wouldn‚Äôt have been possible without the amazing contribution from the community, and it remains an active and evolving project.\nSince last year, we‚Äôve taken meaningful steps forward: not only by continuing to support Scicloj‚Äôs rich ecosystem of open-source data science projects, but also by connecting with newcomers. Our first online conference, Scinoj Light, held in May 2025, brought together diverse data analysis stories and community building sessions to show the charm of Clojure in data science. We have received much positive feedback and many favorable reactions from the attendees.\nNow, building on that momentum, we‚Äôre excited to announce Macroexpand 2025, taking place in October 2025 ‚Äî a pair of online conferences designed further to deepen and broaden our community: Macroexpand-Noj and Macroexpand-Deep."
  },
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html#expanding-community-and-support-through-macroexpand",
    "href": "scicloj/macroexpand/macroexpand_2025.html#expanding-community-and-support-through-macroexpand",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "",
    "text": "Since 2019, Scicloj has played a key role in supporting Clojure growth to new domains. In particular, it has nurtured a love for data science, scientific computing, and specialized use cases in Clojure-growing into a strong and supportive community.\nOne of many highlights of the journey is Noj, a toolkit designed to streamline data science workflows in Clojure. Its development wouldn‚Äôt have been possible without the amazing contribution from the community, and it remains an active and evolving project.\nSince last year, we‚Äôve taken meaningful steps forward: not only by continuing to support Scicloj‚Äôs rich ecosystem of open-source data science projects, but also by connecting with newcomers. Our first online conference, Scinoj Light, held in May 2025, brought together diverse data analysis stories and community building sessions to show the charm of Clojure in data science. We have received much positive feedback and many favorable reactions from the attendees.\nNow, building on that momentum, we‚Äôre excited to announce Macroexpand 2025, taking place in October 2025 ‚Äî a pair of online conferences designed further to deepen and broaden our community: Macroexpand-Noj and Macroexpand-Deep."
  },
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html#macroexpand-noj",
    "href": "scicloj/macroexpand/macroexpand_2025.html#macroexpand-noj",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "Macroexpand-Noj",
    "text": "Macroexpand-Noj\nMacroexpand-Noj centers around the growth and application of the Noj toolkit in real-world data science. It will feature talks that showcase practical projects, highlight new tools and libraries in the ecosystem, and share efforts around documentation, theoretical insights, and methodology. Whether you‚Äôre a newcomer or an experienced Clojurian, our goal is that you find sessions that help you learn, explore, and contribute.\nWe will include follow-ups from Scinoj Light, practical use cases of Noj in data workflows, and discussions of newly emerging features that strengthen the Clojure data science experience."
  },
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html#macroexpand-deep",
    "href": "scicloj/macroexpand/macroexpand_2025.html#macroexpand-deep",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "Macroexpand-Deep",
    "text": "Macroexpand-Deep\nMacroexpand-Deep is the first Scicloj conference dedicated to AI system research and applications in Clojure. By ‚ÄúAI systems‚Äù, we generally mean systems that combine deep learning networks with other components, though broader interpretations are welcome and encouraged.\nThe conference will explore how to build systems using large language models and vector embeddings, experiment with algorithms in specific domains, and train custom neural network architectures, and study the behavior of trained networks. We will also cover the creation and improvement of supporting tools and infrastructure that enable this kind of work in Clojure."
  },
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html#call-for-proposals-share-your-work",
    "href": "scicloj/macroexpand/macroexpand_2025.html#call-for-proposals-share-your-work",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "üì¢ Call for Proposals: Share Your Work!",
    "text": "üì¢ Call for Proposals: Share Your Work!\nWe‚Äôre now inviting proposals for talks at Macroexpand 2025!\nWhether you‚Äôre working on a new idea, experimenting with a prototype, building tools, exploring data, writing documentation, or reflecting on your process, we would like to hear from you!\nYou don‚Äôt need to have everything figured out. If you‚Äôre unsure whether your idea is ‚Äúready‚Äù or how to shape your talk, we‚Äôre here to help you brainstorm, refine, and prepare. We believe that learning, progress, and curiosity are worth sharing and valuable at any stage.\nWe also encourage first-time speakers and newcomers to Clojure to join. The community is supportive, and we‚Äôll be happy to help every step of the way.\n‚û°Ô∏è Learn more and submit your idea via the Speakers page."
  },
  {
    "objectID": "scicloj/macroexpand/macroexpand_2025.html#our-vision-for-macroexpand-2025",
    "href": "scicloj/macroexpand/macroexpand_2025.html#our-vision-for-macroexpand-2025",
    "title": "Macroexpand 2025 by Scicloj",
    "section": "Our Vision for Macroexpand 2025",
    "text": "Our Vision for Macroexpand 2025\nMacroexpand is a space for sharing real progress‚Äîwhether you‚Äôre improving documentation, exploring new ideas, building tools, or reporting on experiments. We aim to support projects at all stages and in all forms: from early prototypes to mature tools.\nIf you‚Äôre interested, have an idea, or just want to chat‚Äîwe‚Äôd love to hear from you. Feel free to reach out!. Let‚Äôs explore together ‚ú®\n\nsource: src/scicloj/macroexpand/macroexpand_2025.clj"
  },
  {
    "objectID": "scicloj/clay/presenting_presentations-revealjs.html#how-to-make-a-slideshow",
    "href": "scicloj/clay/presenting_presentations-revealjs.html#how-to-make-a-slideshow",
    "title": "Presenting your namespace",
    "section": "How to make a slideshow",
    "text": "How to make a slideshow\nAdd a little metadata to your namespace ü™Ñ\n^{:clay {:format [:quarto :revealjs]}\n(ns my.awesome.idea)\n..."
  },
  {
    "objectID": "scicloj/clay/presenting_presentations-revealjs.html#the-slides",
    "href": "scicloj/clay/presenting_presentations-revealjs.html#the-slides",
    "title": "Presenting your namespace",
    "section": "The slides",
    "text": "The slides\nWrite comments\n;; Markdown **in my comments**\nCode\n\n(+ 1 2)\n\n\n3\n\nand headings\n;; Each heading is a slide"
  },
  {
    "objectID": "scicloj/clay/presenting_presentations-revealjs.html#turn-data-into-html",
    "href": "scicloj/clay/presenting_presentations-revealjs.html#turn-data-into-html",
    "title": "Presenting your namespace",
    "section": "Turn data into HTML",
    "text": "Turn data into HTML\n\n(kind/hiccup\n  [:svg {:width \"100%\"}\n   [:circle {:r 40 :cx 50 :cy 50 :fill \"lightblue\"}]\n   [:circle {:r 20 :cx 50 :cy 50 :fill \"lightgreen\"}]])"
  },
  {
    "objectID": "scicloj/clay/presenting_presentations-revealjs.html#powerful-visualizations",
    "href": "scicloj/clay/presenting_presentations-revealjs.html#powerful-visualizations",
    "title": "Presenting your namespace",
    "section": "Powerful visualizations",
    "text": "Powerful visualizations\n\n(-&gt; (rdatasets/datasets-iris)\n    (plotly/layer-point\n      {:=x :sepal-length\n       :=y :sepal-width}))"
  },
  {
    "objectID": "scicloj/clay/presenting_presentations-revealjs.html#thats-it",
    "href": "scicloj/clay/presenting_presentations-revealjs.html#thats-it",
    "title": "Presenting your namespace",
    "section": "That‚Äôs it!",
    "text": "That‚Äôs it!\nCreate src/your/idea.clj as a Clojure namespace\nSubmit a PR to the ClojureCivitas repo\nVoil√† ‚Äî you‚Äôve published your presentation.\nüå±\nWhy not turn your next idea into a slideshow?\n\nsource: src/scicloj/clay/presenting_presentations.clj"
  },
  {
    "objectID": "scicloj/kindly_render/visualize_colls.html",
    "href": "scicloj/kindly_render/visualize_colls.html",
    "title": "Collections as grids with borders",
    "section": "",
    "text": "A key idea of Lisp is that all syntax is a list\n\n()\n\n\n()\n\nRich innovated by introducing collection literals\n\n[]\n\n\n[]\n\n\n{}\n\n\n{}\n\n\n#{}\n\n\n#{}\n\nData is well represented by these collections\n\n(def data\n  {:numbers [2 9 -1]\n   :sets    #{\"hello\" \"world\"}\n   :mix     [1 \"hello world\" (kind/hiccup [:div \"hello\" [:strong \"world\"] \"hiccup\"])]\n   :nest    {:markdown             (kind/md \"hello **markdown**\")\n             :number               9999\n             :nothing-is-something #{nil #{} 0}}\n   :dataset (tc/dataset {:x (range 3)\n                         :y [:A :B :C]})})\n\nIn a notebook, we like to visualize values. Often those visualizations summarize the data in some way.\n\nThe collection represents something\nThe collection organizes some things\nWe are interested in the collection itself\n\nIn website design, everything is a grid. Grids organize and align content, achieving visual hierarchy. Can we apply this idea to data structures? Let‚Äôs start with a vector:\n\n(def v [1 2 3 4 5 6 7 8 9])\n\n\nv\n\n\n[1 2 3 4 5 6 7 8 9]\n\nPretty printing the vector is a fine choice, but what if we made it a grid?\n\n(defn content [x columns]\n  (kind/hiccup\n    (into [:div {:style {:display               :grid\n                         :grid-template-columns (str \"repeat(\" columns \", auto)\")\n                         :align-items           :center\n                         :justify-content       :center\n                         :text-align            :center\n                         :padding               \"10px\"}}]\n          x)))\n\n\n(defn vis [x opt]\n  (kind/hiccup\n    [:div {:style {:display               \"grid\"\n                   :grid-template-columns \"auto auto auto\"\n                   :gap                   \"0.25em\"\n                   :align-items           \"center\"\n                   :justify-content       \"center\"}}\n     [:div {:style {:padding     \"0 0.25em\"\n                    :font-weight :bold\n                    :align-self  (when opt \"start\")\n                    :align-items (when-not opt \"stretch\")}}\n      \"[\"]\n     (content x 1)\n     [:div {:style {:padding     \"0.25em\"\n                    :font-weight :bold\n                    :align-self  (when opt \"end\")\n                    :align-items (when-not opt \"stretch\")}}\n      \"]\"]]))\n\nIn some situations this feels better, especially when nesting visualizations. But it does raise the question of where the braces belong.\n\n(vis v false)\n\n[123456789]\n\n(vis v true)\n\n[123456789]\nAnother idea is to use borders to indicate collections.\n\n(defn vis2 [x]\n  (kind/hiccup\n    [:div {:style {:border-left  \"2px solid blue\"\n                   :border-right \"2px solid blue\"}}\n     (content x 1)]))\n\n\n(vis2 v)\n\n123456789\nBorders can be stylized with images\n\n(defn svg [& body]\n  (kind/hiccup\n    (into [:svg {:xmlns        \"http://www.w3.org/2000/svg\"\n                 :width        100\n                 :height       100\n                 :viewBox      [-100 -100 200 200]\n                 :stroke       :currentColor\n                 :fill         :none\n                 :stroke-width 4}\n           body])))\n\n\n(defn border-style [x]\n  {:border              \"30px solid transparent\"\n   :border-image-slice  \"30\"\n   :border-image-source (str \"url('data:image/svg+xml;utf8,\"\n                             (hiccup/html {:mode :xml} x)\n                             \"')\")\n   :border-image-repeat \"round\"})\n\nWe can create a curly brace shape to use as the border\n\n(def curly-brace-path\n  \"M -10 -40 Q -20 -40, -20 -10, -20 0, -30 0 -20 0, -20 10, -20 40, -10 40\")\n\n\n(def map-svg\n  (svg (for [r [0 90 180 270]]\n         [:path {:transform (str \"rotate(\" r \") translate(-30) \")\n                 :d         curly-brace-path}])))\n\n\nmap-svg\n\n\n\n(def map-style\n  (border-style map-svg))\n\n\n(defn vis3 [style columns x]\n  (kind/hiccup [:div {:style style} (content x columns)]))\n\nWe now have a style that can be used to indicate something is a map\n\n(vis3 map-style 2 (vec (repeat 10 [:div \"hahaha\"])))\n\nhahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha\nUsually we‚Äôd put this in a CSS rule, I‚Äôm just illustrating what it would look like.\n\n(def set-svg\n  (svg\n    [:line {:x1 -80 :y1 -20 :x2 -80 :y2 20}]\n    [:line {:x1 -70 :y1 -20 :x2 -70 :y2 20}]\n    [:line {:x1 -90 :y1 10 :x2 -60 :y2 10}]\n    [:line {:x1 -90 :y1 -10 :x2 -60 :y2 -10}]\n    (for [r [0 90 180 270]]\n      [:path {:transform (str \"rotate(\" r \") translate(-30) \")\n              :d         curly-brace-path}])))\n\nA set could have a hash on the left\n\nset-svg\n\n\n\n(def set-style (border-style set-svg))\n\n\n(vis3 set-style 1 (vec (repeat 10 [:div \"hahaha\"])))\n\nhahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha\nSets could instead have a Venn inspired border\n\n(def set2-svg\n  (svg\n    (for [r [0 90 180 270]]\n      [:g {:transform (str \"rotate(\" r \")\")}\n       [:ellipse {:cx -60 :cy -15 :rx 12 :ry 25}]\n       [:ellipse {:cx -60 :cy 15 :rx 12 :ry 25}]])))\n\n\nset2-svg\n\n\n\n(def set2-style (border-style set2-svg))\n\n\n(vis3 set2-style 1 (vec (repeat 10 [:div \"hahaha\"])))\n\nhahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha\nBut I think it‚Äôs better to use the more obvious # hash.\n\n(def sequence-svg\n  (svg\n    (for [r [0 90 180 270]]\n      [:g {:transform (str \"rotate(\" r \")\")}\n       [:circle {:r 75}]])))\n\n\nsequence-svg\n\n\nParenthesis style border for sequences\n\n(def sequence-style (border-style sequence-svg))\n\n\n(vis3 sequence-style 1 (vec (repeat 10 [:div \"hahaha\"])))\n\nhahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha\n\n(def vector-svg\n  (svg\n    (for [r [0 90 180 270]]\n      [:g {:transform (str \"rotate(\" r \")\")}\n       [:path {:d \"M -65 -65 v 10 \"}]\n       [:path {:d \"M -65 65 v -10 \"}]\n       [:path {:d \"M -65 -30 H -75 V 30 H -65\"}]])))\n\n\nvector-svg\n\n\nAnd rectangular brace style border for vectors\n\n(def vector-style (border-style vector-svg))\n\n\n(vis3 vector-style 1 (vec (repeat 10 [:div \"hahaha\"])))\n\nhahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha\nNesting collections\n\n(vis3 map-style 2\n      [:some-key (vis3 vector-style 1 v)\n       :some-other (vis3 set-style 1 (repeat 5 (vis3 sequence-style 1 [\"ha\" \"ha\" \"ha\"])))])\n\nsome-key123456789some-otherhahahahahahahahahahahahahahaha\nI think this scheme achieves a visually stylized appearance. It maintains the expected hierarchy. And it is fairly obvious what collections are represented.\nWhat do you think?\n\nsource: src/scicloj/kindly_render/visualize_colls.clj"
  },
  {
    "objectID": "scicloj/cfd/intro/linear_1d_convection_with_array.html",
    "href": "scicloj/cfd/intro/linear_1d_convection_with_array.html",
    "title": "Simulating 1-D Convection in Clojure ‚Äî From Equations to Arrays",
    "section": "",
    "text": "Earlier this year I gave a talk at the first online Scinoj Light Conference, sharing a ongoing project to port Computational Fluid Dynamics(CFD) learning materials from Python to Clojure.\nIn this post, I‚Äôll demonstrate a simple one-dimensional linear convection simulation implemented in Clojure using Java primitive arrays. This example shows a glimpse into the porting effort, with a focus on expressing numerical simulations using only built-in Clojure functions."
  },
  {
    "objectID": "scicloj/cfd/intro/linear_1d_convection_with_array.html#the-equation",
    "href": "scicloj/cfd/intro/linear_1d_convection_with_array.html#the-equation",
    "title": "Simulating 1-D Convection in Clojure ‚Äî From Equations to Arrays",
    "section": "The Equation",
    "text": "The Equation\n(This section won‚Äôt take up too much of your time‚Ä¶)\nWe‚Äôre going to simulate the 1-D linear convection equation:\n\\[\\frac{\\partial u }{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\\]\nThis explains how the flow velocity u changes over time t and position x, with c which is the wave speed.\nInstead of focusing on the physical interpretation(since I am no expert), the main focus on this post will be its implementation side - expressing it numerically and coding it in Clojure!\nUsing a finite-difference scheme, the discretized form becomes:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + c \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\\]\nThen, solving for u_i^{n+1} gives:\n\\[u_i^{n+1} = n_i^n - c \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)\\]"
  },
  {
    "objectID": "scicloj/cfd/intro/linear_1d_convection_with_array.html#initial-setup",
    "href": "scicloj/cfd/intro/linear_1d_convection_with_array.html#initial-setup",
    "title": "Simulating 1-D Convection in Clojure ‚Äî From Equations to Arrays",
    "section": "Initial Setup",
    "text": "Initial Setup\nWe begin by defining initial simulation parameters to start:\n\nnx: number of sliced steps for spatial point x from x-start and x-end\nnt: number of time steps we want to propagate\ndx: each sliced x calculated from dx = (x-end - x-start) / (nx - 1)\ndt: sliced each time step\nc: speed of wave\n\n\n(def init-params\n  {:x-start 0\n   :x-end   2\n   :nx      41\n   :nt      25\n   :dx      (/ (- 2 0) (dec 41))\n   :dt      0.025\n   :c       1})\n\n\nCreating the x Grid\nWith the given init-params we defined earlier, we create a float-array of spatial points x:\n\n(def array-x (let [{:keys [nx x-start x-end]} init-params\n                   arr  (float-array nx)\n                   step (/ (- x-end x-start) (dec nx))]\n               (dotimes [i nx]\n                 (aset arr i (float (* i step))))\n               arr))\n\n\n[0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6,\n 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, 1.05, 1.1, 1.15, 1.2,\n 1.25, 1.3, 1.35, 1.4, 1.45, 1.5, 1.55, 1.6, 1.65, 1.7, 1.75, 1.8,\n 1.85, 1.9, 1.95, 2.0]\n\n\n\nDefining Initial Flow Velocity Condition\nThe initial flow velocity(when t = 0) is 2 when x ‚àà [0.5, 1.0], and is 1 elsewhere:\n\n(def init-cond-fn #(float (if (and (&gt;= % 0.5) (&lt;= % 1.0)) 2 1)))\n\n\n(def array-u\n  (let [nx (:nx init-params)\n        u  (float-array nx)]\n    (dotimes [i nx]\n      (let [x-i (aget array-x i)\n            u-i (init-cond-fn x-i)]\n        (aset u i u-i)))\n    u))\n\n\n(def init-array-u (float-array array-u))\n\n\n[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0,\n 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n\nWe can visualize this initial u:\n\n\n\nWait, Why dotimes?\nSince we‚Äôre working with mutable Java arrays(float-array), dotimes is an efficient choice here. Because it gives direct, index-based iteration. And it pairs naturally with aget and aset for reading and writing array values."
  },
  {
    "objectID": "scicloj/cfd/intro/linear_1d_convection_with_array.html#implementing-and-the-simulation",
    "href": "scicloj/cfd/intro/linear_1d_convection_with_array.html#implementing-and-the-simulation",
    "title": "Simulating 1-D Convection in Clojure ‚Äî From Equations to Arrays",
    "section": "Implementing and the Simulation",
    "text": "Implementing and the Simulation\nWith the initial setup complete, we now apply the discretized convection equation at each time step.\n\nStep Function\nGiven the previous time step‚Äôs array-u and the init-params, We compute and mutate the flow velocity in-place:\n\n(defn mutate-linear-convection-u\n  [array-u {:keys [nx c dx dt]}]\n  (let [u_i (float-array array-u)]\n    (dotimes [i (- nx 2)]\n      (let [idx     (inc i)\n            un-i    (aget u_i idx)\n            un-i-1  (aget u_i i)\n            new-u-i (float (- un-i (* c (/ dt dx) (- un-i un-i-1))))]\n        (aset array-u idx new-u-i))))\n  array-u)\n\n\n\nTime Integration\nWe run the step function nt times to run our simulation over time.\n\n(defn simulate!\n  [array-u {:keys [nt] :as init-params}]\n  (loop [n 0]\n    (if (= n nt)\n      array-u\n      (do (mutate-linear-convection-u array-u init-params) (recur (inc n))))))\n\nFinally, we visualize the resulting array-u:\n\n(simulate! array-u init-params)\n\n\n[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0000007,\n 1.0000097, 1.0000782, 1.0004553, 1.0020387, 1.0073167, 1.0216427,\n 1.0538762, 1.1147615, 1.2121781, 1.3450189, 1.4999992, 1.6549712,\n 1.7877436, 1.8847833, 1.9440854, 1.9710407, 1.9710407, 1.9440854,\n 1.8847833, 1.7877436, 1.6549712, 1.4999992, 1.3450189, 1.2121781,\n 1.1147615, 1.0538762, 1.0216427, 1.0073167, 1.0]\n\n\nThe plot shows how the flow velocity shifts from left to right over time, while also becoming smoother. Nice!"
  },
  {
    "objectID": "scicloj/cfd/intro/linear_1d_convection_with_array.html#the-summary",
    "href": "scicloj/cfd/intro/linear_1d_convection_with_array.html#the-summary",
    "title": "Simulating 1-D Convection in Clojure ‚Äî From Equations to Arrays",
    "section": "The Summary",
    "text": "The Summary\nThis Simple example demonstrates a simulation process using low-level Java primitive arrays in Clojure.\nChoosing this approach provided mutable, non-persistent data structures. While this deviates from idiomatic Clojure, it offers significant performance benefits for big-size numerical simulations. However, it comes with trade-offs; by opting for mutability, we give up the guarantees of immutability and structural sharing, making the code less safe and more error-prone.\nAs the porting project continues, we plan to evolve the design to better align with idiomatic Clojure principles. Stay tuned!\n\nsource: src/scicloj/cfd/intro/linear_1d_convection_with_array.clj"
  },
  {
    "objectID": "pages.html",
    "href": "pages.html",
    "title": "Pages",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nExplorer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuthors\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Clojure Civitas makes it easy for you to publish Clojure ideas and explorations without the overhead of setting up a new project, blog, or repo. Whether you‚Äôre sketching out a quick experiment or writing a deeper post, just fork this repo, create a namespace, write, commit and submit a pull request. This is your shared scratch space.\n\n\n\n\nNavigate your own path through interconnected topics.\n\n\n\n\n\nWrite notebooks and situate them in a broader context by linking ideas.\n\n\n\n\n\nThe best resources rise through collective refinement.\n\n\n\nAn open effort to structure learning resources with meaningful connections.\n‚ÄúCivitas‚Äù refers to a community of citizens, encompassing the rights, duties, and privileges associated with belonging. It‚Äôs a term that signifies citizenship, not just a physical city, but also the political and social fabric of the community.\n\n\nSee README.md.\n\n\n\nClojure and markdown are a natural fit for interactive, literate programming. But there is incidental complexity in setup and publishing. Creating a new project, configuring a blog, choosing themes and styling, organizing files, adding analytics, and thinking about SEO all add overhead. This friction discourages experimentation and makes publishing harder than it needs to be.\n\n\nMarkdown comments in Clojure namespaces is a perfect fit for interactive literate programming. Creators should only have to care about their code, not setting up projects or hosting workflows. Let‚Äôs make a shared, organized platform for short experiments, tutorials, notes, and blog posts.\n\n\n\nCivitas aggregates structured metadata about the content it hosts and links it to other Clojure resources. We can build a connected web of ideas, showing how concepts relate, what builds on what, and where to go next. A hex-grid interface presents these relationships visually. Each notebook can declare prerequisites, alternatives, and follow-ups. This helps learners discover next steps, helps educators design coherent learning paths, and enables the community to improve content over time. The goal is to make the Clojure knowledge ecosystem easier to explore and navigate.\n\n\n\nClojure Civitas does not aim to centralize Clojure knowledge. Rather it hopes to amplify existing resources, connect with them, and add a place in between for raw ideas and creative experiments.\n\n\n\n\n\n\n\nContent is submitted via Pull Requests, which are reviewed to prevent abuse. A small team of reviewers ensures quick turnaround. Community representatives are available to assist and guide contributors.\n\n\n\nMetadata is provided by authors. Future improvements may include automated extraction and smarter linking to enrich the knowledge base.\n\n\n\nPage view analytics are publicly available. See the Clojure Civitas Analytics Dashboard.\n\n\n\nMade with Clay. See the README.md in the repository for contribution guidelines and technical details.\n\n\n\n\nWe value reproducible artifacts. Start with code. Make it work. Then tell the story."
  },
  {
    "objectID": "about.html#usage",
    "href": "about.html#usage",
    "title": "About",
    "section": "",
    "text": "See README.md."
  },
  {
    "objectID": "about.html#rationale",
    "href": "about.html#rationale",
    "title": "About",
    "section": "",
    "text": "Clojure and markdown are a natural fit for interactive, literate programming. But there is incidental complexity in setup and publishing. Creating a new project, configuring a blog, choosing themes and styling, organizing files, adding analytics, and thinking about SEO all add overhead. This friction discourages experimentation and makes publishing harder than it needs to be.\n\n\nMarkdown comments in Clojure namespaces is a perfect fit for interactive literate programming. Creators should only have to care about their code, not setting up projects or hosting workflows. Let‚Äôs make a shared, organized platform for short experiments, tutorials, notes, and blog posts.\n\n\n\nCivitas aggregates structured metadata about the content it hosts and links it to other Clojure resources. We can build a connected web of ideas, showing how concepts relate, what builds on what, and where to go next. A hex-grid interface presents these relationships visually. Each notebook can declare prerequisites, alternatives, and follow-ups. This helps learners discover next steps, helps educators design coherent learning paths, and enables the community to improve content over time. The goal is to make the Clojure knowledge ecosystem easier to explore and navigate.\n\n\n\nClojure Civitas does not aim to centralize Clojure knowledge. Rather it hopes to amplify existing resources, connect with them, and add a place in between for raw ideas and creative experiments."
  },
  {
    "objectID": "about.html#how-it-works",
    "href": "about.html#how-it-works",
    "title": "About",
    "section": "",
    "text": "Content is submitted via Pull Requests, which are reviewed to prevent abuse. A small team of reviewers ensures quick turnaround. Community representatives are available to assist and guide contributors.\n\n\n\nMetadata is provided by authors. Future improvements may include automated extraction and smarter linking to enrich the knowledge base.\n\n\n\nPage view analytics are publicly available. See the Clojure Civitas Analytics Dashboard.\n\n\n\nMade with Clay. See the README.md in the repository for contribution guidelines and technical details."
  },
  {
    "objectID": "about.html#why-markdown-in-code",
    "href": "about.html#why-markdown-in-code",
    "title": "About",
    "section": "",
    "text": "We value reproducible artifacts. Start with code. Make it work. Then tell the story."
  },
  {
    "objectID": "math/stats/central_limit_theorem_different_distributions.html",
    "href": "math/stats/central_limit_theorem_different_distributions.html",
    "title": "Convergence to Normal Distribution, independent of original distribution",
    "section": "",
    "text": "We mentioned last time that the result of combining more and more events will approach the normal distribution, regardless of the shape of the original event distribution. Let‚Äôs try to demonstrate that visually.\nOur previous definition of a random event is an example of a uniform distribution:\n\n(defn event []\n  (rand))\n\n\n(defn event-sample-dataset [event-fn sample-count]\n  {:index       (range sample-count)\n   :event-value (repeatedly sample-count event-fn)})\n\n\n(def uniform-ds (event-sample-dataset event 100000))\n\n\n(defn histogram [ds]\n  (-&gt; ds\n      (tc/dataset)\n      (plotly/layer-histogram\n       {:=x :event-value\n        :=histnorm \"count\"\n        :=histogram-nbins 40})\n      (plotly/layer-point)))\n\n\n(histogram uniform-ds)\n\n\nIf we combine several of these distributions, watch the shape of the distribution:\n\n(defn avg [nums]\n  (/ (reduce + nums) (count nums)))\n\n\n(defn combined-event [number-of-events]\n  (avg (repeatedly number-of-events event)))\n\n\n(histogram (event-sample-dataset #(combined-event 2) 100000))\n\n\n\n(histogram (event-sample-dataset #(combined-event 5) 100000))\n\n\n\n(histogram (event-sample-dataset #(combined-event 20) 100000))\n\n\nLet‚Äôs try this again with a different shape of distribution:\n\n(defn triangle-wave [x]\n  (-&gt; x (- 0.5) (Math/abs) (* 4.0)))\n\n\n(-&gt; (let [xs (range 0.0 1.01 0.01)\n          ys (mapv triangle-wave xs)]\n      (tc/dataset {:x xs :y ys}))\n    (plotly/layer-point\n     {:=x :x\n      :=y :y}))\n\n\nGenerating samples from this distribution is more complicated than I initially expected. This warrants a follow-up, but for now I‚Äôll just link to my source for this method: Urban Operations Research by Richard C. Larson and Amedeo R. Odoni, Section 7.1.3 Generating Samples from Probability Distributions (see ‚ÄúThe rejection method‚Äù).\n\n(defn sample-from-function [f x-min x-max y-min y-max]\n  (loop []\n    (let [x (+ x-min (* (rand) (- x-max x-min)))\n          y (+ y-min (* (rand) (- y-max y-min)))]\n      (if (&lt;= y (f x))\n        x\n        (recur)))))\n\n\n(defn event []\n  (sample-from-function triangle-wave 0.0 1.0 0.0 2.0))\n\n\n(def triangle-wave-ds (event-sample-dataset event 100000))\n\n\n(histogram triangle-wave-ds)\n\n\nLet‚Äôs combine several of these distributions:\n\n(histogram (event-sample-dataset #(combined-event 2) 100000))\n\n\n\n(histogram (event-sample-dataset #(combined-event 5) 100000))\n\n\n\n(histogram (event-sample-dataset #(combined-event 20) 100000))\n\n\nI find these visuals surprisingly powerful because you can see the original distribution ‚Äúmorph‚Äù into this characteristic shape.\nThe normal distribution holds a unique place in mathematics and in the world itself: whenever you combine multiple independent and identically-distributed events, the result will converge to the normal distribution as the number of combined events increases.\n\nsource: src/math/stats/central_limit_theorem_different_distributions.clj"
  },
  {
    "objectID": "math/stats/quantquestions/what_are_the_odds/the_hidden_geometry_of_dice.html",
    "href": "math/stats/quantquestions/what_are_the_odds/the_hidden_geometry_of_dice.html",
    "title": "The Hidden Geometry of Dice",
    "section": "",
    "text": "Welcome to What Are the Odds? The show where we answer life‚Äôs important questions, like can I outsmart a six-sided die? Today we‚Äôre starting small. Two rolls of the dice and one burning question. No magic formulas, just curiosity, some patient counting, and a faint hope that math is on our side. Let‚Äôs roll.\n\nPop quiz: You roll a fair 6-sided die twice. Calculate the probability that the value of the first roll is strictly less than the value of the second roll.\n\nAs I always like to say to my niece, ‚Äúthe secret to answering any probability question is to enumerate the outcomes and count the ones we care about.‚Äù\n\\(P(Interesting) = InterestingOutcomes / TotalOutcomes\\)\nRolling 1 die once has 6 outcomes: 1 2 3 4 5 6.\nRolling 1 die twice gives us a combination of outcomes, let‚Äôs write out a few.\n[1 1] [1 2] '... [1 6]\n[2 1] [2 2] '...\nFollowing this pattern would produce 6 rows of 6 columns, so there must be 36 outcomes. We write down just enough of the pattern to figure out the best way to count it. Now we count how many of those meet the criteria.\n[1 1 :no] [1 2 :yes] '...\n[2 1 :no] [2 2 :no] [2 3 :yes] '...\nLogically we should see 5 yeses on the first row, then 4, 3, 2, 1, and 0, which we can ignore. Add them all up and we get 15.\nSo the answer to the question is 15/36 which reduces to 5/12, dividing top and bottom by the greatest common divisor 3.\nYou might be thinking that it‚Äôs not practical to enumerate everything all the time, I should use the formulas of probability. That‚Äôs true, those are marvelous. However, in my experience it is also easy to go wrong reasoning from formulas. It‚Äôs harder to go wrong starting with a counting problem, then improving your method of counting. You end up in the same place, but more confident in the answer.\nThe full enumeration of our simple 2 roll question as a counting problem is just big enough to be too tedious to use only counting.\n\n(let [roll [1 2 3 4 5 6]]\n  (for [i roll]\n    (for [j roll]\n      [i j])))\n\n\n(([1 1] [1 2] [1 3] [1 4] [1 5] [1 6])\n ([2 1] [2 2] [2 3] [2 4] [2 5] [2 6])\n ([3 1] [3 2] [3 3] [3 4] [3 5] [3 6])\n ([4 1] [4 2] [4 3] [4 4] [4 5] [4 6])\n ([5 1] [5 2] [5 3] [5 4] [5 5] [5 6])\n ([6 1] [6 2] [6 3] [6 4] [6 5] [6 6]))\n\nIdentifying the pattern is enough to realize the answer\n\n(+ 5 4 3 2 1)\n\n\n15\n\nWhat a marvelous pattern it is! Predictable, but not flat. Smooth, but not boring. Recursive, and not obvious.\n\n[1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210]\n\nThere‚Äôs something special about this sequence. Aren‚Äôt those numbers just‚Ä¶ pleasing in some way?\nThis sequence is called the triangular numbers.\n            .\n           . .\n          . . .\n         . . . .\nYou can find the first 10 or so numbers in your head, and with some paper many more quite quickly.\n\n\n\nSo many dots\n\n\nThere is a formula for calculating the nth triangular number: \\(T_n = 1 + 2 + 3 + \\dots + n = \\frac{n(n + 1)}{2}\\)\nThe 20th triangular number is (20x21)/2 = (400+20)/2 = 210. Isn‚Äôt it wonderful how there‚Äôs so many different ways to find the same answer in math?\nThere is something curious about the formula; it divides by 2 but only produces integers. How can we be certain we will only ever get an integer? So mysterious. n(n+1) is always even! Let‚Äôs think about that a bit more, if n is odd, then n+1 is even. If n is even, then n+1 is odd. One of the multiples is always even, meaning that 2 is a factor, so the multiple must always have a factor 2, and be even.\nIt‚Äôs easy now to imagine if we had a 1000 sided dice what the answer would be. But be careful! For a 1000 side die, we want the 999nth triangular number: \\((999 \\times 1000)/2 = (1000000-1000)/2 = 500000-500 = 499500\\) and the total outcomes would be 1000x1000, so the answer would be 0.4995. It‚Äôs comforting to see that for a large range, we land closer to 50%.\nThe point is that once we know what we are counting, it feels more obvious that we used the right formula to count it.\nTriangular numbers show up in many situations, my favorite is that they can be used to lay out hexagons. The code that draws Clojure Civitas hexagons is based on the triangular number formula.\n\nTriangular numbers also show up in the number of pairs, handshakes, edges in a complete graph, diagonals sum to triangular numbers, square numbers as sums of consecutive odd numbers, differences of triangulars, acceleration frames, smooth transitions, spacing. Such a beautiful pattern that can be found in so many situations!\nUntil next time, may your dice be fair and your outcomes interesting.\n\nsource: src/math/stats/quantquestions/what_are_the_odds/the_hidden_geometry_of_dice.clj"
  },
  {
    "objectID": "math/primes/factorization/sieve_augmented.html",
    "href": "math/primes/factorization/sieve_augmented.html",
    "title": "Factorization of Eratosthenes",
    "section": "",
    "text": "Adapts the Sieve of Eratosthenes to prime factorize numbers through n.\n\n(defn prime-factors [n]\n  (reduce\n   (fn [factors prime]\n     (if (= 1 (count (nth factors prime)))\n       (reduce\n        (fn [factors multiple]\n          (let [[composite-divisor :as divisors] (nth factors multiple)]\n            (if (&lt; prime composite-divisor)\n              (let [remaining-divisor (/ composite-divisor prime)\n                    remaining-divisors (nth factors remaining-divisor)\n                    prime-divisors (cons prime (rest divisors))]\n                (assoc\n                 factors multiple\n                 (if (&lt; 1 (count remaining-divisors))\n                   (concat remaining-divisors prime-divisors)\n                   (cons remaining-divisor prime-divisors))))\n              factors)))\n        factors\n        (range (* prime prime) (inc n) prime))\n       factors))\n   (mapv list (range (inc n)))\n   (range 2 (inc (m/sqrt n)))))\n\n\n(prime-factors 13)\n\n\n[(0)\n (1)\n (2)\n (3)\n (2 2)\n (5)\n (3 2)\n (7)\n (2 2 2)\n (3 3)\n (5 2)\n (11)\n (3 2 2)\n (13)]\n\n\nsource: src/math/primes/factorization/sieve_augmented.clj"
  },
  {
    "objectID": "internationalization/transliteration2.html",
    "href": "internationalization/transliteration2.html",
    "title": "More on transliteration",
    "section": "",
    "text": "In the last post on transliteration, I introduced the idea of transliteration as implemented in programming, and pointed out that the process of transforming text is more general. In that regard, the implementation that works for one use case will work for another. Now, the question is what is the most efficient and appropriate implementation?\nI talked about a prefix tree as easy for storing the sub-/strings to match on. However, in my pure Clojure implementation of a prefix tree, which is implemented using nested maps, the performance is slow. Very slow! But that‚Äôs not a reflection of Clojure, which is a language that is very practical and optimizes what it can. And the ethos of Clojure programming follows the maxim in programming, stemming from early Unix, of ‚Äúmake it work, make it right, make it fast‚Äù. As such, we should think about how to make this fast.\nTim asked me why this text transformation couldn‚Äôt have been implemented in a regex, and doing so would certainly make it fast. For example, to transliterate Tamil language text in Latin script into the Tamil script, my existing implementation would look like:\n\n(def s \"vaNakkam. padippavarkaLukku n-anRi.\")\n\n\n(def expected \"‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç. ‡Æ™‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡Æ±‡Æø.\")\n\n\n(cvt/romanized-&gt;‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç s)\n\n\n\"‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç. ‡Æ™‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡Æ±‡Æø.\"\n\n\n(assert (= expected (cvt/romanized-&gt;‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç s)))\n\n\nnil\n\nThat transliteration is converting Latin script into Tamil script in a somewhat predictable and intuitive way, such that: a -&gt; ‡ÆÖ, aa -&gt; ‡ÆÜ, ‚Ä¶, k -&gt; ‡Æï‡Øç, ng -&gt; ‡Æô‡Øç, etc. Tim‚Äôs point is that you can detect the input substrings using the regex, and then feed the matching substring occurrences into a replacement map to get the translation. His previous pseudocode in JS looked like this:\nlet text = \"this is a test\";\nconst replacementMap = { 'th': 'X', 't': 'Y' };\n\nlet result = text.replace(/th|t/g, (match) =&gt; {\n                                               return replacementMap[match];\n                                               });\n\nconsole.log(result);\nHe is taking into account the caveat that some of the substrings will overlap or be a superstring of other substrings, and therefore, order matters so that the right ‚Äúrule‚Äù (match + replace) is triggered.\nThis should work. Let‚Äôs try it. In the ‚Äúromanized-&gt;‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç‚Äù function, where the word ‚Äúromanized‚Äù really should be ‚ÄúLatin‚Äù for the name of the script, the conversions are more or less defined here: Let‚Äôs just reuse it!\n\ncvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map\n\n\n{\"d\" \"‡Æü‡Øç\",\n \"n\" \"‡Æ©‡Øç\",\n \"ee\" \"‡Æè\",\n \"z\" \"‡Æ¥‡Øç\",\n \"w\" \"‡Æ®‡Øç\",\n \"aa\" \"‡ÆÜ\",\n \"ii\" \"‡Æà\",\n \"s\" \"‡Æö‡Øç\",\n \"uu\" \"‡Æä\",\n \"e\" \"‡Æé\",\n \"zh\" \"‡Æ¥‡Øç\",\n \"ch\" \"‡Æö‡Øç\",\n \"q\" \"‡ÆÉ\",\n \"L\" \"‡Æ≥‡Øç\",\n \"p\" \"‡Æ™‡Øç\",\n \"oo\" \"‡Æì\",\n \"nth\" \"‡Æ®‡Øç‡Æ§‡Øç\",\n \"v\" \"‡Æµ‡Øç\",\n \"mb\" \"‡ÆÆ‡Øç‡Æ™‡Øç\",\n \"E\" \"‡Æè\",\n \"R\" \"‡Æ±‡Øç\",\n \"a\" \"‡ÆÖ\",\n \"t\" \"‡Æü‡Øç\",\n \"ai\" \"‡Æê\",\n \"U\" \"‡Æä\",\n \"ng\" \"‡Æô‡Øç\",\n \"O\" \"‡Æì\",\n \"i\" \"‡Æá\",\n \"k\" \"‡Æï‡Øç\",\n \"b\" \"‡Æ™‡Øç\",\n \"r\" \"‡Æ∞‡Øç\",\n \"y\" \"‡ÆØ‡Øç\",\n \"g\" \"‡Æï‡Øç\",\n \"l\" \"‡Æ≤‡Øç\",\n \"N\" \"‡Æ£‡Øç\",\n \"u\" \"‡Æâ\",\n \"A\" \"‡ÆÜ\",\n \"I\" \"‡Æà\",\n \"m\" \"‡ÆÆ‡Øç\",\n \"th\" \"‡Æ§‡Øç\",\n \"nj\" \"‡Æû‡Øç\",\n \"o\" \"‡Æí\",\n \"au\" \"‡Æî\",\n \"nr\" \"‡Æ©‡Øç‡Æ±‡Øç\",\n \"nd\" \"‡Æ£‡Øç‡Æü‡Øç\",\n \"n-\" \"‡Æ®‡Øç\"}\n\nNow to handle the caveat. As you can see, \"t\" is a substring of \"th\", and both are keys in the map. We effectively have to do a topological sort or some other graph traversal based on which keys are substrings of which other ones. In this particular case, a shortcut that is a huge hack (because it cannot possibly be generalizable) would be to sort the match strings in order of longest to shortest en route to constructing our regex string:\n\n(-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n     (sort-by count)\n     reverse)\n\n\n(\"nth\"\n \"n-\"\n \"nd\"\n \"nr\"\n \"au\"\n \"nj\"\n \"th\"\n \"ng\"\n \"ai\"\n \"mb\"\n \"oo\"\n \"ch\"\n \"zh\"\n \"uu\"\n \"ii\"\n \"aa\"\n \"ee\"\n \"o\"\n \"m\"\n \"I\"\n \"A\"\n \"u\"\n \"N\"\n \"l\"\n \"g\"\n \"y\"\n \"r\"\n \"b\"\n \"k\"\n \"i\"\n \"O\"\n \"U\"\n \"t\"\n \"a\"\n \"R\"\n \"E\"\n \"v\"\n \"p\"\n \"L\"\n \"q\"\n \"e\"\n \"s\"\n \"w\"\n \"z\"\n \"n\"\n \"d\")\n\nOur regex string will end up looking like:\n\n(-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n     (sort-by count)\n     reverse\n     (interpose \\|)\n     (apply str))\n\n\n\"nth|n-|nd|nr|au|nj|th|ng|ai|mb|oo|ch|zh|uu|ii|aa|ee|o|m|I|A|u|N|l|g|y|r|b|k|i|O|U|t|a|R|E|v|p|L|q|e|s|w|z|n|d\"\n\nOur regex would be formed by feeding it to re-pattern:\n\n(def regex (re-pattern (-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n                            (sort-by count)\n                            reverse\n                            (interpose \\|)\n                            (apply str))))\n\nWe can do segmentation on the input string based on the transliteration/transformation substring match keys:\n\n(re-seq regex s)\n\n\n(\"v\"\n \"a\"\n \"N\"\n \"a\"\n \"k\"\n \"k\"\n \"a\"\n \"m\"\n \"p\"\n \"a\"\n \"d\"\n \"i\"\n \"p\"\n \"p\"\n \"a\"\n \"v\"\n \"a\"\n \"r\"\n \"k\"\n \"a\"\n \"L\"\n \"u\"\n \"k\"\n \"k\"\n \"u\"\n \"n-\"\n \"a\"\n \"n\"\n \"R\"\n \"i\")\n\nWe can‚Äôt naively just transform the strings that match, however. Ex: you would lose the whitespace and punctuation in this example.\n\n(-&gt;&gt; (re-seq regex s)\n     (map cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n     fmt/phonemes-&gt;str)\n\n\n\"‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç‡Æ™‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ®‡Æ©‡Øç‡Æ±‡Æø\"\n\nSo we need to adjust our regex to be smart enough to have a ‚Äúdefault branch‚Äù that matches the next character if nothing else matches. We do this by appending the match all shortcut . to the end of the giant pattern alternation:\n\n(def regex (re-pattern (str (-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n                                 (sort-by count)\n                                 reverse\n                                 (interpose \\|)\n                                 (apply str))\n                            \"|.\")))\n\nNow, we get non-matching characters in the output\n\n(-&gt;&gt; (re-seq regex s)\n     (map #(or (cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map %) %))\n     fmt/phonemes-&gt;str)\n\n\n\"‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç. ‡Æ™‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡Æ±‡Æø.\"\n\nAnd for that matter, since the . regex alternation pattern matches a single character anyways, and you‚Äôre always doing a lookup on what is returned by the regex, we can remove any 1-character length strings from the regex pattern without change in functionality:\n\n(def regex (re-pattern (str (-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n                                 (sort-by count)\n                                 reverse\n                                 (remove #(= 1 (count %)))\n                                 (interpose \\|)\n                                 (apply str))\n                            \"|.\")))\n\nCheck that the output is the same:\n\n(-&gt;&gt; (re-seq regex s)\n     (map #(or (cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map %) %))\n     fmt/phonemes-&gt;str)\n\n\n\"‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç. ‡Æ™‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡Æ±‡Æø.\"\n\nLet‚Äôs see that the new regex is faster than the slightly older regex, and that they are indeed faster than the unoptimized pure Clojure prefix tree implementation.\n\n(def regex1 (re-pattern (str (-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n                                 (sort-by count)\n                                 reverse\n                                 (interpose \\|)\n                                 (apply str))\n                            \"|.\")))\n\n\n(def regex2 (re-pattern (str (-&gt;&gt; (keys cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map)\n                                 (sort-by count)\n                                 reverse\n                                 (remove #(= 1 (count %)))\n                                 (interpose \\|)\n                                 (apply str))\n                            \"|.\")))\n\n\n(def NUM-REPS 100)\n\n\n(time (dotimes [_ NUM-REPS]\n        (cvt/romanized-&gt;‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç s)))\n\n\n\n\n\n\n\nOUT\n\n\n\n\"Elapsed time: 160.491404 msecs\"\n\n\n\n\nnil\n\n\n(time (dotimes [_ NUM-REPS]\n        (-&gt;&gt; (re-seq regex1 s)\n             (map #(or (cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map %) %))\n             fmt/phonemes-&gt;str)))\n\n\n\n\n\n\n\nOUT\n\n\n\n\"Elapsed time: 113.833864 msecs\"\n\n\n\n\nnil\n\n\n(time (dotimes [_ NUM-REPS]\n        (-&gt;&gt; (re-seq regex2 s)\n             (map #(or (cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map %) %))\n             fmt/phonemes-&gt;str)))\n\n\n\n\n\n\n\nOUT\n\n\n\n\"Elapsed time: 83.225344 msecs\"\n\n\n\n\nnil\n\nWell, this is surprising. I assumed that the regex implementation would be significantly faster. Let‚Äôs try to investigate.\nMaybe the difference is less than we thought because fmt/phonemes-&gt;str is suspiciously inefficient (and also based on the prefix tree code). So what if we strike that out from the above expressions that were timed?\n\n(time (dotimes [_ NUM-REPS]\n        (-&gt;&gt; (re-seq regex2 s)\n             (map #(or (cvt/romanized-‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç-phoneme-map %) %))\n             str/join)))\n\n\n\n\n\n\n\nOUT\n\n\n\n\"Elapsed time: 2.107273 msecs\"\n\n\n\n\nnil\n\nSo fmt/phonemes-&gt;str is the culprit. And the implementation of it uses prefix tree code, which is ripe for optimization, perhaps similar to what we just proved here?\n\nsource: src/internationalization/transliteration2.clj"
  },
  {
    "objectID": "clojure/transducers/what_if.html",
    "href": "clojure/transducers/what_if.html",
    "title": "What if‚Ä¶ we were taught transducers first?",
    "section": "",
    "text": "Most Clojure tutorials start out with sequence functions like map, filter etc, and then explain how to avoid some of the problems that lazy sequences can cause. Transducers tend to be introduced later as a more advanced topic, but I‚Äôd argue that they could (and should) be taught earlier, and instead treat lazy sequences as an advanced topic.\nWhat if‚Ä¶ we were taught transducers first?\nWe‚Äôre typically taught to use map or filter on a sequence or collection to produce a new sequence ‚Äì and there‚Äôs often a comment that map applied to a vector does not produce a vector. With transducers, one of the key concepts is that the transformation is separated from the input and also from the output.\nLet‚Äôs start out with the sequence function, just to show how we can go straight to a sequence of results:\n\n(sequence (map inc) (range 5))\n\n\n(1 2 3 4 5)\n\nsequence works with multiple collections, like map:\n\n(sequence (map *) (range 5) (range 5) (range 5))\n\n\n(0 1 8 27 64)\n\n\n(sequence (map vector) (range 5) (range 5) (range 5))\n\n\n([0 0 0] [1 1 1] [2 2 2] [3 3 3] [4 4 4])\n\nHow about chaining several transformations together? We can use eduction (but see the caveats below about eduction):\n\n(eduction (filter even?) (map inc) (range 10))\n\n\n(1 3 5 7 9)\n\nLet‚Äôs look at producing different types of output, using into:\n\n(into [] (map inc) (range 5))\n\n\n[1 2 3 4 5]\n\n\n(into #{} (map inc) (range 5))\n\n\n#{1 4 3 2 5}\n\nUnder the hood, into uses conj so if you use a list, the order is reversed (because conj onto a list prepends items, whereas conj onto a vector appends items):\n\n(into () (map inc) (range 5))\n\n\n(5 4 3 2 1)\n\nFor the next level of control, we can use transduce to specify how to combine the results, as well as what we start with initially:\n\n(transduce (map inc) conj [] (range 5))\n\n\n[1 2 3 4 5]\n\n\n(transduce (map inc) conj #{} (range 5))\n\n\n#{1 4 3 2 5}\n\n\n(transduce (map inc) conj () (range 5))\n\n\n(5 4 3 2 1)\n\nWe might be tempted to use cons here, but its argument order is different from conj so this will fail:\n\n(transduce (map inc) cons () (range 5))\n\n\n\n\n\n\n\nDon‚Äôt know how to create ISeq from: java.lang.Long\n\n\n\n\n\n                    clojure.core/eval    core.clj: 3232\n                                  ...                 \nclojure.transducers.what-if/eval73029  REPL Input:     \n               clojure.core/transduce    core.clj: 7025\n                                  ...                 \n              clojure.core/map/fn{x2}    core.clj: 2759\n                    clojure.core/cons    core.clj:   29\n                                  ...                 \njava.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n\n\n\n\n\nOkay, well, let‚Äôs use an anonymous function to reverse the order of the arguments:\n\n(transduce (map inc) #(cons %2 %1) () (range 5))\n\n\n\n\n\n\n\nWrong number of args (1) passed to: clojure.transducers.what-if/eval73031/fn‚Äì73032\n\n\n\n\n\n                    clojure.core/eval    core.clj: 3232\n                                  ...                 \nclojure.transducers.what-if/eval73031  REPL Input:     \n               clojure.core/transduce    core.clj: 7027\n              clojure.core/map/fn{x2}    core.clj: 2757\n                                  ...                 \nclojure.lang.ArityException: Wrong number of args (1) passed to: clojure.transducers.what-if/eval73031/fn--73032\n\n\n\n\n\nWhy is it trying to call our cons wrapper with a single argument? In addition to separating the transformation from the output, transduce also has a ‚Äúcompletion‚Äù step, which is performed on the final result. A convenience function called completing can be used to wrap the function here to provide a ‚Äúno-op‚Äù completion:\n\n(transduce (map inc) (completing #(cons %2 %1)) () (range 5))\n\n\n(5 4 3 2 1)\n\ncompleting lets us provide a ‚Äúcompletion‚Äù function (instead of the default which is identity) so we could reverse the result:\n\n(transduce (map inc) (completing #(cons %2 %1) reverse) () (range 5))\n\n\n(1 2 3 4 5)\n\nInstead of producing a collection result, we can also use transduce to compute results in other ways:\n\n(transduce (map inc) + 0 (range 5))\n\n\n15\n\n\n(transduce (map inc) * 1 (range 5))\n\n\n120\n\nThe way (transduce xf f init coll) works is pretty much like this:\n(let [rf (xf f)]\n  (rf (reduce rf init coll)))\nNote how xf and f are combined to create a single ‚Äúreducing function‚Äù (which is a 2-arity function that takes an accumulator and a value), for the reduce and then also applied to the result as a 1-arity function, which is what completing does for us in the above example.\nNow let‚Äôs circle back to chaining transformations, while also controlling the output type. We can use comp for this. As a recap, here‚Äôs our eduction from earlier:\n\n(eduction (filter even?) (map inc) (range 10))\n\n\n(1 3 5 7 9)\n\nWe can compose multiple transducers:\n\n(comp (filter even?) (map inc))\n\n\n#fn [comp$fn]\n\nLet‚Äôs give this a name:\n\n(def evens+1 (comp (filter even?) (map inc)))\n\n\n(into [] evens+1 (range 10))\n\n\n[1 3 5 7 9]\n\n\n(into #{} evens+1 (range 10))\n\n\n#{7 1 3 9 5}\n\nWe glossed over the result of eduction earlier ‚Äì it produced a sequence because we printed it out, but it is a ‚Äúreducible‚Äù that has captured both its input and the series of transformations to apply, so we could pass it directly to into or transduce as if it were a collection:\n\n(into [] (eduction (filter even?) (map inc) (range 10)))\n\n\n[1 3 5 7 9]\n\n\n(into [] (eduction evens+1 (range 10)))\n\n\n[1 3 5 7 9]\n\nBecause it is a ‚Äúreducible‚Äù, it only does work when it is consumed, so it is ‚Äúlazy‚Äù in that sense, but it is not a lazy sequence. We can get a lazy sequence from a transducer using sequence, if we want, or we can rely on into and transduce etc being eager. In addition, eduction performs the transformations each time it is consumed:\n\n(let [s (eduction (map #(inc (doto % println))) (range 5))]\n  [(into [] s)\n   (into [] s)])\n\n\n\n\n\n\n\nOUT\n\n\n\n0\n1\n2\n3\n4\n0\n1\n2\n3\n4\n\n\n\n\n[[1 2 3 4 5] [1 2 3 4 5]]\n\nThat will print 0 1 2 3 4 twice, because the eduction is consumed twice. Compare that behavior to sequence, which produces a lazy sequence and caches its results:\n\n(let [s (sequence (map #(inc (doto % println))) (range 5))]\n  [(into [] s)\n   (into [] s)])\n\n\n\n\n\n\n\nOUT\n\n\n\n0\n1\n2\n3\n4\n\n\n\n\n[[1 2 3 4 5] [1 2 3 4 5]]\n\nThis will only print 0 1 2 3 4 once.\nIn conclusion, by separating the transformation from the input and the output, we gain expressive power, flexibility, and reuse: we can compose transducers, we can apply them to any input that produces values, and consume the results in any way we like.\nFor example, transducers can be used in several different ways with core.async channels:\n\non a channel\nin a pipeline\nor consumed with transduce\n\n\nsource: src/clojure/transducers/what_if.clj"
  },
  {
    "objectID": "games/beginning_to_build_a_browser_game.html",
    "href": "games/beginning_to_build_a_browser_game.html",
    "title": "Beginning to build a browser game",
    "section": "",
    "text": "I‚Äôm new to Clojure. I asked my new friend Timothy how to make a square appear on the screen:\n\n^:kind/hiccup\n[:svg [:rect {:width 50 :height 50}]]\n\n\nCompared to HTML:\n\n&lt;svg&gt;&lt;rect width=50 height=50 /&gt;&lt;/svg&gt;\n\nIt‚Äôs nice to not have to close tags, but I‚Äôm not sure about the colons, nor the dependencies.\nDependencies aside, we are this square. And we want to be able to move. Timothy, how can I move?\nWe‚Äôll separate the position data from the rendering:\n\n(def world (atom {:player {:x 75 :y 75}}))\n\n\n(defn render [world]\n  ^:kind/hiccup\n  [:svg {:style {:border \"1px solid black\"}}\n   (for [[_entity-id {:keys [x y]}] world]\n     [:rect {:width 50 :height 50 :x x :y y}])])\n\n\n(render @world)\n\n\nWe‚Äôll add an enemy to see how to work with atom:\n\n(swap! world assoc :enemy {:x 130 :y 75})\n\n\n{:player {:x 75, :y 75}, :enemy {:x 130, :y 75}}\n\n\n(render @world)\n\n\nLet us be different shapes:\n\n(defn render [world]\n  ^:kind/hiccup\n  [:svg {:style {:border \"1px solid black\"}}\n   (for [[entity-id {:keys [x y]}] world]\n     (if (= entity-id :player)\n       [:rect {:width 50 :height 50 :fill \"#62b133\" :x x :y y :id \"player\"}]\n       [:circle {:r 25 :fill \"#5880d9\" :cx x :cy y :id \"enemy\"}]))])\n\n\n(render @world)\n\n\nNow would be a perfect time to use Reagent to connect the user‚Äôs keyboard to our world atom. However, I couldn‚Äôt get it working with Clay (what we‚Äôre using to render this page). The dependencies have won the first battle.\nMoving on, we‚Äôll resort to a script element. Clay lets us use JavaScript, but I couldn‚Äôt get it to work with curly braces. Suffering a one-liner, we can now move, via WASD on our keyboard.\n\n^:kind/hiccup\n[:script #\"document.addEventListener('keydown', e =&gt; (['w', 'W'].includes(e.key) && player.setAttribute('y', parseInt(player.getAttribute('y')) - 10) || ['a', 'A'].includes(e.key) && player.setAttribute('x', parseInt(player.getAttribute('x')) - 10) || ['s', 'S'].includes(e.key) && player.setAttribute('y', parseInt(player.getAttribute('y')) + 10) || ['d', 'D'].includes(e.key) && player.setAttribute('x', parseInt(player.getAttribute('x')) + 10)))\"]\n\n\n\nsource: src/games/beginning_to_build_a_browser_game.clj"
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html",
    "href": "core/async/flow/example/asynctopolis.html",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "",
    "text": "Welcome to Asynctopolis, a city where agents act on signals, not orders. Here, unseen agents pass messages, track patterns, and sound alarms when the moment calls. No one oversees the whole city, yet everything flows.\nBeneath it all hums the Core Async Flow, a network of processes working together without ever meeting. Today, you‚Äôll observe the agents of this asynchronous allegiance.\nThis code is adapted from Alex‚Äôs stats flow example, used for his video walkthrough.\nIn Asynctopolis, there are often races to print messages, which for the sake of clarity we shall serialize.\nAbove us in the sky flies Talon the Stat Hawk. Sleek, silent, and tireless. With a glint in his eye and wings tipped in probability, he soars into the realm of the unknowable every half second, returning with a fresh stat clutched in his talons. He doesn‚Äôt question, he doesn‚Äôt falter. He circles over the range from min to max, plucks a random integer, and drops it onto a channel without ceremony.\nBorn of wind and randomness, Talon is no ordinary bird. He executes his mission with the rhythm and the grace of chance incarnate. Talon embodies an ongoing loop. An autonomous creature of purpose, relentless and unthinking. To be a process is to endure. Ever watchful, speaking in channels.\nFly Talon! Collect samples. Let‚Äôs see what distribution you bring.\nYou have sampled fairly, Talon.\nTalon operates at the behest of the city‚Äôs Generator."
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html#meet-randomius-maximus-the-generator",
    "href": "core/async/flow/example/asynctopolis.html#meet-randomius-maximus-the-generator",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "Meet Randomius Maximus, the Generator",
    "text": "Meet Randomius Maximus, the Generator\nIn a stone tower at the edge of the async city lives Randomius Maximus. Robed in numbers, crowned with entropy, keeper of the unceasing stream. He does not wander. He does not speak. He gestures, and Talon flies.\nWith a sweep of his hand, he dispatches his hawk to gather truths from the swirling chaos. Min and Max are his decree. Wait is his tempo. As long as his flow runs, the stats will come.\nTo be a true citizen of Asynctopolis is to be known as a process. To follow the sacred cycle of Vita Processus: Describe your duties. Initialize your station. Transition with order. Transform with purpose.\n\n(defn Randomius\n  \"Source proc for random stats\"\n  ;; describe\n  ([]\n   (println* \"I am Randomius, I take numbers from Talon and send them out.\")\n   {:params {:min  \"Min value to generate\"\n             :max  \"Max value to generate\"\n             :wait \"Time in ms to wait between generating\"}\n    :outs   {:out \"Output channel for stats\"}})\n\n  ;; init\n  ([args]\n   (println* \"Randomius initialing\")\n   (assoc args\n     :clojure.core.async.flow/in-ports {:stat (a/chan 100)}\n     :flying (atom false)))\n\n  ;; transition\n  ([{:keys [min max wait flying clojure.core.async.flow/in-ports] :as state} transition]\n   (println* \"Randomius transitioning\" transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (do\n       (when (not @flying)\n         (println* \"Talon, set flight!\")\n         (reset! flying true)\n         (future (Talon (:stat in-ports) min max wait flying)))\n       state)\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (when @flying\n         (println* \"Talon, rest!\")\n         (reset! flying false))\n       state)))\n\n  ;; transform\n  ([state input-id msg]\n   (println* \"Randomius transform\" msg \"from\" input-id \"to\" :out)\n   [state {:out [msg]}]))\n\nRandomius, describe your duties!\n\n(Randomius)\n\n\n\n\n\n\n\nOUT\n\n\n\nI am Randomius, I take numbers from Talon and send them out.\n\n\n\n\n{:params\n {:min \"Min value to generate\",\n  :max \"Max value to generate\",\n  :wait \"Time in ms to wait between generating\"},\n :outs {:out \"Output channel for stats\"}}\n\nInitialize your station!\n\n(def state\n  (atom (Randomius {:min  10\n                    :max  20\n                    :wait 1})))\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius initialing\n\n\n\n\n^:kind/println\n@state\n\n\n{:min 10, :max 20, :wait 1, :clojure.core.async.flow/in-ports {:stat #object [ManyToManyChannel]}, :flying #object[clojure.lang.Atom 0x2c4e3606 {:status :ready, :val false}]}\n\nTransition with order.\n\n(swap! state Randomius :clojure.core.async.flow/resume)\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/resume\nTalon, set flight!\n\n\n\n\n{:min 10,\n :max 20,\n :wait 1,\n :clojure.core.async.flow/in-ports {:stat #object [ManyToManyChannel]},\n :flying #&lt;Atom@2c4e3606: false&gt;}\n\nTalon is flying.\n\n(-&gt; (:clojure.core.async.flow/in-ports @state)\n    (:stat)\n    (a/&lt;!!))\n\n\n15\n\nTransform with purpose.\n\n(swap! state\n       (fn [state]\n         (let [[state step] (Randomius state :stat \"I transform, therefore I am\")]\n           (println* step)\n           state)))\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius transform I transform, therefore I am from :stat to :out\n{:out [I transform, therefore I am]}\n\n\n\n\n{:min 10,\n :max 20,\n :wait 1,\n :clojure.core.async.flow/in-ports {:stat #object [ManyToManyChannel]},\n :flying #&lt;Atom@2c4e3606: false&gt;}\n\nI see you wish to send a missive to out. Be wary in the future, send only numbers to those who seek stats.\nWell done, Randomius. You are a true citizen. Now rest.\n\n(swap! state Randomius :clojure.core.async.flow/stop)\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/stop\nTalon, rest!\n\n\n\n\n{:min 10,\n :max 20,\n :wait 1,\n :clojure.core.async.flow/in-ports {:stat #object [ManyToManyChannel]},\n :flying #&lt;Atom@2c4e3606: false&gt;}"
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html#meet-tallystrix-the-whispering-aggregator",
    "href": "core/async/flow/example/asynctopolis.html#meet-tallystrix-the-whispering-aggregator",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "Meet Tallystrix, the Whispering Aggregator",
    "text": "Meet Tallystrix, the Whispering Aggregator\nIn the marble shadows of the Hall of Measures, Tallystrix gathers numbers in her obsidian basin. She listens not to the sky, but to the stat channel, where strange numbers arrive without explanation. She lets them settle, silent and still.\nShe says nothing‚Äîuntil the bell rings. Then, with a tilt of the bowl and a whisper of reckoning, she releases the average to those who asked.\nIf a number is too high or too low, she sends a warning, a flare in the async night.\n\n(defn Tallystrix\n  ;; describe\n  ([]\n   (println* \"I am Tallystrix, I take from stats or poke, and put to alert and notify\")\n   {:params   {:min \"Min value, alert if lower\"\n               :max \"Max value, alert if higher\"}\n    :ins      {:stat \"Channel to receive stat values\"\n               :poke \"Channel to poke when it is time to report a window of data to the log\"}\n    :outs     {:alert \"Notify of value out of range {:val value, :error :high|:low\"}\n    :workload :compute})\n\n  ;; init\n  ([args]\n   (println* \"Tallystrix initializing\")\n   (assoc args :vals []))\n\n  ;; transition\n  ([state transition]\n   (println* \"Tallystrix transitioning\" transition)\n   state)\n\n  ;; transform\n  ([{:keys [min max vals] :as state} input-id msg]\n   (println* \"Tallystrix transforming\" input-id msg)\n   (case input-id\n     :stat (let [state' (assoc state :vals (conj vals msg))\n                 msgs (cond\n                        (&lt; msg min) {:alert [{:val msg, :error :low}]}\n                        (&lt; max msg) {:alert [{:val msg, :error :high}]}\n                        :else nil)]\n             [state' msgs])\n     :poke [(assoc state :vals [])\n            {:clojure.core.async.flow/report (if (empty? vals)\n                                               [{:count 0}]\n                                               [{:avg   (/ (double (reduce + vals)) (count vals))\n                                                 :count (count vals)}])}])))\n\nTallystrix, what messages have you?\n\n(let [state {:min 1 :max 5 :vals []}\n      [state' msgs'] (Tallystrix state :stat 7)]\n  msgs')\n\n\n\n\n\n\n\nOUT\n\n\n\nTallystrix transforming :stat 7\n\n\n\n\n{:alert [{:val 7, :error :high}]}\n\nWell alerted. Your transform is sound."
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html#meet-chronon-the-scheduler-of-bells",
    "href": "core/async/flow/example/asynctopolis.html#meet-chronon-the-scheduler-of-bells",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "Meet Chronon, the Scheduler of Bells",
    "text": "Meet Chronon, the Scheduler of Bells\nIn a chamber just outside the Hall of Measures, Chronon stands beside a great brass bell. Every few thousand milliseconds, he raises his staff and strikes it. A chime ripples through the channels and stirs the Aggregator within.\nHe does not wait for thanks. He does not miss a beat. His duty is rhythm. His gift is regularity. And with every ring, the silence grows wiser.\n\n(defn Chronon\n  ;; describe\n  ([]\n   (println* \"I am Chronon, I poke out periodically\")\n   {:params {:wait \"Time to wait between pokes\"}\n    :outs   {:out \"Poke channel, will send true when the alarm goes off\"}})\n\n  ;; init\n  ([args]\n   (println* \"Chronon initializing\")\n   (assoc args\n     :clojure.core.async.flow/in-ports {:alarm (a/chan 10)}\n     :running (atom false)))\n\n  ;; transition\n  ([{:keys [wait running clojure.core.async.flow/in-ports] :as state} transition]\n   (println* \"Chronon transitioning\" transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (do\n       (when (not @running)\n         (println* \"Chronon running\")\n         (reset! running true)\n         (future (while @running\n                   (if (a/&gt;!! (:alarm in-ports) true)\n                     (Thread/sleep ^long wait)\n                     (reset! running false)))))\n       state)\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (when @running\n         (println* \"Chronon rests.\")\n         (reset! running false))\n       state)))\n\n  ;; transform\n  ([state input-id msg]\n   (println* \"Chronon transforms\" input-id msg \"to\" :out)\n   [state {:out [msg]}]))\n\nChronon has no familiar to do his work, and listens only to himself."
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html#meet-claxxus-the-notifier-the-herald",
    "href": "core/async/flow/example/asynctopolis.html#meet-claxxus-the-notifier-the-herald",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "Meet Claxxus, the Notifier, the Herald",
    "text": "Meet Claxxus, the Notifier, the Herald\nAt the city‚Äôs edge stands Claxxus, cloaked in red and brass, eyes ever on the flame that signals alarm. He does not gather, he does not measure, he only declares.\nWhen Tallystrix sends a flare, Claxxus steps forward to speak. He raises his voice for all to hear: ‚ÄúOut of range!‚Äù\n\n(defn Claxxus\n  ;; describe\n  ([]\n   (println* \"I am Claxxus, I shout what I hear from in\")\n   {:params {:prefix \"Log message prefix\"}\n    :ins    {:in \"Channel to receive messages\"}})\n\n  ;; init\n  ([state]\n   (println* \"Claxxus initializing\")\n   state)\n\n  ;; transition\n  ([state transition]\n   (println* \"Claxxus transitioning\" transition)\n   state)\n\n  ;; transform\n  ([{:keys [prefix] :as state} input-id msg]\n   (println* \"Claxxus transforming\" input-id msg)\n   (println* prefix msg)\n   [state nil]))\n\nCursed to know only how to shout.\n\n(Claxxus {:prefix \"ERROR:\"} :in \"Out of range!\")\n\n\n\n\n\n\n\nOUT\n\n\n\nClaxxus transforming :in Out of range!\nERROR: Out of range!\n\n\n\n\n[{:prefix \"ERROR:\"} nil]"
  },
  {
    "objectID": "core/async/flow/example/asynctopolis.html#the-asynchronous-allegiance",
    "href": "core/async/flow/example/asynctopolis.html#the-asynchronous-allegiance",
    "title": "Stats and Signals in the Flow of Asynctopolis",
    "section": "The Asynchronous Allegiance",
    "text": "The Asynchronous Allegiance\nAll these roles are bound together in a flow, a living graph of asynchronous collaboration.\nRandomius Maximus generates. Chronon keeps the beat. Tallystrix listens and computes. Claxxus alerts.\nThey never meet. They never speak. Yet they move as one.\nThis is an allegiance, asynchronous and unseen. Held together by channels, purpose, and trust.\n\n(def config\n  {:procs {:Randomius  {:args {:min 0 :max 12 :wait 500}\n                        :proc (flow/process #'Randomius)}\n           :Tallystrix {:args {:min 1 :max 10}\n                        :proc (flow/process #'Tallystrix)}\n           :Chronon    {:args {:wait 3000}\n                        :proc (flow/process #'Chronon)}\n           :Claxxus    {:args      {:prefix \"Alert: \"}\n                        :proc      (flow/process #'Claxxus)\n                        :chan-opts {:in {:buf-or-n (a/sliding-buffer 3)}}}}\n   :conns [[[:Randomius :out] [:Tallystrix :stat]]\n           [[:Chronon :out] [:Tallystrix :poke]]\n           [[:Tallystrix :alert] [:Claxxus :in]]]})\n\n\n\n\n\n\n\nOUT\n\n\n\nI am Randomius, I take numbers from Talon and send them out.\nI am Tallystrix, I take from stats or poke, and put to alert and notify\nI am Chronon, I poke out periodically\nI am Claxxus, I shout what I hear from in\n\n\n\n\n^:kind/hiccup\n[:iframe {:width  \"100%\"\n          :height \"600px\"\n          :srcdoc (flow-static/template config nil)}]\n\n\nThe Flow creates them, calling upon their civic duties, Describe your duties. Initialize your station.\n\n(def flow (flow/create-flow config))\n\nThe city is ready, but not yet in action.\n\n(def chs (flow/start flow))\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius initialing\nTallystrix initializing\nChronon initializing\nClaxxus initializing\n\n\n\n\nchs\n\n\n{:report-chan #object [ManyToManyChannel],\n :error-chan #object [ManyToManyChannel]}\n\nreport-chan and error-chan are special conduits in the Flow. Tallystrix sends her summaries to report, dutifully. When something breaks it flows to error.\n\n(a/poll! (:report-chan chs))\n\n\nnil\n\nStart initialized, but transitioning has not occurred yet. Transition with order.\n\n(flow/resume flow)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/resume\nTalon, set flight!\nSQUARK: 5\nRandomius transform 5 from :stat to :out\nTallystrix transitioning :clojure.core.async.flow/resume\nTallystrix transforming :stat 5\nChronon transitioning :clojure.core.async.flow/resume\nChronon running\nClaxxus transitioning :clojure.core.async.flow/resume\n\n\n\n\ntrue\n\n\n(Thread/sleep 1)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nChronon transforms :alarm true to :out\nTallystrix transforming :poke true\n\n\n\n\nnil\n\nThe city breathes, the asynchronous allegiance stirs.\nTransform with purpose.\n\n(a/poll! (:report-chan chs))\n\n\n{:avg 5.0, :count 1}\n\n\n(a/poll! (:report-chan chs))\n\n\nnil\n\n\n(flow/inject flow [:Tallystrix :poke] [true])\n\n\n#object [FutureTask]\n\n\n(a/poll! (:report-chan chs))\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nTallystrix transforming :poke true\n\n\n\n\n{:count 0}\n\nMischief is afoot.\n\n(flow/inject flow [:Tallystrix :stat] [\"abc1000\"])\n\n\n#object [FutureTask]\n\n\n(a/poll! (:error-chan chs))\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nTallystrix transforming :stat abc1000\n\n\n\n\n#:clojure.core.async.flow{:pid :Tallystrix,\n                          :status :running,\n                          :state\n                          {:min 1,\n                           :max 10,\n                           :clojure.core.async.flow/pid :Tallystrix,\n                           :vals []},\n                          :count 4,\n                          :cid :stat,\n                          :msg \"abc1000\",\n                          :op :step,\n                          :ex #error {\n :cause \"class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\"\n :via\n [{:type java.util.concurrent.ExecutionException\n   :message \"java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\"\n   :at [java.util.concurrent.FutureTask report \"FutureTask.java\" 122]}\n  {:type java.lang.ClassCastException\n   :message \"class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap')\"\n   :at [clojure.lang.Numbers lt \"Numbers.java\" 253]}]\n :trace\n [[clojure.lang.Numbers lt \"Numbers.java\" 253]\n  [core.async.flow.example.asynctopolis$Tallystrix invokeStatic \"NO_SOURCE_FILE\" 224]\n  [core.async.flow.example.asynctopolis$Tallystrix invoke \"NO_SOURCE_FILE\" 197]\n  [clojure.lang.AFn applyToHelper \"AFn.java\" 160]\n  [clojure.lang.AFn applyTo \"AFn.java\" 144]\n  [clojure.lang.Var applyTo \"Var.java\" 707]\n  [clojure.core$apply invokeStatic \"core.clj\" 667]\n  [clojure.core$apply invoke \"core.clj\" 662]\n  [clojure.core.async.flow.impl$futurize$fn__52066$fn__52067 invoke \"impl.clj\" 34]\n  [clojure.lang.AFn call \"AFn.java\" 18]\n  [java.util.concurrent.FutureTask run \"FutureTask.java\" 317]\n  [java.util.concurrent.ThreadPoolExecutor runWorker \"ThreadPoolExecutor.java\" 1144]\n  [java.util.concurrent.ThreadPoolExecutor$Worker run \"ThreadPoolExecutor.java\" 642]\n  [java.lang.Thread run \"Thread.java\" 1583]]}}\n\nClaxxus does not speak of such failures. He is for alerts. Thresholds breached, events of note, things the city must hear.\n\n(flow/inject flow [:Claxxus :in] [:sandwich])\n\n\n#object [FutureTask]\n\n\n(Thread/sleep 1)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nClaxxus transforming :in :sandwich\nAlert:  :sandwich\n\n\n\n\nnil\n\nFluxus est graphum, fluxus est processus, fluxus est data.\n\n(datafy/datafy flow)\n\n\n{:procs\n {:Randomius\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step core.async.flow.example.asynctopolis/Randomius,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :Tallystrix\n  {:args {:min 1, :max 10},\n   :proc\n   {:step core.async.flow.example.asynctopolis/Tallystrix,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :Chronon\n  {:args {:wait 3000},\n   :proc\n   {:step core.async.flow.example.asynctopolis/Chronon,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :Claxxus\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step core.async.flow.example.asynctopolis/Claxxus,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:Randomius :out] [:Tallystrix :stat]]\n  [[:Chronon :out] [:Tallystrix :poke]]\n  [[:Tallystrix :alert] [:Claxxus :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans\n {:ins\n  {[:Tallystrix :stat]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:Tallystrix :poke]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:Claxxus :in]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}}},\n  :outs\n  {[:Randomius :out]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:Tallystrix :alert]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}},\n   [:Chronon :out]\n   {:put-count 0,\n    :take-count 1,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}}},\n  :error\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}},\n  :report\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}}}}\n\nThe flow may coordinate peace.\n\n(flow/pause flow)\n\n\ntrue\n\n\n(Thread/sleep 1)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/pause\nTalon, rest!\nClaxxus transitioning :clojure.core.async.flow/pause\nChronon transitioning :clojure.core.async.flow/pause\nChronon rests.\nTallystrix transitioning :clojure.core.async.flow/pause\n\n\n\n\nnil\n\nPax optima rerum.\nThe flow may cease.\n\n(flow/stop flow)\n\n\ntrue\n\n\n(Thread/sleep 1)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/stop\nChronon transitioning :clojure.core.async.flow/stop\nClaxxus transitioning :clojure.core.async.flow/stop\nTallystrix transitioning :clojure.core.async.flow/stop\n\n\n\n\nnil\n\nThe city falls silent.\nThus does Asynctopolis coordinate, thus is Vita Processus observed.\nThe flow of Asynctopolis is a choreography of concurrent logic, where each part knows just enough to play its role, and no more. It‚Äôs a quiet network of intent. Each role with a narrow purpose, joined by shared channels and rhythm.\nYou can observe its work as it happens. You can inspect, poke, pause, and resume. Buffers shape its tempo, and transitions reveal its state.\nIn Asynctopolis, no one rules, yet the system flows precisely, predictably, asynchronously.\n\nsource: src/core/async/flow/example/asynctopolis.clj"
  },
  {
    "objectID": "civitas/repl.html",
    "href": "civitas/repl.html",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "",
    "text": "‚ÄúWould you like to make that interactive?‚Äù\n‚Äì The eternal question facing documentation writers.\nMost code documentation has either static code with fixed results or dynamic editor blocks with evaluated results. This post explores a third option, a sidebar REPL that coexists with static examples, letting you copy interesting snippets and build on them."
  },
  {
    "objectID": "civitas/repl.html#persistent-workspace-benefits",
    "href": "civitas/repl.html#persistent-workspace-benefits",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "Persistent Workspace Benefits",
    "text": "Persistent Workspace Benefits\nThe sidebar REPL mirrors the intuitive ‚Äúone environment, one REPL‚Äù model, keeping state across interactions.\n\n(kind/hiccup\n  '((require '[reagent.core :as r])\n    (defonce state (r/atom {:zaniness \"moderate\"\n                            :mood \"curious\"}))))\n\n\nWe start with some initial mood and zaniness. Here‚Äôs a suggestion to modify it:\n(swap! state assoc :zaniness \"maximum\")\n\n\n\n\n\n\nTip\n\n\n\nClick the ‚Äúcopy‚Äù icon in the code example to transfer it to the REPL window.\n\n\nAnd now we‚Äôll add to the post a mini-app for monitoring the state.\n\n(kind/hiccup\n  [:div.card {:style {:margin \"20px 0\"\n                      :max-width \"600px\"}}\n   [:div.card-header.bg-success.text-white\n    [:h5.mb-0 \"üîç State Monitor\"]]\n   [:div.card-body\n    [:dl.row.mb-0\n     [:dt.col-sm-3.text-end \"Current state:\"]\n     [:dd.col-sm-9\n      [:div.p-2.bg-light.border.rounded.font-monospace.small\n       ['(fn [] (pr-str @state))]]]\n     [:dt.col-sm-3.text-end \"Instructions:\"]\n     [:dd.col-sm-9.text-muted.small\n      \"Try: \" [:div.sourceCode [:code \"(swap! state assoc :key \\\"value\\\")\"]] \" in the REPL\"]]]])\n\nüîç State MonitorCurrent state:Instructions:Try: (swap! state assoc :key \"value\") in the REPL\nThe state you create in the REPL affects page components."
  },
  {
    "objectID": "civitas/repl.html#curated-and-open-exploration",
    "href": "civitas/repl.html#curated-and-open-exploration",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "Curated and Open Exploration",
    "text": "Curated and Open Exploration\nAuthors can provide focused examples for specific learning goals, while readers can pursue tangents. Here‚Äôs an example showcasing Clojure‚Äôs frequencies function with some delicious data:\n\n(frequencies [\"apple\"\n              \"banana\"\n              \"apple\"\n              \"cherry\"\n              \"banana\"\n              \"apple\"])\n\n\n{\"apple\" 3, \"banana\" 2, \"cherry\" 1}\n\nTry it with different data, maybe the letters in your name.\n(frequencies \"supercalifragilisticexpialidocious\")\nOr simulate random selections:\n(frequencies (repeatedly 1000\n                         #(rand-nth [:a :b :c :d :e :f])))"
  },
  {
    "objectID": "civitas/repl.html#visual-playground",
    "href": "civitas/repl.html#visual-playground",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "Visual Playground",
    "text": "Visual Playground\nThe REPL can affect components on the page. This interactive canvas demonstrates how data can drive visual elements.\n\n(kind/hiccup\n  [:div.card {:style {:margin \"20px 0\"}}\n   [:div.card-header.bg-primary.text-white\n    [:h5.mb-0 \"üé® Interactive Canvas\"]]\n   [:div.card-body\n    [:p.mb-3 \"Shapes controlled by \" [:code \"@state\"] \" ‚Äî use the REPL to create and modify them.\"]\n    ['(fn []\n       [:svg {:xmlns \"http://www.w3.org/2000/svg\"\n              :width \"100%\"\n              :height \"250px\"\n              :viewBox \"0 0 500 250\"\n              :style {:border \"2px solid #dee2e6\" :border-radius \"4px\" :background \"#f8f9fa\"}}\n        ;; Grid pattern\n        [:defs\n         [:pattern {:id \"grid\" :width \"50\" :height \"50\" :patternUnits \"userSpaceOnUse\"}\n          [:path {:d \"M 50 0 L 0 0 0 50\" :fill \"none\" :stroke \"#e9ecef\" :stroke-width \"1\"}]]]\n        [:rect {:width \"500\" :height \"250\" :fill \"url(#grid)\"}]\n        ;; Dynamic shapes from state\n        (for [{:keys [type x y size color]} (:shapes @state)]\n           (case type\n             :circle [:circle {:cx x :cy y :r size :fill color :stroke \"#333\" :stroke-width 1}]\n             :square [:rect {:x (- x size) :y (- y size)\n                             :width (* 2 size) :height (* 2 size)\n                             :fill color :stroke \"#333\" :stroke-width 1}]\n             :triangle [:polygon {:points (str x \",\" (- y size) \" \"\n                                               (- x size) \",\" (+ y size) \" \"\n                                               (+ x size) \",\" (+ y size))\n                                  :fill color :stroke \"#333\" :stroke-width 1}]\n             nil))])]]])\n\nüé® Interactive CanvasShapes controlled by @state ‚Äî use the REPL to create and modify them.\nAdd a single shape (maybe a tiny orange dot? üü†):\n(swap! state update :shapes conj\n  {:type :circle :x 250 :y 200 :size 15 :color \"#f39c12\"})\n\n\n\n\n\n\nTip\n\n\n\nClick the ‚Äúcopy‚Äù icon in the code example to transfer it to the REPL window, then press CTRL+Enter to eval.\n\n\nAdd more shapes by modifying the :shapes vector:\n(swap! state update :shapes into\n  [{:type :circle :x 100 :y 100 :size 30 :color \"#e74c3c\"}\n   {:type :square :x 200 :y 150 :size 25 :color \"#3498db\"}\n   {:type :triangle :x 350 :y 100 :size 40 :color \"#2ecc71\"}])\nGenerate a ‚ú®random constellation‚ú®:\n(swap! state assoc :shapes\n  (repeatedly 15\n    #(hash-map :type (rand-nth [:circle :square :triangle])\n               :x (rand-int 500)\n               :y (rand-int 250)\n               :size (+ 8 (rand-int 25))\n               :color (rand-nth [\"#e74c3c\" \"#3498db\" \"#2ecc71\"\n                                 \"#f39c12\" \"#9b59b6\" \"#1abc9c\"]))))"
  },
  {
    "objectID": "civitas/repl.html#the-full-development-experience",
    "href": "civitas/repl.html#the-full-development-experience",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "The Full Development Experience",
    "text": "The Full Development Experience\nWhile the sidebar REPL provides convenient experimentation for simple examples, the real power of Clay is in working with the source code. Clone the repository and open it in your editor to get the full interactive notebook experience. You can modify examples, create new namespaces, and contribute ideas back to the community. Add your own namespace under src/ and it is published as a new post."
  },
  {
    "objectID": "civitas/repl.html#sidebar-repl-usage",
    "href": "civitas/repl.html#sidebar-repl-usage",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "Sidebar REPL Usage",
    "text": "Sidebar REPL Usage\nClojureCivitas authors can require this namespace and enable the REPL sidebar:\n(require '[civitas.repl :as repl])\n(repl/scittle-sidebar)\nSet :page-layout :full in the :quarto metadata to make best use of the available page space.\n\n\n\nI‚Äôll have the static examples with a side of REPL, thanks"
  },
  {
    "objectID": "civitas/repl.html#wrapping-up",
    "href": "civitas/repl.html#wrapping-up",
    "title": "I‚Äôll take a side of REPL with that",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nI hope you enjoyed exploring this sidebar REPL approach. The sidebar REPL complements Clay‚Äôs strength of showing examples and results. Authors can intersperse static examples with outputs and interactive prompts for experimentation. The real magic happens when you clone this repository and work with the source code directly.\nReady to contribute? Add your own namespace under src/ and it becomes a new post automatically.\nJoin the conversation: The best place to discuss this feature, share improvements, or ask questions is the Zulip: clay-dev channel\nGive it a try and let us know what you think! üöÄ\n\n\nsource: src/civitas/repl.clj"
  },
  {
    "objectID": "civitas/explorer.html",
    "href": "civitas/explorer.html",
    "title": "Explorer",
    "section": "",
    "text": "We need a database of Clojure learning resources.\nOfficial Clojure DocumentationClojure for the Brave and TrueTransducers ExplainedClojureScript GuideReagent Documentationre-frame: A React FrameworkLuminus Web FrameworkTablecloth: Dataframe LibraryClay Documentationtech.ml Machine Learningdeps.edn ReferenceCIDER for Emacsshadow-cljs Build ToolKaocha Test RunnerSciCloj CommunityClojureCamp EventsClojureTV YouTubeClojurians SlackPracticalli TutorialsJVM Performance GuideComponent LibrarynREPL ProtocolDatomic DatabaseXTDB Documentation\n\n\nidtitleurlformattopicleveldepends-onclj-docsOfficial Clojure Documentationhttps://clojure.org/guides/getting_startedreference[:core]\n0brave-clojureClojure for the Brave and Truehttps://www.braveclojure.com/interactive-book[:core :core/fp]\n1transducersTransducers Explainedhttps://www.youtube.com/watch?v=6mTbuzafcIIvideo[:core :core/fp]\n2[\"clj-docs\"]\nreagent-docsReagent Documentationhttps://reagent-project.github.io/library-docs[:web :web/frontend]\n1re-framere-frame: A React Frameworkhttps://day8.github.io/re-frame/library-docs[:web :web/frontend]\n2[\"reagent-docs\"]\nluminusLuminus Web Frameworkhttps://luminusweb.com/framework[:web :web/backend]\n2tableclothTablecloth: Dataframe Libraryhttps://github.com/scicloj/tableclothlibrary-docs[:data :data/analysis]\n1clayClay Documentationhttps://scicloj.github.io/clay/publishing-tool[:data]\n2tech.mltech.ml Machine Learninghttps://github.com/techascent/tech.mllibrary-docs[:data :data/ml]\n3deps-edndeps.edn Referencehttps://clojure.org/reference/deps_and_clireference[:tooling]\n0ciderCIDER for Emacshttps://docs.cider.mx/tool-docs[:tooling :tooling/repl]\n1shadow-cljsshadow-cljs Build Toolhttps://shadow-cljs.github.io/docs/UsersGuide.htmltool-docs[:tooling :tooling/build]\n2sciclojSciCloj Communityhttps://scicloj.github.io/community[:community :community/orgs]\n0clojure-campClojureCamp Eventshttps://clojurecamp.berlin/community[:community :community/events]\n1clojure-tvClojureTV YouTubehttps://www.youtube.com/user/ClojureTVvideo-channel[:community :community/learning]\n0clojuriansClojurians Slackhttp://clojurians.net/community[:community :community/chat]\n0practicalliPracticalli Tutorialshttps://practical.li/tutorials[:community :community/learning]\n1jvm-tuningJVM Performance Guidehttps://clojure.org/reference/jvm_programmingguide[:systems :systems/production]\n3componentComponent Libraryhttps://github.com/stuartsierra/componentlibrary-docs[:systems :systems/design]\n2nreplnREPL Protocolhttps://nrepl.org/protocol[:systems :systems/tooling]\n2datomicDatomic Databasehttps://docs.datomic.com/cloud/database[:systems :systems/data :data/db]\n3clojurescriptClojureScript Guidehttps://clojurescript.org/reference[:core :web :tooling]\n1kaochaKaocha Test Runnerhttps://github.com/lambdaisland/kaochatool-docs[:tooling :tooling/testing]\n2xtdbXTDB Documentationhttps://xtdb.com/database[:systems :systems/data :data/db]\n3\n\n\n\nsource: src/civitas/explorer.clj"
  },
  {
    "objectID": "civitas/authors.html",
    "href": "civitas/authors.html",
    "title": "Authors",
    "section": "",
    "text": "You belong here!\nThank you for sharing your ideas.\nAlex MillerClojure.coreChris HouserDaniel SlutskySciclojElango CheranHaroldTechAscentMatt KleinsmithClojure CampSam UmbachClojure CampSean CorfieldClojure CampSiyoung ByunSciclojTim SchaferClojure CampTimothy PratleyHummi\n\nsource: src/civitas/authors.clj"
  },
  {
    "objectID": "core/async/flow/example/before_his_wings_melted.html",
    "href": "core/async/flow/example/before_his_wings_melted.html",
    "title": "What He Saw Before His Wings Melted",
    "section": "",
    "text": "Long before he flew too high, before the wax gave way and the world remembered only his fall, Icarus flew low. They often leave out this part of his misadventures, when curiosity, not hubris, guided his wings. He flew not to ascend to Olympus, but rather to get a good view of the lesser known Asynctopolis.\nA city pulsing with signals, stitched together by invisible threads. From above, its patterns unfolded like a diagram. Flows of information, agents in silent collaboration, each unaware of the others, yet perfectly aligned.\nThis is what he saw."
  },
  {
    "objectID": "core/async/flow/example/before_his_wings_melted.html#asynctopolis-from-the-clouds",
    "href": "core/async/flow/example/before_his_wings_melted.html#asynctopolis-from-the-clouds",
    "title": "What He Saw Before His Wings Melted",
    "section": "Asynctopolis from the Clouds",
    "text": "Asynctopolis from the Clouds\n\n(def asynctopolis (flow/create-flow asynctopolis/config))\n\n\n(show/flow-svg asynctopolis nil {:show-chans   false\n                                 :with-content false})\n\nTallystrixChrononClaxxusRandomius\nHe circled the skyline. He watched the channels breathe. And slowly, he spiraled down, drawn not by ambition, but fascination‚Äî closer to each process, each transformation, each role in the great asynchronous allegiance.\nAs he flew lower he saw that processes are connected via channels.\n\n(show/flow-svg asynctopolis nil {:chans-as-ports true\n                                 :with-content   false})\n\nTallystrixstatpokealertChrononoutClaxxusinRandomiusout\nAre channels attached to a process, or are they part of it? You can choose to visualize them as distinct connectors, or as embedded roles within each process. Both perspectives reveal useful insights.\n\n(show/flow-svg asynctopolis nil {:chans-as-ports false\n                                 :with-content   false})\n\nTallystrixstatpokealertChrononoutClaxxusinRandomiusout\nWanting to see more, Icarus swooped even lower to survey the processes.\n\n(show/proc-table asynctopolis)\n\n\n\n\n\n\n\n\n\n\n\n\nprocess\nstart params\nin chans\nout chans\n\n\n\n\nTallystrix\n\n\n\nmin: 1\n\n\nMin value, alert if lower\n\n\n\n\nmax: 10\n\n\nMax value, alert if higher\n\n\n\n\n\nstat: Channel to receive stat values\n\n\npoke: Channel to poke when it is time to report a window of data to the log\n\n\n\n\nalert: Notify of value out of range {:val value, :error :high|:low\n\n\n\n\nChronon\n\n\n\nwait: 3000\n\n\nTime to wait between pokes\n\n\n\n\n\n\n\n\nout: Poke channel, will send true when the alarm goes off\n\n\n\n\nClaxxus\n\n\n\nprefix: Alert:\n\n\nLog message prefix\n\n\n\n\n\nin: Channel to receive messages\n\n\n\n\n\n\n\nRandomius\n\n\n\nmin: 0\n\n\nMin value to generate\n\n\n\n\nmax: 12\n\n\nMax value to generate\n\n\n\n\nwait: 500\n\n\nTime in ms to wait between generating\n\n\n\n\n\n\n\n\nout: Output channel for stats\n\n\n\n\n\n\n\nWith a clearer understanding of the processes, he pondered how these processes are connected.\n\n(show/conn-table asynctopolis)\n\n\n\n\n\n\nsource\ntarget\n\n\n\n\nRandomius_out\nTallystrix_stat\n\n\nChronon_out\nTallystrix_poke\n\n\nTallystrix_alert\nClaxxus_in\n\n\n\n\n\nIn doing so he realized there are also 2 global channels, report and error:\n\n(show/flow-svg asynctopolis nil {:chans-as-ports    false\n                                 :with-content      false\n                                 :show-global-chans true})\n\nTallystrixstatpokealertChrononoutClaxxusinRandomiusoutreporterror\nAny process can put messages on report and error."
  },
  {
    "objectID": "core/async/flow/example/before_his_wings_melted.html#street-level",
    "href": "core/async/flow/example/before_his_wings_melted.html#street-level",
    "title": "What He Saw Before His Wings Melted",
    "section": "Street Level",
    "text": "Street Level\nReaching street level, he called out start! The flow responded, handing him report and error channels in a map.\n\n(def chs (flow/start asynctopolis))\n\n\n\n\n\n\n\nOUT\n\n\n\nRandomius initialing\nTallystrix initializing\nChronon initializing\nClaxxus initializing\n\n\n\nBut still, nothing stirred. So he yelled resume!\n\n(flow/resume asynctopolis)\n\n\ntrue\n\n\n(def report-chan (:report-chan chs))\n\n\n(async/poll! report-chan)\n\n\nnil\n\n\n(flow/inject asynctopolis [:Tallystrix :poke] [true])\n\n\n#object [FutureTask]\n\n\n(flow/inject asynctopolis [:Tallystrix :stat] [\"abc1000\"])\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nRandomius transitioning :clojure.core.async.flow/resume\nTalon, set flight!\n\n\n\n\n#object [FutureTask]\n\n\n(show/flow-svg asynctopolis chs {:chans-as-ports false\n                                 :with-content   false})\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nTallystrix transitioning :clojure.core.async.flow/resume\nTallystrix transforming :stat abc1000\nChronon transitioning :clojure.core.async.flow/resume\nChronon running\nClaxxus transitioning :clojure.core.async.flow/resume\nTallystrix transforming :poke true\nSQUARK: 2\nRandomius transform 2 from :stat to :out\nTallystrix transforming :stat 2\nChronon transforms :alarm true to :out\nTallystrix transforming :poke true\n\n\n\nTallystrixstatpokealertChrononoutClaxxusinRandomiusout\nTallystrix takes only numbers, \"abc1000\" was not acceptable."
  },
  {
    "objectID": "core/async/flow/example/before_his_wings_melted.html#conclusion",
    "href": "core/async/flow/example/before_his_wings_melted.html#conclusion",
    "title": "What He Saw Before His Wings Melted",
    "section": "Conclusion",
    "text": "Conclusion\n\n(flow/stop asynctopolis)\n\n\n\n\n\n\n\nTHREAD OUT\n\n\n\nTallystrix transitioning :clojure.core.async.flow/stop\nRandomius transitioning :clojure.core.async.flow/stop\nTalon, rest!\nClaxxus transitioning :clojure.core.async.flow/stop\nChronon transitioning :clojure.core.async.flow/stop\nChronon rests.\n\n\n\n\ntrue\n\n\n(Thread/sleep 1)\n\n\nnil\n\nIcarus realized that Flow is a library for building concurrent, event-driven systems out of simple, communication-free functions. Processes connect through channels. You define the structure as a directed graph. Flow takes care of orchestration. Flows are data-driven, easy to inspect, reason about and visualize. Then he wondered just how high could he fly?\nHappy flowing, and keep your feathers waxed!\n\nsource: src/core/async/flow/example/before_his_wings_melted.clj"
  },
  {
    "objectID": "games/macros_matter.html",
    "href": "games/macros_matter.html",
    "title": "Macros, Matter, & Malleability",
    "section": "",
    "text": "What if we embedded live UI and JavaScript logic directly into a Clojure namespace? Sounds wild? Let‚Äôs see how.\nClay renders Hiccup views, Scittle executes ClojureScript in the browser, and Reagent enables components as functions. kind/hiccup is how we annotate forms to be rendered as HTML via Clay.\nCheck out this mini-app for manipulating the Civitas logo.\n\n(kind/hiccup\n  [:div\n   '(defonce state (atom {}))\n   '(declare reset explode)\n   [:div#app {:style {:width \"100%\"}}]\n   ['(fn []\n       [:div\n        [:em \"Click and drag the hexagons\"]\n        [:div\n         [:button {:on-click #'reset} \"reset\"]\n         [:button {:style {:color \"red\"} :on-click #'explode} \"explode\"]]])]])\n\n\nFun right?\nNotice that Clay accepts normal hiccup, but further treats forms as code, and function forms as components. We‚Äôll get to the implementations of reset, explode, and the view setup later. But first I want to introduce you to the killer feature for this kind of code; Macros! Not just any macro, but the ultimate macro, sneeze.\n\n(defmacro sneeze\n  \"Generates Hiccup with a quasiquote-like templating syntax,\n  enabling content insertion using unquote (~) and unquote-splicing (~@).\"\n  [& forms]\n  `(kind/hiccup ~(backtick/quote-fn identity forms)))\n\nThis macro sneeze behaves just like quote but respects unquote and unquote-splicing. It also suggests that Clay treat the result as Hiccup, which further means that forms will be treated as Scittle. So it‚Äôs a convenient way to write hiccup that contains code, without quoting, and being able to mix in Clojure values with ~ and ~@.\n\n(sneeze\n  (defn my-component []\n    [:strong ~(str \"Wow, so random \" (rand))])\n  [:div [#'my-component]])\n\n\nThis is weird right, why do we need ~? Well, when we define my-component we are writing symbolic code. This is going to be interpreted in the browser, not in Clojure. We can conveniently insert calculations made in Clojure into our UI code. It‚Äôs like Scittle just inherited macros! That‚Äôs exciting‚Ä¶ in a way JavaScript has inherited macros.\nSpeaking of JavaScript, we need to bring in the MatterJS. MatterJS handles the physics simulation and rendering for our mini-app.\n\n(kind/hiccup\n  [:script {:src \"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js\"}])\n\n\nO.K. so here‚Äôs the code for the hexagons, notice toward the end the use of ~ to reuse Clojure code inside our Scittle code.\n\n(sneeze\n  ;; Set up a MatterJS simulation to render to the `app` div.\n  (def app (js/document.getElementById \"app\"))\n  (def client-width (.-clientWidth app))\n  (def engine (js/Matter.Engine.create (clj-&gt;js {:gravity {:y 0}})))\n  (def world-width 600)\n  (def w2 (/ world-width 2.0))\n  (def render (js/Matter.Render.create (clj-&gt;js {:element app\n                                                 :engine  engine\n                                                 :options {:wireframes false\n                                                           :background \"rgba(0,0,128,0.05)\"\n                                                           :hasBounds  true\n                                                           :width      client-width\n                                                           :height     client-width}})))\n\n  ;; Bounds create a fixed coordinate system, similar to a view-box in SVG.\n  (set! (.. render -bounds -min -x) 0)\n  (set! (.. render -bounds -min -y) 0)\n  (set! (.. render -bounds -max -x) world-width)\n  (set! (.. render -bounds -max -y) world-width)\n  (def mouse (js/Matter.Mouse.create (.-canvas render)))\n  (let [scale (/ world-width client-width)]\n    (js/Matter.Mouse.setScale mouse (clj-&gt;js {:x scale\n                                              :y scale})))\n  (def mouse-constraint (js/Matter.MouseConstraint.create engine (clj-&gt;js {:mouse mouse})))\n  (js/Matter.World.add (.-world engine) mouse-constraint)\n  (js/Matter.Render.run render)\n  (def runner (js/Matter.Runner.create))\n  (js/Matter.Runner.run runner engine)\n\n  ;; Handle when the browser window dimensions change\n  (js/window.addEventListener\n    \"resize\"\n    (fn []\n      (let [w (.-clientWidth app)]\n        (-&gt; render .-options .-width (set! w))\n        (-&gt; render .-options .-height (set! w))\n        (-&gt; render .-canvas .-width (set! w))\n        (-&gt; render .-canvas .-height (set! w))\n        (let [scale (/ world-width w)]\n          (js/Matter.Mouse.setScale mouse (clj-&gt;js {:x scale\n                                                    :y scale})))\n        (js/Matter.Render.setPixelRatio render js/window.devicePixelRatio))))\n\n  ;; Add some walls to keep everything inside the view\n  (defn create-boundaries [width height thickness]\n    (let [options (clj-&gt;js {:isStatic    true\n                            :restitution 0.9\n                            :friction    0.1})\n          x-mid (/ width 2.0)\n          y-mid (/ height 2.0)\n          t2 (/ thickness 2.0)]\n      (for [[x y rw rh] [[(- 0 t2) y-mid thickness height]\n                         [(+ width t2) y-mid thickness height]\n                         [x-mid (- 0 t2) width thickness]\n                         [x-mid (+ height t2) width thickness]]]\n        (js/Matter.Bodies.rectangle x y rw rh options))))\n  (js/Matter.World.add (.-world engine)\n                       (clj-&gt;js (create-boundaries world-width world-width 500)))\n\n  ;; The Civitas logo consists of hexagons\n  (defn make-hexagon [x y radius color]\n    (js/Matter.Bodies.polygon x y 6 radius\n                              (clj-&gt;js {:restitution 0.9\n                                        :friction    0.1\n                                        :render      {:fillStyle color}})))\n  ;; Notice that we can make use of the colors from a different, Clojure namespace\n  (let [hexagons (for [[x y c] ~(mapv conj (geometry/hex 100) db/get-colors)]\n                   (make-hexagon (+ w2 x) (+ w2 y) 50 c))]\n    (js/Matter.World.add (.-world engine) (clj-&gt;js hexagons))\n    (swap! state assoc :hexagons hexagons))\n\n  ;; These functions are attached to the on-click of the buttons\n  (defn reset []\n    (doseq [[hex [x y]] (map vector (:hexagons @state) ~(vec (geometry/hex 100)))]\n      (js/Matter.Body.setAngle hex 0)\n      (js/Matter.Body.setPosition hex (clj-&gt;js {:x (+ w2 x), :y (+ w2 y)}))))\n  (defn explode []\n    (doseq [hex (:hexagons @state)]\n      (js/Matter.Body.setVelocity hex (clj-&gt;js {:x (- (rand 50) 25),\n                                                :y (- (rand 50) 25)})))))\n\n\nI‚Äôll be the first to admit that this is a zany way to write code. But it‚Äôs a lot of fun, powerful, concise, and best of all is there is no setup. Everything is here in this one Clojure namespace. No build steps. I send my namespace to Clay and get a HTML page with Scittle baked in. It blends macros, UI, and JavaScript into a single file. For learning, tinkering, and demos, it‚Äôs a joy.\n\n\n\nHexagons escaping\n\n\n\nsource: src/games/macros_matter.clj"
  },
  {
    "objectID": "clojure/print_object/remove_extraneous.html",
    "href": "clojure/print_object/remove_extraneous.html",
    "title": "Clean object printing by removing extraneous",
    "section": "",
    "text": "The Clojure default for printing objects is noisy. Clojure‚Äôs print-method for Object delegates to clojure.core/print-object\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (#'clojure.core/print-object x w))\n\n\n#object [MultiFn]\n\n\n(Object.)\n\n\n#object [Object]\n\nThe syntax is #object[CLASS-NAME HASH toString())] and as you can see, the toString of an Object is CLASS-NAME@HASH. For most objects this becomes quite a long string.\n\n(async/chan)\n\n\n#object [ManyToManyChannel]\n\n\n\n\nObjection!\n\n\nFunctions are printed as objects\n\n(fn [x] x)\n\n\n#fn [fn]\n\nIt‚Äôs quite easy to miss the fact that it is a function as we are looking for a tiny little fn in a sea of text. If, like me, you are fond of the odd lambda calculus excursion, things get even more hectic.\n\n((fn [x] (fn [v] ((x x) v))) (fn [y] y))\n\n\n#fn [fn$fn]\n\nYikes! what an eyesore. This is not an academic issue specific to lambda calculus. Any function created from inside a function is helpfully identifiable through the fn$fn nesting. We create these quite regularly, and they are often printed in stack traces. I‚Äôm sure you have seen them when you map an inline function across a seq, and there is a bug in the anonymous function.\n\n(defn caesar-cipher [s]\n  (mapv (fn add2 [x] (+ 2 x)) s))\n\n\n(try (caesar-cipher \"hello world\")\n     (catch Exception ex\n       (vec (take 4 (.getStackTrace ex)))))\n\n\n[[clojure.lang.Numbers add \"Numbers.java\" 155]\n [clojure.lang.Numbers add \"Numbers.java\" 3747]\n [clojure.print_object.remove_extraneous$caesar_cipher$add2__72938 invoke \"NO_SOURCE_FILE\" 50]\n [clojure.core$mapv$fn__8569 invoke \"core.clj\" 7059]]\n\nSee that part caesar_cipher$add2? That is very useful information. It tells us that the exception was inside add2, which is inside caesar-cipher. The stack trace doesn‚Äôt print functions as objects, but it illustrates that the thing that we care about is that they are a function, what their name is, and whether they were created from inside another function.\nLet‚Äôs return to printing a function as an object. An easy improvement is to demunge from Java names to Clojure names. Demunging converts _ to - and $ to /, and munged characters like + which is PLUS in Java.\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(class-name ((fn [] (fn [y] y))))\n\n\n\"clojure.print-object.remove-extraneous/eval72944/fn--72945/fn--72946\"\n\nNext, we don‚Äôt need the eval identities.\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(remove-extraneous (class-name ((fn [] (fn [y] y)))))\n\n\n\"clojure.print-object.remove-extraneous/fn/fn\"\n\nMuch nicer. I can actually read that! I‚Äôm not particularly fond of the long namespace shown as the name is either defined in this namespace, referred, or part of clojure.core. The multiple slashes form invalid symbols which annoy me; I prefer using / only for namespace/name separation and $ as the name level delimiter: my.namespace/my$nested$name.\n\n(defn format-class-name ^String [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str (str/join \"$\" names))\n      (-&gt; s (str/split #\"\\.\") (last)))))\n\n\n(format-class-name (remove-extraneous (class-name ((fn [] (fn [y] y))))))\n\n\n\"fn$fn\"\n\nSo short, so sweet. If it‚Äôs a function, why call it an object?\n\n(defn object-str ^String [x]\n  (str (if (fn? x) \"#fn\" \"#object\")\n       \" [\" (format-class-name (class-name x)) \"]\"))\n\n\n(object-str ((fn [] (fn [y] y))))\n\n\n\"#fn [fn$fn]\"\n\n\n(object-str (async/chan))\n\n\n\"#object [ManyToManyChannel]\"\n\nThis is really all I care to know about when printing objects and functions, and it matters inside notebooks, where we want to print things, eval things that return objects and functions, and datafy complex objects that contain other objects. To print things without knowing if they are objects, functions, or data, we can extend Clojure‚Äôs print-method.\n\n(defmethod print-method Object [x ^Writer w]\n  (.write w (object-str x)))\n\n\n#object [MultiFn]\n\n\n((fn [] (fn [y] y)))\n\n\n#fn [fn$fn]\n\n\n(async/chan)\n\n\n#object [ManyToManyChannel]\n\nYou can require this namespace from other notebooks to turn on this nice, concise mode of object printing.\nHappy notebooking!\n\nsource: src/clojure/print_object/remove_extraneous.clj"
  },
  {
    "objectID": "clojure/tree_seq/depth_first_search.html",
    "href": "clojure/tree_seq/depth_first_search.html",
    "title": "Depth-first search in Clojure (tree-seq)",
    "section": "",
    "text": "eight queens on a chessboard\n\n\nA classic puzzle involves placing eight queens on a chessboard so that no two are attacking each other.\nToday, we search out such arrangements, in Clojure.\n\nSince no solution has two queens on the same rank, a nice way to represent the board with data is as a vector of numbers, each element of the vector a column index for the queen on that rank.\nFor example, the vector [0 2] would be a board with two queens, one in the corner and another a knight‚Äôs move away.\n\n(def board [0 2])\n\nWe can visualize boards by converting these vectors into so-called FEN strings, which can be converted into images by a web service provided by the caring strangers at chessboardimage.com.\nFirst, we obtain the elements of the FEN string as a sequence.\n\n(for [i board] (str i \"q\" (- 7 i)))\n\n\n(\"0q7\" \"2q5\")\n\nFEN strings do not allow zeros (I do not make the rules).\n\n(for [i board] (.replace (str i \"q\" (- 7 i)) \"0\" \"\"))\n\n\n(\"q7\" \"2q5\")\n\nEach rank is delimited with a slash.\n\n(-&gt;&gt; (for [i board] (.replace (str i \"q\" (- 7 i)) \"0\" \"\"))\n     (clojure.string/join \"/\"))\n\n\n\"q7/2q5\"\n\nThat goes straight into the chessboardimage.com URL\n\n(-&gt;&gt; (for [i board] (.replace (str i \"q\" (- 7 i)) \"0\" \"\"))\n     (clojure.string/join \"/\")\n     (format \"https://chessboardimage.com/%s.png\"))\n\n\n\"https://chessboardimage.com/q7/2q5.png\"\n\n\n\n\ntwo queens on a chessboard\n\n\nThat is the body of a function that converts a board into an image\n\n(defn board-&gt;image\n  [board]\n  (-&gt;&gt; (for [i board] (.replace (str i \"q\" (- 7 i)) \"0\" \"\"))\n       (clojure.string/join \"/\")\n       (format \"https://chessboardimage.com/%s.png\")))\n\n\nTo solve the puzzle, we build a tree of candidate solution boards, the children of each node being boards with a new queen added on the next rank to each square not under attack.\nTo find the squares under attack, we begin by computing the board‚Äôs ranks.\n\n(map-indexed vector board)\n\n\n([0 0] [1 2])\n\nEach queen attacks up to three squares on the next rank, so for each slope m in -1, 0, 1 and each queen‚Äôs rank and index, we produce three indexes under attack (y=mx+b).\n\n(for [m [-1 0 1]\n      [rank i] (map-indexed vector board)]\n  (+ i (* m (- (count board) rank))))\n\n\n(-2 1 0 2 2 3)\n\nTo compute the candidate squares, we take the set of valid indexes and remove those under attack.\n\n(-&gt;&gt; (for [m [-1 0 1]\n           [rank i] (map-indexed vector board)]\n       (+ i (* m (- (count board) rank))))\n     (apply disj (set (range 8))))\n\n\n#{7 4 6 5}\n\nFrom those we produce a sequence of child boards.\n\n(-&gt;&gt; (for [m [-1 0 1]\n           [rank i] (map-indexed vector board)]\n       (+ i (* m (- (count board) rank))))\n     (apply disj (set (range 8)))\n     (map #(conj board %)))\n\n\n([0 2 7] [0 2 4] [0 2 6] [0 2 5])\n\nThat is the body of a function that takes a board, and produces child boards in the tree of candidate solutions.\n\n(defn board-&gt;children\n  [board]\n  (-&gt;&gt; (for [m [-1 0 1]\n             [rank i] (map-indexed vector board)]\n         (+ i (* m (- (count board) rank))))\n       (apply disj (set (range 8)))\n       (map #(conj board %))))\n\n\nWe can enumerate all candidate boards with Clojure‚Äôs tree-seq; a function of three arguments, the first is a predicate that is true for nodes with children.\nIn our case, we keep adding queens as long as a board has fewer than eight queens.\n\n(def boards (tree-seq #(&lt; (count %) 8) ... ...))\n\nThe second argument to tree-seq is a function that given a node, produces a sequence of children.\nWe just wrote that function (board-&gt;children).\n\n(def boards (tree-seq #(&lt; (count %) 8) board-&gt;children ...))\n\nThe third argument to tree-seq is the root of the tree, an empty board [] will do.\n\n(def boards (tree-seq #(&lt; (count %) 8) board-&gt;children []))\n\nThe solutions to the puzzle are those boards with 8 queens on them.\n\n(def solutions (filter #(= (count %) 8) boards))\n\nOf which, there are this many‚Ä¶\n\n(count solutions)\n\n\n92\n\nThe forty-second such solution\n\n(nth solutions 42)\n\n\n[3 0 4 7 1 6 2 5]\n\nAs an image\n\n(board-&gt;image (nth solutions 42))\n\n\n\"https://chessboardimage.com/3q4/q7/4q3/7q/1q6/6q1/2q5/5q2.png\"\n\n\n\n\neight queens on a chessboard\n\n\nüôá\n\nsource: src/clojure/tree_seq/depth_first_search.clj"
  },
  {
    "objectID": "internationalization/transliteration.html",
    "href": "internationalization/transliteration.html",
    "title": "About Transliteration",
    "section": "",
    "text": "Transliteration is about systematically converting the way in which text encodes language (or information) from one writing system (or convention or format) to another.\nWe most commonly think of this for human languages, when converting the sounds spoken in a language from one writing system to another (ex: Chinese language sounds written as ideographs into English language sounds written in the Latin script).\nThe idea of transliteration can be thought of more generically for computers that need to transform text or even file formats.\n\n(def translit-map\n  \"This map defines a transliteration scheme for transforming text, in this case,\n  from Latin script character sequences (of English words) into emojis.\n\n  We define our transformation mappings in a map. In this way, it looks a lot like an\n  input to the Clojure `replace` function. This map will be used as an input for the prefix tree\n  (a.k.a. trie) data struture used to convert.\"\n  {\"happy\" \"üôÇ\"\n   \"happier\" \"üòÄ\"\n   \"happiest\" \"üòÑ\"})\n\n\n(def translit-trie\n  \"Create the prefix tree (a.k.a. trie) data structure based on our transliteration mappings\n  map that defines our transliteration.\"\n  (fmt/make-trie translit-map))\n\nA prefix tree is also called a trie. A prefix tree is a way to store a collection of sequences (ex: strings) efficiently when there is a lot of overlapping prefixes among the strings.\nA dictionary for an alphabetic language is a good example of when a prefix tree is efficient in space. Imagine all of the words in a single page of the dictionary. It could look like ‚Äúcat‚Äù, ‚Äúcatamaran‚Äù, ‚Äúcatamount‚Äù, ‚Äúcategory‚Äù, ‚Äúcaternary‚Äù, etc. It could instead be stored as:\nc - a - t *\n           a - m\n                  a - r - a - n *\n                  o - u - n - t *\n           e\n              g - o - r - y *\n              r - n - a - r - y *\nWhy would we use a prefix tree? Even if the source text patterns in the replacement rules are overlapping, we could perform replacement without a tree if we order the replacement rules by the source text pattern, such that a pattern that contains another pattern is applied earlier. However, to perform this ordering in a globally scalable way would effectively require constructing a prefix tree. Furthermore, a map of rules better models the notion of rules being independent data that are not complected with other rules. Also, as the number of rules increases, there may be performance benefits in terms of lookup in a prefix tree versus attempting to apply all rules in the ruleset sequentially.\nLet‚Äôs introspect into our prefix tree. Let‚Äôs see which input strings have a\n\n(fmt/in-trie? translit-trie \"hap\")\n\n\nfalse\n\n\n(fmt/in-trie? translit-trie \"happy\")\n\n\ntrue\n\n\n(fmt/in-trie? translit-trie \"happier\")\n\n\ntrue\n\n\n(fmt/in-trie? translit-trie \"happiest\")\n\n\ntrue\n\n\n(fmt/in-trie? translit-trie \"happiest!\")\n\n\nfalse\n\n\n(def s \"Hello, world! Happiness is not being happiest or happier than the rest, but instead just being happy.\")\n\n\n(defn convert\n  \"Use our translit-trie to convert the input string into the output string\"\n  [s]\n  (-&gt;&gt; (fmt/str-&gt;elems translit-trie s)\n       (apply str)))\n\n\n(def converted\n  \"Create the converted string according to our transliteration rules.\"\n  (convert s))\n\n\nconverted\n\n\n\"Hello, world! Happiness is not being üòÑ or üòÄ than the rest, but instead just being üôÇ.\"\n\nIt‚Äôs worth noting that a prefix tree, when used to do transliteration conversions, is effectively the finite state machine (FSM) needed to parse and transform.\nFor next time: What if we implicitly did that same conversion by constructing a regular expression (regex) that can match on the input patterns. Could that be equally fast, or faster than our naive Clojure implementation? A regex might work like so:\nlet text = \"this is a test\";\nconst replacementMap = { 'th': 'X', 't': 'Y' };\n\nlet result = text.replace(/th|t/g, (match) =&gt; {\n                                               return replacementMap[match];\n                                               });\n\nconsole.log(result);\n\nsource: src/internationalization/transliteration.clj"
  },
  {
    "objectID": "math/stats/quantquestions/what_are_the_odds/five_pirates_treasure.html",
    "href": "math/stats/quantquestions/what_are_the_odds/five_pirates_treasure.html",
    "title": "Five Pirates Treasure Splitting",
    "section": "",
    "text": "Welcome back code champs, number ninjas, and data divers to the second episode of ‚ÄúWhat are the Odds?‚Äù where we answer life‚Äôs important questions.\n\nI was out treasure hunting with four friends the other day, and we found 100 gold coins. To split the booty, I came up with a genius plan. We take turns proposing how to divide the gold, and if half the crew agrees, we go with it. But if not I get nothing and the next person makes a proposal and so on. To my surprise, the others loved the idea! ‚ÄúA democracy of pirates!‚Äù said one. ‚ÄúA fair and logical system!‚Äù said another. Even our parrot nodded in approval. Can you guess how many coins I walked away with?\n\n(def pirates\n  [\"Green Boots\" \"Red Rackham\" \"Blue Thunder\" \"Black Beard\" \"Tim\"])\n\nWith only one pirate, they get all the booty\n\nGreen Boots: 100\n\nWith 2 pirates, whoever proposes the split gets all the booty\n\nRed Rackham 100\nGreen Boots 0\n\nWith 3 pirates, the pirate who would miss out in the next round is incentivised by 1 coin\n\nBlue Thunder 99\nRed Rackham 0\nGreen Boots 1\n\nWith 4 pirates, 1 vote needed, the pirate who would miss out is incentivised by 1 coin\n\nBlack Beard 99\nBlue Thunder 0\nRed Rackham 1\nGreen Boots 0\n\nWith 5 pirates, 2 votes needed, the 2 pirates who would miss out in the next round get a coin each\n\nTim 98\nBlack Beard 0\nBlue Thunder 1\nRed Rackham 0\nGreen Boots 1\n\nProbably you can spot a pattern emerging here‚Ä¶\n\n(defn split [coins pirates]\n  (let [n (count pirates)]\n    (-&gt; (mapv vector\n              (reverse pirates)\n              (cycle (if (odd? n) [1 0] [0 1])))\n        (assoc-in [0 1] (- coins (/ (if (odd? n) (dec n) n) 2))))))\n\n\n(split 100 pirates)\n\n\n[[\"Tim\" 98]\n [\"Black Beard\" 0]\n [\"Blue Thunder\" 1]\n [\"Red Rackham\" 0]\n [\"Green Boots\" 1]]\n\n\n^:kind/table\n(split 100 pirates)\n\n\n\n\n\n\nTim\n98\n\n\nBlack Beard\n0\n\n\nBlue Thunder\n1\n\n\nRed Rackham\n0\n\n\nGreen Boots\n1\n\n\n\n\n\n\n\n\nScallywag Pirate\n\n\nWell, it got me thinking, what if sharing your ideas was as easy as tricking treasure hunters? No sword fights. No mutiny. Just a fork, some code, a few comments, and a pull request. Let‚Äôs try it out. First I fork ClojureCivitas, Open the project, add a namespace, write some code, add some comments. Commit. Push. Pull request. Once it is merged, it is automatically published to the website. Doesn‚Äôt that look nice? I can even track how many people are reading my idea in these public analytics. If I want a quick preview, I use Clay to render the code and results to HTML. I hope you have an idea to share with me, Why not start a namespace and publish it this way?\nUntil next time, may your treasure split be fair and your adventures interesting.\n\nsource: src/math/stats/quantquestions/what_are_the_odds/five_pirates_treasure.clj"
  },
  {
    "objectID": "math/stats/central_limit_theorem_convergence.html",
    "href": "math/stats/central_limit_theorem_convergence.html",
    "title": "Convergence of Random Events",
    "section": "",
    "text": "Life is full of random events.\nWe learn that multiple coin flips are ‚Äúindependent events‚Äù ‚Äì no matter whether the past flip was heads or tails, the next flip is 50/50. (So why do they show the last few results at the routlette table? Hint: Don‚Äôt play routlette.) We learn that about half of babies are male and half female, so chances are 50/50 that your new little sibling will be a boy or a girl.\nI found the answer to ‚ÄúOf my 8 children, what are the chances that 4 are girls and 4 are boys?‚Äù counterintuitive. The central limit theorem is crucial to intuition around this question.\nWhen I initially encountered the Monte Hall problem, the correct answer wasn‚Äôt obvious or intuitive, but the mathemetical explanation is surprisingly understandable. We‚Äôll try here to make the central limit theorem more understandable as well.\nStart with a single random event ‚Äì value drawn from [0.0, 1.0)\n\n(rand)\n\n\n0.2872408619310026\n\nOne way to combine random events is to take the average:\n\n(defn avg [nums]\n  (/ (reduce + nums) (count nums)))\n\n\n(avg [0.0 1.0])\n\n\n0.5\n\nLet‚Äôs try taking the average of several events together:\n\n(avg [(rand) (rand)])\n\n\n0.4701271471492828\n\n\n(avg [(rand) (rand) (rand)])\n\n\n0.4658798179185167\n\nThis is getting repetitive. We can make the computer repeat for us:\n\n(avg (repeatedly 3 rand))\n\n\n0.3422771633447592\n\nThe more events that you average, the closer the result comes to 0.5:\n\n(avg (repeatedly 30 rand))\n\n\n0.528832376542981\n\n\n(avg (repeatedly 300 rand))\n\n\n0.5057514379652794\n\nLet‚Äôs try taking several events together:\n\n(defn event []\n  (rand))\n\n\n(event)\n\n\n0.9769021575568072\n\n\n(defn combined-event [number-of-events]\n  (avg (repeatedly number-of-events event)))\n\n\n(combined-event 1)\n\n\n0.4205551592418304\n\n\n(combined-event 2)\n\n\n0.5498003605705508\n\n\n(combined-event 5)\n\n\n0.4974256041814232\n\nLet‚Äôs look at a series of multiple of these combined event\n\n(repeatedly 5 #(combined-event 2))\n\n\n(0.7818662768036032\n 0.7177121581698209\n 0.25403348159267425\n 0.7558454699903696\n 0.48397295278054164)\n\n\n(repeatedly 5 #(combined-event 5))\n\n\n(0.4700890406593171\n 0.5014263809937952\n 0.6415157212840854\n 0.4634187099241277\n 0.4911997485513634)\n\n\n(repeatedly 5 #(combined-event 10))\n\n\n(0.5597506073970455\n 0.533544920087498\n 0.32297140093625176\n 0.4460530979760776\n 0.4653834004320899)\n\nAs we combine a larger number of events, the values cluster more closely to the middle of the original distribution.\nAnd regardless of the shape of the original event distribution, the result of combining more and more events will approach the normal distribution ‚Äì it‚Äôs a unique function toward which these combinations always converge.\nThis is true for both continuous variables (like (rand)) or discrete variables (like dice (rand-nth [1 2 3 4 5 6])), and it‚Äôs true even for oddly shaped distributions. When you combine enough of them, they take on the character of the bell-shaped curve.\nLearn More at 3Blue1Brown - But what is the Central Limit Theorem?\n\nsource: src/math/stats/central_limit_theorem_convergence.clj"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nDepth-first search in Clojure (tree-seq)\n\n\nStep-by-step development of a depth-first search, using tree-seq, to solve a classic puzzle.\n\n\n\n\n\nAug 11, 2025\n\n\nHarold\n\n\n\n\n\n\n\n\n\n\n\n\nI‚Äôll take a side of REPL with that\n\n\nSelective interaction with a persistent REPL sidebar inside your Clay documents\n\n\n\n\n\nAug 5, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nMacroexpand 2025 by Scicloj\n\n\nMacroexpand 2025: A pair of conferences by Scicloj: Macroexpand-Noj and Macroexpand-Deep. Call for proposals is open!\n\n\n\n\n\nAug 4, 2025\n\n\nDaniel Slutsky, Siyoung Byun\n\n\n\n\n\n\n\n\n\n\n\n\nMacros, Matter, & Malleability\n\n\nHow to add UI components and ClojureScript to your Clojure namespace\n\n\n\n\n\nAug 1, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nPresenting your namespace\n\n\nDid you know your blog post can be a slideshow?\n\n\n\n\n\nJul 30, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCollections as grids with borders\n\n\n\n\n\n\n\n\nJul 20, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating 1-D Convection in Clojure ‚Äî From Equations to Arrays\n\n\nA quick exploration to simulate a classic fluid dynamics equation in Clojure using Java arrays.\n\n\n\n\n\nJul 15, 2025\n\n\nSiyoung Byun\n\n\n\n\n\n\n\n\n\n\n\n\nBeginning to build a browser game\n\n\n\n\n\n\n\n\nJul 9, 2025\n\n\nMatt Kleinsmith\n\n\n\n\n\n\n\n\n\n\n\n\nConvergence to Normal Distribution, independent of original distribution\n\n\n\n\n\n\n\n\nJun 27, 2025\n\n\nSam Umbach\n\n\n\n\n\n\n\n\n\n\n\n\nConvergence of Random Events\n\n\n\n\n\n\n\n\nJun 25, 2025\n\n\nSam Umbach, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nTransforming Datasets to Stack Charts\n\n\nA couple of quick ideas about visualizing data, especially with regard to comparison.\n\n\n\n\n\nJun 24, 2025\n\n\nHarold\n\n\n\n\n\n\n\n\n\n\n\n\nMore on transliteration\n\n\n\n\n\n\n\n\nJun 22, 2025\n\n\nElango Cheran\n\n\n\n\n\n\n\n\n\n\n\n\nFive Pirates Treasure Splitting\n\n\nSharing ideas and pirate treasure with ClojureCivitas.\n\n\n\n\n\nJun 18, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nAbout Transliteration\n\n\n\n\n\n\n\n\nJun 8, 2025\n\n\nElango Cheran\n\n\n\n\n\n\n\n\n\n\n\n\nThe Hidden Geometry of Dice\n\n\nA simple probability puzzle turns into a journey through triangular numbers and tessellated hexagons.\n\n\n\n\n\nJun 5, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if‚Ä¶ we were taught transducers first?\n\n\n\n\n\n\n\n\nMay 31, 2025\n\n\nSean Corfield\n\n\n\n\n\n\n\n\n\n\n\n\nThe Hallway Track: SciNoj Light #1 Data Analysis Stories\n\n\n\n\n\n\n\n\nMay 28, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nFactorization of Eratosthenes\n\n\n\n\n\n\n\n\nMay 28, 2025\n\n\nTim Schafer\n\n\n\n\n\n\n\n\n\n\n\n\nClean object printing by removing extraneous\n\n\n\n\n\n\n\n\nMay 26, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nThe Z-Combinator Gambit\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nChris Houser, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nNoj Reload Executable\n\n\n\n\n\n\n\n\nMay 6, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nWhat He Saw Before His Wings Melted\n\n\n\n\n\n\n\n\nMay 1, 2025\n\n\nDaniel Slutsky, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nStats and Signals in the Flow of Asynctopolis\n\n\n\n\n\n\n\n\nMay 1, 2025\n\n\nAlex Miller, Timothy Pratley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "conferences/scinoj_light_1/notes/hallway_track.html",
    "href": "conferences/scinoj_light_1/notes/hallway_track.html",
    "title": "The Hallway Track: SciNoj Light #1 Data Analysis Stories",
    "section": "",
    "text": "The SciNoj Light #1 Conference brought together Clojure enthusiasts, data scientists, and researchers for an engaging exploration of data analysis stories. The event fostered a collaborative, informal atmosphere where participants exchanged ideas across disciplines from cognitive psychology to urban planning.\nIf you missed it, you can view the talks on the conference sessions playlist. The conference website has detailed information about the talks and speakers. Links to the notebook code presented are on the sessions page, and available as data in the info.edn file.\nThe concluding talk on lane reductions stood out as my favorite because it blended data-driven insights with relatable, human-interest storytelling. As a cyclist, I immediately connected with how lane reductions and protected bike lanes are impactful to my safety. The talk‚Äôs compelling visuals, grounded in real case studies, made the story very tangible. Heather‚Äôs personal perspective as a car-free parent added emotional weight. She illustrated how community advocacy and smart urban design saves lives, and makes more livable spaces. The mix of passion, rigor, and optimism left me inspired; data analysis can drive tangible, life-improving change.\n\n\n\nBike lane improvements reduce crashes\n\n\nA major focus of the conference was the development of Clojure‚Äôs data science Noj toolkit. This suite of libraries demonstrated how Clojure combines functional programming elegance with practical performance. Speakers highlighted Noj‚Äôs interoperability with Python and Java ecosystems while emphasizing its advantages for reproducible and maintainable workflows. The community‚Äôs collaborative energy was evident throughout.\n\n\n\nNoj core components\n\n\nArtificial intelligence emerged as a recurring theme, with several talks exploring hybrid approaches to enhance reliability. One discussion centered on Retrieval-Augmented Generation (RAG) systems, where combining large language models with Clojure‚Äôs logic programming capabilities could improve accuracy in structured domains like government Q&A. Another session delved into probabilistic programming with Inferme, illustrating Bayesian methods for modeling uncertainty. These technical deep dives were balanced by ethical considerations and reflections on technology‚Äôs societal implications.\nScientific applications showcased Clojure‚Äôs versatility. One talk explored simulating fluid dynamics. Another focused on forecasting tropical cyclone paths using physics-informed machine learning. Cognitive science experiments were also featured, using collaborative games and puzzles to study human planning behavior, and brain wave monitors. The conference also highlighted social impact work, such as data-driven advocacy for safer street designs, proving that technical tools can drive urban change.\nWhat stood out to me was how effectively the SciCloj community uses Clojure notebooks for collaborative work. Presenters shared their research through executable notebooks that cleanly combined code, visualizations and explanations. It‚Äôs a practical pattern broadly applicable for sharing ideas and knowledge.\nThroughout the event, a sense of optimism prevailed about Clojure‚Äôs untapped potential. While acknowledging gaps in ML tooling compared to Python, speakers demonstrated that Clojure‚Äôs functional rigor and JVM scalability make it a good fit for data science. Attendee discussions envisioned collaborating further on logic-guided AI and semantic web ontologies. There was a recurring theme of bridging the gap between academic theory and real-world engineering. SciNoj Light ultimately painted a picture of Clojure not just as a language, but as a catalyst for interdisciplinary innovation.\n\nYou can have the cake of Clojure‚Äôs immutable persistent data structures and eat it too;\nGet your answers fast and make your customers happy.\n‚Äî Harold\n\nA big thank you to the organizers! The event was an overwhelming success with high quality presentations and valuable discussions. I‚Äôm looking forward to the next SciNoj, it‚Äôs a rare and valuable blend of science, technology, community and code.\nBelow are my notes about the sessions and conversations from the conference.\n\nPre-conference interview\nEngaging to have a taste of what‚Äôs to come, got me really enthusiastic about the coming event. Game as a Research Tool: ‚ÄúTik Tik‚Äù is a controlled environment for studying human cognition and collaboration. Combines cognitive psychology, game design, and data analysis.\n\n\n1.1: Hello\nCommunity-driven event. Informal, interactive, and welcoming. Focus on Clojure for data workflows. Tools and libraries have matured, and the conference shares these advancements. Zulip is the main forum, attendees are encouraged to engage via structured topic threads. The macroexpand session invites ideas for expanding Clojure adoption in various fields. Hosts encourage questions, jokes, and relaxed participation. Sets the tone for an inclusive, engaging, and slightly nerdy gathering of Clojure enthusiasts.\n\n\n1.2: An intro to the Noj toolkit\nNoj is a Clojure-based data science toolkit integrating libraries for data analysis, visualization, and machine learning. Designed for functional, efficient data processing with compatibility across libraries (e.g., Tablecloth, FastMath, Metamorph). Inspired by tools like R‚Äôs dplyr/ggplot and Python‚Äôs pandas/Plotly, but with a Clojure-centric approach. Tablecloth for tabular data manipulation (similar to pandas/dplyr). TablePlot grammar-of-graphics-inspired visualization (like ggplot). FastMath stats and statistical modeling (logistic regression and more). Metamorph for machine learning workflows. Worked example of predicting success in Kickstarter projects. Data loading/cleaning, exploratory analysis (grouping, aggregation, bar plots), predictive modeling, evaluation (train/test split, accuracy checks). Functional & Immutable, Noj leverages Clojure‚Äôs strengths. Efficient columnar storage with zero-copy operations.\n\n\n1.3: Probability and statistics - Daniel Slutsky\nGenerating pseudo-random numbers using seeds for reproducibility in research. Simulating dice rolls to explore distributions. Used histograms and scatter plots to visualize distributions. Computed mean, standard deviation and z-scores for comparison. Bayesian inference for probabilistic models with parameters. Conditioned models on observed data to infer posterior distributions. Highlighted constraints and efficient sampling algorithms. Avoid lazy sequences for large simulations; consider dtype-next or transducers. Visualization matters, histograms and scatter plots reveal patterns. Probabilistic programming models uncertainty and updates beliefs with data. Balanced foundational stats with advanced topics, emphasizing Clojure‚Äôs tools for data science.\n\n\n1.4: Customer churn analysis, LLMs & logic programming - Siavash Mohammady\nCustomers leaving significantly impacts revenue. Exploring factors like course format, teacher experience, and registration patterns. High churn in early months, newer teachers correlated with higher churn. User prompt ‚Üí NLP entity recognition ‚Üí LLM generates high-level DSL ‚Üí Clara rule engine translates to low-level DSL ‚Üí Execution. Mentorship for new teachers can reduce churn. Pairing LLMs abstract reasoning with logic engines concrete execution optimizes complex data tasks. A forward-looking talk blending data science, AI, and Clojure, emphasizing doing less.\n\n\n1.5: Linear Foundations & Nonlinear Frontiers - Jelena Losic\nLinear systems rely on superposition, the whole is the sum of parts. Vector spaces, linear regression, Fourier analysis. Real-world systems are often nonlinear. Linear methods fail when data lies on curved manifolds or exhibits complex interactions. Techniques like t-SNE, UMAP, and autoencoders handle nonlinearity by preserving structures or learning manifold geometry. Nonlinear systems can be deterministic yet unpredictable. Nonlinear methods unlock richer patterns but sacrifice interpretability and require more data. Dimensionality reduction illustrates the trade-off between simplicity and accuracy. Embeddings leverage linear algebra but rely on nonlinear transformations for deeper semantics.\n\n\n1.6: RAGgedy Ann‚Äôs Big Adventure - Paula Gearon\nVectors represent concepts in multidimensional space. Embeddings convert text into vectors, capturing meaning. Similarity between vectors is measurable. Neural networks process inputs through weighted connections and activation functions. Transformers contextualize words in sentences. Combining LLMs with vector databases to reduce hallucinations. Augmenting queries with retrieved context. LLMs are built from modular math operations. Vector databases enable semantic search. RAG improves accuracy by grounding LLM outputs in verified data.\n\n\n1.7: Parliamentary Questions - RAG Evaluation - Eoin Carney\nCan RAG effectively answer parliamentary style questions using Irish government data? 10k publicly available Irish parliamentary questions and answers. Compared sentence-based chunking with full document retrieval. Tested multiple LLMs for generation and evaluation. Retrieval Matters More Than Prompting. Smaller, precise chunks of 3‚Äì5 sentences improved precision over full document retrieval. Direct answer retrieval outperformed matching questions to answers. Deterministic metrics like word overlap failed to capture nuance. LLM as judge worked better for correctness. Clay notebook visualization helped explore vector embeddings interactively. Government answers should be plain and factual. LLMs are oddly well-suited for that.\n\n\n1.8 - Discussion: RAGs and Structured Knowledge\nShared experiences using Clojure for AI projects. Exploring logic programming as a superset of reasoning techniques and unifying them with embeddings and vector logic. Foundational ontologies and their role in structuring knowledge for AI, particularly in medical domains. The conversation fluidly shifted from technical to philosophical and practical.\n\n\n1.9: Noj Deep Dive - Harold & Daniel Slutsky\nUsing Clojure for functional data science, contrasting it with Python tools like Pandas. The focus is on immutability, performance, and leveraging Clojure‚Äôs strengths for data processing. Tech.ml.dataset for tabular data processing. Columnar storage for efficiency and integrates with other libraries in the ecosystem. Layered Architecture. Hamfisted high-performance, immutable collections optimized for JVM memory/CPU. Dtype-next array random access and lazy, non-caching transformations. Tablecloth high-level tabular data tools built atop these foundations. Challenges and solutions for integrating with Python via libpython-clj and stdlang. Hamfisted and Dtype-next enable Clojure to match Java/Python performance while retaining functional idioms. 20x speedup in lazy sequences. Columnar storage in TMD reduces memory overhead. Libraries like FastMath, MetamorphML, and Tableplot extend the stack. Real-world applications in consulting and open-source collaboration. Frequent shoutouts to contributors and emphasis on community input via Zulip. If you think data science needs software engineering, you‚Äôre right. A blend of technical rigor, community spirit, and practical focus on building scalable, functional data tools.\n\n\n1.10: Brain data in Clojure - Lorelai Lyons\nEthical and Historical Context of Brain-Computer Interfaces. Morally questionable history of neuroscience. Need for ethical considerations in modern BCIs. The goal is to bridge the gap between continuous human thought and discrete computing. Neurons generate electrical signals that can be recorded and digitized. EEG measures brainwave frequencies via electrodes placed on the scalp. EEG data from a motor imagery study. Applied filters to isolate frequency bands. Developing a low-cost binary file system for efficient EEG data storage. Exploring brain-controlled interfaces for creative applications. Consumer EEG devices make brain data collection feasible for programmers. BCIs require collaboration across neuroscience, hardware, and software. Mixed technical depth with ethical reflection.\n\n\n2.1: 1D Viscous Fluid Flow Data Analysis, Burgers‚Äô Equation - Siyoung Byun\nFluid dynamics is complex, involving variables like friction, pressure, and momentum. CFD uses computational methods to simulate fluid behavior, crucial for fields like aerospace, healthcare, and astrophysics. Astrophysics simulations of binary star collisions use CFD. Burgers‚Äô Equation combines nonlinear convection (steepening fluid motion) and viscosity (smoothing/diffusion). Demonstrated via simulations of a shock in a 1D fluid, visualized over time. Used mutable Java arrays for performance. Extending to 2D/3D simulations and incorporate the Navier-Stokes equations for full fluid dynamics. Visualization Matters. Plotting data is critical for interpreting simulations. Siyoung emphasizes the learning process and invites collaboration. Technical but accessible, viscosity effects are explained with analogies. Passion for both astrophysics, fluid dynamics and Clojure shines through. Simulations of white dwarf collisions brought home the realization that star interactions are fluid. Korean ondol floor heating as an analogy for convection.\n\n\n2.2: UK Electricity Demand Time Series Forecasting - Anton Lobach\nThe Taylor dataset contains electricity demand in Wales/England. Extract day of week, minute of day, weekend flag. Ridge regression regularized linear regression to prevent overfitting. Use rolling origin cross-validation. Root Mean Squared Error to measure forecast accuracy. Clojure has expressive, modular workflows with strong data processing capabilities. Seasonality matters. Minute-of-day was the most predictive feature. Ridge regression achieved reasonable accuracy. Split data into train/test sets before exploratory analysis to avoid bias. Use rolling windows for temporal data. The tutorial is available as an interactive notebook.\n\n\n2.3: Tropical cyclone trajectory modelling - K Ram Narayan, Naimish Mani B\nAccurate trajectory forecasting is crucial for disaster preparedness, evacuation planning, and minimizing loss of life and property. Forecasting relies on a mix of satellite data, computer simulations, and aircraft reconnaissance. Using SINDy (Sparse Identification of Nonlinear Dynamics), to extract governing equations from cyclone trajectory data to predict future paths. Global cyclone track dataset. Satellite imagery used to compute wind velocity and shear via optical flow. Incorporates cyclone dynamics to refine SINDy‚Äôs candidate equations. Cyclone movement is driven by steering winds, Coriolis force, beta drift, and interactions with pressure systems. Collect trajectory and satellite data. Construct a candidate library of possible dynamical terms. Use Lasso regression to sparsely select the most relevant terms. Derive interpretable differential equations for forecasting. SINDy achieved a 43.71 km mean absolute error, acceptable in cyclone forecasting. Outperformed by gradient boosting, and random forest in single-step prediction but excels in full trajectory forecasting. Bay of Bengal cyclones curve unpredictably due to land effects. Bridges meteorology, physics, and machine learning for cyclone prediction.\n\n\n2.4: Studying planning with a novel video game - Cvetomir Dimov\nPlanning is a fundamental cognitive ability used in everyday tasks. ‚ÄúTik Tik‚Äù game is designed to study planning. Players control a fireball and an ice cube that must collaborate to navigate obstacles and reach targets. A custom program was developed to generate and solve game levels, identifying optimal paths and measuring problem difficulty. Goal is to understand what incentivizes planning. Difficulty influenced by the number of barriers and their intersections. Problem difficulty predictors were the minimum moves needed and the number of possible paths up to the optimal length. Study 1 high dropout rates, large individual differences in planning ability. Study 2 time limits and stricter move limits reduced dropouts and reinforced planning incentives. Tight constraints encourage planning. Problem difficulty can be systematically manipulated for cognitive research. Demonstrations of the game and solver make abstract concepts tangible. Credits multiple software tools, emphasizing a community-driven approach to research.\n\n\n2.5: Building a Data Science Ecosystem in Clojure - Kira Howe\nInspiration from the Tidyverse (R). A cohesive ecosystem with shared design principles on data and composable tools. Standardized data structures and streamline workflows. Fragmented tools create glue code overhead. Immutable data and pure functions enable reproducibility. JVM handles large-scale data efficiently. Engineering culture emphasis on stability and interoperability. Explosive data growth demands scalable, deterministic tools. Noj as a Clojure based ecosystem inspired by Tidyverse but optimized for scalability and engineering. Simplify onboarding through Jupyter support and Clojure in a box. Need for Shiny-like tools for rapid prototyping. Emphasized grassroots community building and learning together. Data quality should be a philosophy, not an afterthought.\n\n\n2.6: Macroexpand-1\nWays to broaden Clojure‚Äôs impact beyond its traditional domains by fostering interdisciplinary collaboration. Need to make Clojure more accessible and visible in fields like data science, education, and specialized industries. Improve tooling, documentation, and community outreach. Developer intuitive libraries, enhancing interoperability with other languages. Lowering barriers for newcomers. Importance of geospatial analysis and modern programming practices. Sustainable community efforts and cross-disciplinary knowledge sharing.\n\n\n2.7: The Impact of Lane Reductions - Heather Moore-Farley\nReducing car lanes, protected bike lanes, and pedestrian crossings decrease traffic injuries and fatalities. California‚Äôs crash data used to visualize collision hotspots to push for safer street redesigns. High injury corridors 6% of streets cause 60% of severe/fatal crashes. Correlated lane reductions, protected bike lanes, and raised bus stops led to fewer crashes over time. Local groups use data to advocate for safer streets. Police reported crash data has missing ages, locations and underreporting driver fault. Heather shares her lived experience as a car-free parent in Oakland, tying data to safety. Design solutions and community action work. Advocating for upcoming redesigns. A compelling mix of data science, urbanism, and grassroots advocacy. Number crunching can drive tangible change."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "About Posts Authors Explorer"
  },
  {
    "objectID": "scicloj/noj/intro/getting-started-noj.html",
    "href": "scicloj/noj/intro/getting-started-noj.html",
    "title": "Noj Reload Executable",
    "section": "",
    "text": "Transcript of Noj Reload Executable\nHello code champs, number ninjas and data divers!\nImagine being able to experiment with Clojure without needing to install tooling, set up editors, or even know about deps.edn Sounds like a dream, right? Well, dream no more‚Äîmeet Noj‚Äôs new Code Reload Executable!\n\n\n\nNoj\n\n\nWe can skip the Clojure tooling and editor setup, but we do need to install the recommended Adoptive Java. Now we download the latest Noj jar from the Scicloj Noj GitHub releases page. Let‚Äôs check the jar is in the Downloads directory, and that we have java installed by executing java -version.\nLaunch Noj using java -jar and the path to the jar file. Pro tip, if you press tab while typing a path, it will autocomplete. Noj is running, it created a directory called notebooks, and it recommends we create a Clojure file there.\nI‚Äôll create my file with Notepad, being careful to create a .clj file rather than a text file. When I saved that file, a browser window opened. Let‚Äôs put them side by side. Every time I save the file, the notebook updates.\nIf I‚Äôm interested in one particular top-level form, I can narrow the output by adding ,, anywhere in the form. And removing it renders the full notebook. And check this out‚Äîcomments are rendered as Markdown. How cool is that? What an easy way to get coding!\nNoj isn‚Äôt just a notebook‚Äîit‚Äôs a fully featured data science environment. It includes interesting datasets that can be queried and the results shown as tables or even better as charts.\nNoj makes experimenting with Clojure easier than ever. No setup headaches, no complicated tooling‚Äîjust pure coding joy.\nUntil next time, Keep on coding"
  },
  {
    "objectID": "scicloj/tableplot/ideas/stacking.html",
    "href": "scicloj/tableplot/ideas/stacking.html",
    "title": "Transforming Datasets to Stack Charts",
    "section": "",
    "text": "With observed data, presumably from two runs of some experiment‚Ä¶\n\n(def ds0\n  (ds/-&gt;dataset \"https://gist.githubusercontent.com/harold/18ba174c6c34e7d1c5d8d0954b48327c/raw\"\n                {:file-type :csv}))\n\n\n(def ds1\n  (ds/-&gt;dataset \"https://gist.githubusercontent.com/harold/008bbcd477bf51b47548d680107a6195/raw\"\n                {:file-type :csv}))\n\nWell, what have we got?\n\nds0\n\n\nhttps://gist.githubusercontent.com/harold/18ba174c6c34e7d1c5d8d0954b48327c/raw [500 1]:\n\n\n\ny\n\n\n\n\n-0.09138541\n\n\n0.73573478\n\n\n0.66637442\n\n\n1.42894310\n\n\n1.17985915\n\n\n2.10245096\n\n\n2.35628501\n\n\n1.65951387\n\n\n2.66932952\n\n\n1.96287689\n\n\n‚Ä¶\n\n\n6.30911743\n\n\n6.65394635\n\n\n5.88407917\n\n\n6.59312352\n\n\n6.32078823\n\n\n5.78220740\n\n\n6.11383638\n\n\n6.62701870\n\n\n6.29688536\n\n\n5.87255145\n\n\n6.34171349\n\n\n\n\nA few hundred numbers‚Ä¶ Hm‚Ä¶\n\nds1\n\n\nhttps://gist.githubusercontent.com/harold/008bbcd477bf51b47548d680107a6195/raw [500 1]:\n\n\n\ny\n\n\n\n\n1.23590349\n\n\n0.97176804\n\n\n1.44779983\n\n\n2.09836076\n\n\n2.39260885\n\n\n2.33861635\n\n\n2.55252144\n\n\n2.75108032\n\n\n3.42274612\n\n\n3.13478376\n\n\n‚Ä¶\n\n\n22.45761328\n\n\n22.35632666\n\n\n21.93285307\n\n\n22.24006990\n\n\n22.51064120\n\n\n22.38858256\n\n\n22.53949283\n\n\n22.57957379\n\n\n22.31971585\n\n\n22.69953383\n\n\n22.23848485\n\n\n\n\nThis neglects the hundreds of thousands of years invested in evolving a visual system‚Ä¶\n\n(-&gt; ds0\n    (plotly/base {:=title \"Run 0\"})\n    (plotly/layer-point {:=y \"y\"}))\n\n\n\n(-&gt; ds1\n    (plotly/base {:=title \"Run 1\"})\n    (plotly/layer-point {:=y \"y\"}))\n\n\nBetter; however, our aim is to compare them‚Ä¶ Which is higher?\n\n(-&gt; (ds/concat (assoc ds0 :v \"Run 0\")\n               (assoc ds1 :v \"Run 1\"))\n    (plotly/base {:=title \"Comparison Between Runs\"})\n    (plotly/layer-point {:=y \"y\"\n                         :=color :v}))\n\n\nNow it‚Äôs up to the viewer to decide whether they like higher numbers or not.\n\nThere are a couple of interesting ideas in that last bit of code:\n\nassoc a constant onto a ds creates a constant column\n:=color takes care of grouping the results and the downstream display\n\nNeat.\n\nsource: src/scicloj/tableplot/ideas/stacking.clj"
  },
  {
    "objectID": "code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "href": "code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "title": "The Z-Combinator Gambit",
    "section": "",
    "text": "Welcome back code champs, number ninjas, and data divers to our first episode of Beating Code Interviews with Stupid Stuff. People often send me emails asking, ‚ÄúHow can I use lambda calculus to impress people?‚Äù Today, we find out.\n\n\n\nProgrammer staring at Z-combinator\n\n\nI have an interview with ZCorp lined up in 5 minutes, and our challenge is to only use anonymous functions. No defn, no loops, and definitely no self-reference. I‚Äôll allow myself the occasional def for brevity, but beyond that, we‚Äôll be running on pure lambda calculus.\n20 minutes later\n\nHey, sorry to keep you waiting. I just got out of a more important meeting. I‚Äôm kind of a big deal here at ZCorp. Why don‚Äôt you tell me a little bit about yourself?\n\nBorn of binary, raised on algorithms, I walk the path of lambda‚Ä¶\n\nRiiiight‚Ä¶ Let‚Äôs just start with the warm-up problem. Show me how you would reverse a list.\n\nAh, the timeless list reversal. Deceptively simple, perilously deep. We must first define our purpose.\n\n(fn [SELF LIST])\n\n\n#fn [fn]\n\n\nWe‚Äôre just writing a function, and it only needs to take a list‚Ä¶\n\nNot just any function, my friend, but one that knows itself. To know yourself is to find your fixed point.\n\n(def REV\n  (fn [SELF LIST]\n    (if (empty? LIST)\n      []\n      (conj (SELF SELF (rest LIST))\n            (first LIST)))))\n\n\n(REV REV [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\nSELF is an input to itself, the logic of reversal.\n\nOk let‚Äôs just move on to the next problem, creating a Fibonacci sequence.\n\nOh no, our definition of reverse is intertwined with recursion. Let‚Äôs factor that out:\nWe need to lift our SELF\n\n(def REV'\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n\n((REV' REV') [1 2 3 4 5])\n\n\n\n\n\n\n\nclass code_interview.beating.with_stupid_stuff.z_combinator_gambit\\(REV_SINGLEQUOTE_\\)fn__76245 cannot be cast to class clojure.lang.IPersistentCollection (code_interview.beating.with_stupid_stuff.z_combinator_gambit\\(REV_SINGLEQUOTE_\\)fn__76245 is in unnamed module of loader clojure.lang.DynamicClassLoader @1b7dff24; clojure.lang.IPersistentCollection is in unnamed module of loader ‚Äòapp‚Äô)\n\n\n\n\n\n                                                     clojure.core/eval    core.clj: 3232\n                                                                   ...                 \ncode-interview.beating.with-stupid-stuff.z-combinator-gambit/eval76248  REPL Input:     \n  code-interview.beating.with-stupid-stuff.z-combinator-gambit/REV'/fn  REPL Input:     \n                                                     clojure.core/conj    core.clj:   84\njava.lang.ClassCastException: class code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_SINGLEQUOTE_$fn__76245 cannot be cast to class clojure.lang.IPersistentCollection (code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_SINGLEQUOTE_$fn__76245 is in unnamed module of loader clojure.lang.DynamicClassLoader @1b7dff24; clojure.lang.IPersistentCollection is in unnamed module of loader 'app')\n\n\n\n\n\nOh, no‚Ä¶ SELF doesn‚Äôt take LIST, it‚Äôs a function that returns a function that operates on LIST, and the argument to SELF is‚Ä¶ SELF. Therefore, we need to give it (SELF SELF).\n\n(def REV''\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj ((SELF SELF) (rest LIST))\n              (first LIST))))))\n\n\n((REV'' REV'') [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nThat‚Äôs a confusing way to write it\n\nQuite right, because it‚Äôs not obvious what (SELF SELF) is. We need to extract it out. What we want is:\n\n(def REV-LOGIC\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n\nBelieve me when I say that is not what I meant‚Ä¶\n\nOh, right. Now SELF = (SELF SELF).\n\nNot what I meant, and also that sounds impossible.\n\nBut identity is the identity of itself:\n\n(identity 1)\n\n\n1\n\n\n((identity identity) 1)\n\n\n1\n\n\nO.K. sure, but that‚Äôs a special case.\n\n\n(((identity identity) (identity identity)) 1)\n\n\n1\n\n\nThis is an identity crisis.\n\nWe just need to find the right conditions for (SELF SELF) = SELF.\n\n(REV-LOGIC REV-LOGIC)\n\n\n#fn [REV-LOGIC$fn]\n\n\nWell, it‚Äôs a function! That much is clear‚Ä¶\n\n\n((REV-LOGIC REV-LOGIC) [1 2 3 4 5])\n\n\n\n\n\n\n\nclass code_interview.beating.with_stupid_stuff.z_combinator_gambit\\(REV_LOGIC\\)fn__76255 cannot be cast to class clojure.lang.IPersistentCollection (code_interview.beating.with_stupid_stuff.z_combinator_gambit\\(REV_LOGIC\\)fn__76255 is in unnamed module of loader clojure.lang.DynamicClassLoader @77b4d2db; clojure.lang.IPersistentCollection is in unnamed module of loader ‚Äòapp‚Äô)\n\n\n\n\n\n                                                        clojure.core/eval    core.clj: 3232\n                                                                      ...                 \n   code-interview.beating.with-stupid-stuff.z-combinator-gambit/eval76266  REPL Input:     \ncode-interview.beating.with-stupid-stuff.z-combinator-gambit/REV-LOGIC/fn  REPL Input:     \n                                                        clojure.core/conj    core.clj:   84\njava.lang.ClassCastException: class code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__76255 cannot be cast to class clojure.lang.IPersistentCollection (code_interview.beating.with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__76255 is in unnamed module of loader clojure.lang.DynamicClassLoader @77b4d2db; clojure.lang.IPersistentCollection is in unnamed module of loader 'app')\n\n\n\n\n\nBut it doesn‚Äôt work, because (REV-LOGIC REV-LOGIC) =/= REV-LOGIC. Let‚Äôs try something easier:\n\n(def FIX\n  (fn [LOGIC]\n    ;; return something like identity where self application does not change it\n    #_FIXED))\n\nFIX takes the logic function, and makes a function such that (FIXED (FIX LOGIC)) = FIXED\n(FIXED FIXED) =&gt; FIXED which means that ((FIX LOGIC) (FIX LOGIC)) = (FIX LOGIC)\n\nRight, that sounds way easier‚Ä¶ shaking head in disbelief\n\nExactly! Because we just reverse it: (FIX F) = ((FIX F) (FIX F))\n\nWhy did you call it FIX?\n\nWell, it was broken before right?\n\nI‚Äôm starting to think that you are the broken one.\n\n\n(def FIX\n  (fn [LOGIC]\n    ((FIX LOGIC) (FIX LOGIC))))\n\nBut FIX can still see itself. We need to parameterize the use of FIXED\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (FIXED FIXED)))\n     (fn [FIXED]\n       (LOGIC (FIXED FIXED))))))\n\nThere, I fixed it.\n\nWhat is fixed?\n\nFIXED is (FIXED FIXED), obviously.\n\nObviously. raises hands in dispair\n\nBecause (FIX F) = ((FIX F) (FIX F)), it was your idea to refactor remember?\n\n(FIX REV-LOGIC)\n\n\n\n\n\n\n\njava.lang.StackOverflowError\n\n\n\n\n\ncode-interview.beating.with-stupid-stuff.z-combinator-gambit/FIX/fn  REPL Input:  (repeats 1,024 times)\njava.lang.StackOverflowError:\n\n\n\n\n\n\nEverything looks to be inside out now.\n\nOh, you are right, we can‚Äôt pass (FIXED FIXED) as an argument because it will be evaluated first. Thanks for the tip.\n\nCan we fix it? slaps self\n\nInstead of calling (FIXED FIXED) we need a function that will create (FIXED FIXED) when it‚Äôs needed, after LOGIC gets called. LOGIC needs to take itself as it‚Äôs argument, so the function we pass to LOGIC should look very much like LOGIC, but of course without any actual logic in it.\n\nThat actually sounds logical.\n\nLOGIC is a function of itself, returning a function that acts on a value:\n(LOGIC (fn SELF [VALUE]\n         ((FIXED FIXED) VALUE)))\n\ndidn‚Äôt you say that (FIXED FIXED) = FIXED?\n\nYes but only after we FIX it. Fixing it requires us to go from FIXED to (FIXED FIXED) remember?\n\nAh sure‚Ä¶\n\nSo while we are fixing logic, let‚Äôs replace (LOGIC (FIXED FIXED)) with our deferring function.\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE))))\n     (fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE)))))))\n\nDid you know this is called continuation passing style?\n\nCSP?\n\nNo, that‚Äôs communicating subprocesses.\n\nThat‚Äôs confusing.\n\nIsn‚Äôt it!? Fortunately, we are about to be unconfused.\n\n(FIX REV-LOGIC)\n\n\n#fn [REV-LOGIC$fn]\n\n\nAt least it didn‚Äôt blow up this time‚Ä¶\n\n\n((FIX REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nNice, that‚Äôs the right answer.\n\nEven nicer is that our fixed logic behaves like identity now:\n\n((REV-LOGIC (FIX REV-LOGIC)) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\n((REV-LOGIC (REV-LOGIC (FIX REV-LOGIC))) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nI can‚Äôt believe something so ridiculous actually works.\n\nYes it is ridiculous to have all those silly names. Let‚Äôs fix that:\n\n(def Z\n  (fn [F]\n    ((fn [X]\n       (F (fn [V] ((X X) V))))\n     (fn [X]\n       (F (fn [V] ((X X) V)))))))\n\nYou are not your variables. Rename them, rebind them. Your essence is invariant.\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nWait, we are meant to be doing Fibonacci, remember?\n\nWe are factoring out our LOGIC.\n\nIt looks to me like you doubled the code, that‚Äôs not great refactoring. Using single letters make it totally unreadable.\n\nHmmm, there does seem to be a lot of doubling. We can factor out a function for f =&gt; (f f).\n\n(def REPLICATE \"Omega, the self-devouring serpent\"\n  (fn [F]\n    (F F)))\n\nThe replication of identity is itself.\n\n((REPLICATE identity) 1)\n\n\n1\n\nBut test not the serpent lightly\n\n(REPLICATE REPLICATE)\n\n\n\n\n\n\n\njava.lang.StackOverflowError\n\n\n\n\n\ncode-interview.beating.with-stupid-stuff.z-combinator-gambit/REPLICATE  REPL Input:  (repeats 512 times)\njava.lang.StackOverflowError:\n\n\n\n\n\nThe replication of replication is eternal. Now we can clean up that duplication.\n\n(def Z\n  (fn [LOGIC]\n    (REPLICATE (fn [X]\n                 (LOGIC (fn [V] ((X X) V)))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nThat‚Äôs not really any clearer‚Ä¶\n\nVery well, we can keep extracting.\n\n(def DEFER \"Eta, the patient one\"\n  (fn [LOGIC]\n    (fn [VALUE]\n      ((REPLICATE LOGIC) VALUE))))\n\nIf the infinite is deferred, is it infinite?\n\n(def FOLD \"Zeta, weaver of logic, bringer of finitude\"\n  (fn [LOGIC]\n    (REPLICATE (fn [SELF]\n                 (LOGIC (DEFER SELF))))))\n\nOMEGA diverges, ZETA folds, LOGIC writes QED.\n\n((FOLD REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\nThat‚Äôs much nicer, I‚Äôm so glad you suggested using longer names.\n\nCan we write Fibonacci, please?\n\nOh, that‚Äôs easy now!\n\n(def FIB-LOGIC\n  (fn [SELF]\n    (fn [[B A :as FIBS]]\n      (if (&gt; B 10)\n        FIBS\n        (SELF (concat [(+ A B) B] FIBS))))))\n\n\n((FOLD FIB-LOGIC) [1 1])\n\n\n(13 8 8 5 5 3 3 2 2 1 1 1)\n\n\nThat‚Äôs all backward!!\n\nOh, my mistake\n\n((FOLD REV-LOGIC) ((FOLD FIB-LOGIC) [1 1]))\n\n\n[1 1 1 2 2 3 3 5 5 8 8 13]\n\n\nYou can‚Äôt be serious‚Ä¶ This is ridiculous. We‚Äôll be here forever if you keep this up.\n\nI love that idea! An infinite sequence is exactly what we need‚Ä¶\n\n(def FIB-LOGIC-FOREVER\n  (fn [SELF]\n    (fn [A]\n      (fn [B]\n        (lazy-seq\n          (cons A ((SELF B) (+ A B))))))))\n\n\n(take 20 (((FOLD FIB-LOGIC-FOREVER) 1) 1))\n\n\n(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\n\nThat‚Äôs so nice.\n\nOh look at the time! I have a more important meeting to go to! disconnects\n\nOuch, Rough. ZCorp never got back to me, so let‚Äôs update the scoreboard as a loss.\n\n\n\n\n\nInterviews\nWins\nGGs\n\n\n\n\n1\n0\n0\n\n\n\n\n\nThat‚Äôs all for today. Until next time, keep on coding.\n\nsource: src/code_interview/beating/with_stupid_stuff/z_combinator_gambit.clj"
  }
]