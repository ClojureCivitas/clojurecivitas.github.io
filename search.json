[
  {
    "objectID": "code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "href": "code_interview/beating/with_stupid_stuff/z_combinator_gambit.html",
    "title": "The Z-Combinator Gambit",
    "section": "",
    "text": "Welcome back code champs, number ninjas, and data divers to our first episode of Beating Code Interviews with Stupid Stuff. People often send me emails asking, “How can I use lambda calculus to impress people?” Today, we find out.\n\n\n\nProgrammer staring at Z-combinator\n\n\nI have an interview with ZCorp lined up in 5 minutes, and our challenge is to only use anonymous functions. No defn, no loops, and definitely no self-reference. I’ll allow myself the occasional def for brevity, but beyond that, we’ll be running on pure lambda calculus.\n20 minutes later\n\nHey, sorry to keep you waiting. I just got out of a more important meeting. I’m kind of a big deal here at ZCorp. Why don’t you tell me a little bit about yourself?\n\nBorn of binary, raised on algorithms, I walk the path of lambda…\n\nRiiiight… Let’s just start with the warm-up problem. Show me how you would reverse a list.\n\nAh, the timeless list reversal. Deceptively simple, perilously deep. We must first define our purpose.\n\n(fn [SELF LIST])\n\n\n#object [fn]\n\n\nWe’re just writing a function, and it only needs to take a list…\n\nNot just any function, my friend, but one that knows itself. To know yourself is to find your fixed point.\n\n(def REV\n  (fn [SELF LIST]\n    (if (empty? LIST)\n      []\n      (conj (SELF SELF (rest LIST))\n            (first LIST)))))\n\n\n(REV REV [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\nSELF is an input to itself, the logic of reversal.\n\nOk let’s just move on to the next problem, creating a Fibonacci sequence.\n\nOh no, our definition of reverse is intertwined with recursion. Let’s factor that out:\nWe need to lift our SELF\n\n(def REV'\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n((REV' REV') [1 2 3 4 5])\nerror\nOh, no… SELF doesn’t take LIST, it’s a function that returns a function that operates on LIST, and the argument to SELF is… SELF. Therefore, we need to give it (SELF SELF).\n\n(def REV''\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj ((SELF SELF) (rest LIST))\n              (first LIST))))))\n\n\n((REV'' REV'') [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nThat’s a confusing way to write it\n\nQuite right, because it’s not obvious what (SELF SELF) is. We need to extract it out. What we want is:\n\n(def REV-LOGIC\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n\nBelieve me when I say that is not what I meant…\n\nOh, right. Now SELF = (SELF SELF).\n\nNot what I meant, and also that sounds impossible.\n\nBut identity is the identity of itself:\n\n(identity 1)\n\n\n1\n\n\n((identity identity) 1)\n\n\n1\n\n\nO.K. sure, but that’s a special case.\n\n\n(((identity identity) (identity identity)) 1)\n\n\n1\n\n\nThis is an identity crisis.\n\nWe just need to find the right conditions for (SELF SELF) = SELF.\n\n(REV-LOGIC REV-LOGIC)\n\n\n#object [REV-LOGIC$fn]\n\n\nWell, it’s a function! That much is clear…\n\nBut it doesn’t work, because (REV-LOGIC REV-LOGIC) =/= REV-LOGIC. Let’s try something easier:\n\n(def FIX\n  (fn [LOGIC]\n    ;; return something like identity where self application does not change it\n    #_FIXED))\n\nFIX takes the logic function, and makes a function such that (FIXED (FIX LOGIC)) = FIXED\n(FIXED FIXED) =&gt; FIXED which means that ((FIX LOGIC) (FIX LOGIC)) = (FIX LOGIC)\n\nRight, that sounds way easier… shaking head in disbelief\n\nExactly! Because we just reverse it: (FIX F) = ((FIX F) (FIX F))\n\nWhy did you call it FIX?\n\nWell, it was broken before right?\n\nI’m starting to think that you are the broken one.\n\n\n(def FIX\n  (fn [LOGIC]\n    ((FIX LOGIC) (FIX LOGIC))))\n\nBut FIX can still see itself. We need to parameterize the use of FIXED\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (FIXED FIXED)))\n     (fn [FIXED]\n       (LOGIC (FIXED FIXED))))))\n\nThere, I fixed it.\n\nWhat is fixed?\n\nFIXED is (FIXED FIXED), obviously.\n\nObviously. raises hands in dispair\n\nBecause (FIX F) = ((FIX F) (FIX F)), it was your idea to refactor remember?\n(FIX REV-LOGIC)\nstack overflow\n\nEverything looks to be inside out now.\n\nOh, you are right, we can’t pass (FIXED FIXED) as an argument because it will be evaluated first. Thanks for the tip.\n\nCan we fix it? slaps self\n\nInstead of calling (FIXED FIXED) we need a function that will create (FIXED FIXED) when it’s needed, after LOGIC gets called. LOGIC needs to take itself as it’s argument, so the function we pass to LOGIC should look very much like LOGIC, but of course without any actual logic in it.\n\nThat actually sounds logical.\n\nLOGIC is a function of itself, returning a function that acts on a value:\n\ndidn’t you say that (FIXED FIXED) = FIXED?\n\nYes but only after we FIX it. Fixing it requires us to go from FIXED to (FIXED FIXED) remember?\n\nAh sure…\n\nSo while we are fixing logic, let’s replace (LOGIC (FIXED FIXED)) with our deferring function.\n\n(def FIX\n  (fn [LOGIC]\n    ((fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE))))\n     (fn [FIXED]\n       (LOGIC (fn SELF [VALUE]\n                ((FIXED FIXED) VALUE)))))))\n\nDid you know this is called continuation passing style?\n\nCSP?\n\nNo, that’s communicating subprocesses.\n\nThat’s confusing.\n\nIsn’t it!? Fortunately, we are about to be unconfused.\n\n(FIX REV-LOGIC)\n\n\n#object [REV-LOGIC$fn]\n\n\nAt least it didn’t blow up this time…\n\n\n((FIX REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nNice, that’s the right answer.\n\nEven nicer is that our fixed logic behaves like identity now:\n\n((REV-LOGIC (FIX REV-LOGIC)) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\n((REV-LOGIC (REV-LOGIC (FIX REV-LOGIC))) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nI can’t believe something so ridiculous actually works.\n\nYes it is ridiculous to have all those silly names. Let’s fix that:\n\n(def Z\n  (fn [F]\n    ((fn [X]\n       (F (fn [V] ((X X) V))))\n     (fn [X]\n       (F (fn [V] ((X X) V)))))))\n\nYou are not your variables. Rename them, rebind them. Your essence is invariant.\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nWait, we are meant to be doing Fibonacci, remember?\n\nWe are factoring out our LOGIC.\n\nIt looks to me like you doubled the code, that’s not great refactoring. Using single letters make it totally unreadable.\n\nHmmm, there does seem to be a lot of doubling. We can factor out a function for f =&gt; (f f).\n\n(def REPLICATE \"Omega, the self-devouring serpent\"\n  (fn [F]\n    (F F)))\n\nThe replication of identity is itself.\n\n((REPLICATE identity) 1)\n\n\n1\n\nBut test not the serpent lightly\n(REPLICATE REPLICATE)\nstack overflow\nThe replication of replication is eternal. Now we can clean up that duplication.\n\n(def Z\n  (fn [LOGIC]\n    (REPLICATE (fn [X]\n                 (LOGIC (fn [V] ((X X) V)))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n\nThat’s not really any clearer…\n\nVery well, we can keep extracting.\n\n(def DEFER \"Eta, the patient one\"\n  (fn [LOGIC]\n    (fn [VALUE]\n      ((REPLICATE LOGIC) VALUE))))\n\nIf the infinite is deferred, is it infinite?\n\n(def FOLD \"Zeta, weaver of logic, bringer of finitude\"\n  (fn [LOGIC]\n    (REPLICATE (fn [SELF]\n                 (LOGIC (DEFER SELF))))))\n\nOMEGA diverges, ZETA folds, LOGIC writes QED.\n\n((FOLD REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\nThat’s much nicer, I’m so glad you suggested using longer names.\n\nCan we write Fibonacci, please?\n\nOh, that’s easy now!\n\n(def FIB-LOGIC\n  (fn [SELF]\n    (fn [[B A :as FIBS]]\n      (if (&gt; B 10)\n        FIBS\n        (SELF (concat [(+ A B) B] FIBS))))))\n\n\n((FOLD FIB-LOGIC) [1 1])\n\n\n(13 8 8 5 5 3 3 2 2 1 1 1)\n\n\nThat’s all backward!!\n\nOh, my mistake\n\n((FOLD REV-LOGIC) ((FOLD FIB-LOGIC) [1 1]))\n\n\n[1 1 1 2 2 3 3 5 5 8 8 13]\n\n\nYou can’t be serious… This is ridiculous. We’ll be here forever if you keep this up.\n\nI love that idea! An infinite sequence is exactly what we need…\n\n(def FIB-LOGIC-FOREVER\n  (fn [SELF]\n    (fn [A]\n      (fn [B]\n        (lazy-seq\n          (cons A ((SELF B) (+ A B))))))))\n\n\n(take 20 (((FOLD FIB-LOGIC-FOREVER) 1) 1))\n\n\n(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\n\nThat’s so nice.\n\nOh look at the time! I have a more important meeting to go to! disconnects\n\nOuch, Rough. ZCorp never got back to me, so let’s update the scoreboard as a loss.\n\n\n\n\n\nInterviews\nWins\nGGs\n\n\n\n\n1\n0\n0\n\n\n\n\n\nThat’s all for today. Until next time, keep on coding.\n\nsource: notebooks/code_interview/beating/with_stupid_stuff/z_combinator_gambit.clj"
  },
  {
    "objectID": "math/primes/factorization/sieve_augmented.html",
    "href": "math/primes/factorization/sieve_augmented.html",
    "title": "Factorization of Eratosthenes",
    "section": "",
    "text": "Adapts the Sieve of Eratosthenes to prime factorize numbers through n.\n\n(defn prime-factors [n]\n  (reduce\n   (fn [factors prime]\n     (if (= 1 (count (nth factors prime)))\n       (reduce\n        (fn [factors multiple]\n          (let [[composite-divisor :as divisors] (nth factors multiple)]\n            (if (&lt; prime composite-divisor)\n              (let [remaining-divisor (/ composite-divisor prime)\n                    remaining-divisors (nth factors remaining-divisor)\n                    prime-divisors (cons prime (rest divisors))]\n                (assoc\n                 factors multiple\n                 (if (&lt; 1 (count remaining-divisors))\n                   (concat remaining-divisors prime-divisors)\n                   (cons remaining-divisor prime-divisors))))\n              factors)))\n        factors\n        (range (* prime prime) (inc n) prime))\n       factors))\n   (mapv list (range (inc n)))\n   (range 2 (inc (m/sqrt n)))))\n\n\n(prime-factors 13)\n\n\n[(0)\n (1)\n (2)\n (3)\n (2 2)\n (5)\n (3 2)\n (7)\n (2 2 2)\n (3 3)\n (5 2)\n (11)\n (3 2 2)\n (13)]\n\n\nsource: notebooks/math/primes/factorization/sieve_augmented.clj"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "About Posts Pages"
  },
  {
    "objectID": "graph/layout/elk_svg.html",
    "href": "graph/layout/elk_svg.html",
    "title": "ELK SVG",
    "section": "",
    "text": "^{:clay {:title \"ELK SVG\"\n         :quarto {:author   :timothypratley\n                  :category :clojure\n                  :tags     [:graphs :svg :visualization]}}}\n(ns graph.layout.elk-svg\n  (:require [clojure.string :as str]\n            [scicloj.kindly.v4.kind :as kind]))\n\n\n(def default-styles\n  {:edge-shape-stroke      \"black\"\n   :edge-shape-fill        \"none\"\n   :node-shape-stroke      \"black\"\n   :node-shape-fill        \"white\"\n   :node-label-stroke      \"none\"\n   :node-label-fill        \"black\"\n   :node-label-font-size   \"12px\"\n   :node-label-font-family \"sans-serif\"\n   :port-shape-stroke      \"black\"\n   :port-shape-fill        \"white\"})\n\n\n(defn edge-path [{:keys [sections]}]\n  (let [[a & more] (for [{:keys [startPoint bendPoints endPoint]} sections\n                         {:keys [x y]} (concat [startPoint] bendPoints [endPoint])]\n                     (str x \",\" y))]\n    (str \"M\" a \"L\" (str/join \" \" more))))\n\n\n(defn edge [{:as e :keys [id]}]\n  [:g {:id id}\n   [:path {:d          (edge-path e)\n           :stroke     (:edge-shape-stroke default-styles)\n           :fill       (:edge-shape-fill default-styles)\n           :marker-end \"url(#edgeShapeMarker)\"}]])\n\n\n(defn edge-defs []\n  [:marker {:id           \"edgeShapeMarker\"\n            :markerWidth  10\n            :markerHeight 10\n            :refX         6\n            :refY         3\n            :orient       \"auto\"\n            :markerUnits  \"strokeWidth\"}\n   [:path {:d    \"M0,0 L0,6 L6,3 z\"\n           :fill (:edge-shape-stroke default-styles)}]])\n\n\n(defn shape [{:keys [x y width height]}]\n  [:rect {:width  width\n          :height height\n          :stroke (:node-shape-stroke default-styles)\n          :fill   (:node-shape-fill default-styles)}])\n\nTODO: good? bad?\n\n(defn fo-div [width height content]\n  [:foreignObject {:width  width\n                   :height height}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width  \"100%\"\n                  :height \"100%\"}}\n    content]])\n\n\n(defn html-node [{:keys [width height layoutOptions]}]\n  [:foreignObject {:width  width\n                   :height height}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width  \"100%\"\n                  :height \"100%\"}}\n    (:content layoutOptions)]])\n\n\n(defn centered-label [{:keys [text width height]}]\n  [:foreignObject {:width  width\n                   :height height\n                   :style  {:overflow \"visible\"}}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:font-size       \"8px\"\n                  :display         \"flex\"\n                  :align-items     \"center\"\n                  :justify-content \"center\"\n                  :width           \"100%\"\n                  :height          \"100%\"}}\n    text]])\n\n\n(defn positioned-label [{:keys [x y text width height]}]\n  [:foreignObject {:x      (some-&gt; x (* 2.5))\n                   :y      (some-&gt; y (* 2.5))\n                   :width  width\n                   :height height\n                   :style  {:overflow \"visible\"}}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:font-size \"8px\"\n                  :width     \"100%\"\n                  :height    \"100%\"}}\n    text]])\n\n\n(defn node [{:as n :keys [id labels ports children edges x y layoutOptions]}]\n  [:g (merge\n        {:id id}\n        (when (and x y)\n          {:transform (str \"translate(\" x \", \" y \")\")}))\n   (if (:content layoutOptions)\n     (html-node n)\n     (shape n))\n   (concat\n     (for [l labels]\n       ;; TODO: is there a nicer way to default the size?\n       (if (seq children)\n         (positioned-label l)\n         (centered-label (merge l (select-keys n [:width :height])))))\n     ;; TODO: for ports need to adjust relative to node\n     (map node ports)\n     (map node children)\n     (map edge edges))])\n\n\n(defn render-graph [{:as g :keys [x y width height]}]\n  (kind/hiccup\n    [:svg {:viewBox (str (or x 0) \" \" (or y 0) \" \" width \" \" height)\n           :width   \"100%\"\n           :height  800}\n     [:defs (edge-defs)]\n\n     (node g)]))\n\n\nsource: notebooks/graph/layout/elk_svg.clj"
  },
  {
    "objectID": "clojure+/print/objects_and_protocols.html",
    "href": "clojure+/print/objects_and_protocols.html",
    "title": "Printing Objects in Clojure",
    "section": "",
    "text": "The Clojure default for printing objects is noisy. Clojure’s print-method for Object delegates to clojure.core/print-object\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (#'clojure.core/print-object x w))\n\n\n#object[clojure.lang.MultiFn 0x5722b830 \"clojure.lang.MultiFn@5722b830\"]\n\n\n(Object.)\n\n\n#object[java.lang.Object 0x20b60f8c \"java.lang.Object@20b60f8c\"]\n\nThe syntax is #object[CLASS-NAME HASH toString())] and as you can see, the toString of an Object is CLASS-NAME@HASH. This can get pretty ugly:\n\n(async/chan)\n\n\n#object[clojure.core.async.impl.channels.ManyToManyChannel 0x602947e7 \"clojure.core.async.impl.channels.ManyToManyChannel@602947e7\"]\n\nclojure-plus provides print-methods to improve printing many things.\n\n(comment\n  (require 'clojure+.print)\n  (clojure+.print/install-printers!))\n\nOnce activated, we can print functions, atoms, namespaces, and more sensibly. Clojure Plus adds printers for many types, but no printer is provided for Object, which remains as Clojure’s default printing method. There are plenty of objects left over that print messily.\nIt’s not hard to provide an Object print-method:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object [\")\n  (.write w (.getName (class x)))\n  (.write w \"]\"))\n\n\n#object [clojure.lang.MultiFn]\n\n\n(async/chan)\n\n\n#object [clojure.core.async.impl.channels.ManyToManyChannel]\n\nMuch nicer! In my opinion this is a big improvement. Especially in the world of notebooks where we like to show things as we go, but also just keeping a tidy REPL or looking into data that contains objects.\n\n(stats/create-flow)\n\n\n#object [clojure.core.async.flow.impl$create_flow$reify__22762]\n\nHmmmm. not so nice. We’ll dig into this further below. But we also need to be aware that Clojure munges it’s names to make Java valid names. This matters for some things:\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class)\n    (.getName))\n\n\n\"clojure_PLUS_.print.objects_and_protocols$eval26377$_PERCENT__PERCENT___26378$_PERCENT__PERCENT__PERCENT___26379\"\n\nWhoa, that’s pretty gross. We’d prefer to demunge the names at least.\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name))\n\n\n\"clojure+.print.objects-and-protocols/eval26384/%%--26385/%%%--26386\"\n\nNotice the /evalNNNNN/ part? To create a function, Clojure creates a new class. The /evalNNNNN/ counts every time it evaluates. This is useful in the sense that it identifies the class for that evaluation. But we almost never care for that detail (more on that later). For the same reason our strangely named functions have --NNNNN appended to them, because they are sub evaluations of the top-level evaluation.\nLet’s do away with that noise for the moment:\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name)\n    (remove-extraneous))\n\n\n\"clojure+.print.objects-and-protocols/%%/%%%\"\n\nLooking better, I can actually see the (strange) name of the functions.\n\n(defn format-class-name ^String [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str (str/join \"$\" names))\n      (-&gt; s (str/split #\"\\.\") (last)))))\n\n\n(-&gt; (((fn aaa [] (fn bbb [] (fn ccc [])))))\n    (class-name)\n    (format-class-name))\n\n\n\"aaa$bbb$ccc\"\n\nLet’s hook this up to the print-method for Object:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object [\")\n  (.write w (-&gt; (class-name x) (format-class-name)))\n  (.write w \"]\"))\n\n\n#object [MultiFn]\n\n\n*ns*\n\n\n#object [Namespace]\n\n\n(((fn aaa [] (fn bbb [] (fn ccc [])))))\n\n\n#object [aaa$bbb$ccc]\n\n\n(stats/create-flow)\n\n\n#object [create-flow$reify]\n\nWhat is this? It’s a reified object that implements protocols. We can see this by the $reify part at the end. The description is not terrible, at least we know where it was made, which hints that it must be a flow. Can we do better?\nAFAIK the only way to check what protocols an object satisfies is to call satisfies? for every possible protocol:\n\n(defn all-protocol-vars [x]\n  (-&gt;&gt; (all-ns)\n       (mapcat ns-publics)\n       (vals)\n       (keep #(-&gt; % meta :protocol))\n       (distinct)\n       (filter #(satisfies? @% x))))\n\nOn the one hand, this is concerning for performance. On the other hand, at my REPL I don’t care about that, it’s faster than I can notice. Leaving aside those concerns, it returns quite a long list…\n\n(def stats-flow\n  (stats/create-flow))\n\n\n(all-protocol-vars stats-flow)\n\n\n(#'charred.api/PToJSON\n #'portal.runtime.cson/ToJson\n #'clojure.spec.alpha/Specize\n #'clojure.core.reducers/CollFold\n #'clojure.core.async.flow.impl.graph/Graph\n #'clojure.core.protocols/Navigable\n #'clojure.core.protocols/Datafiable\n #'clojure.core.protocols/CollReduce\n #'clojure.core.protocols/InternalReduce\n #'clojure.core.protocols/IKVReduce\n #'hiccup.compiler/HtmlRenderer\n #'nrepl.bencode/BencodeSerializable\n #'reitit.impl/IntoString\n #'clj-yaml.core/YAMLCodec\n #'portal.runtime.jvm.editor/IResolve\n #'clojure.tools.reader.reader-types/PushbackReaderCoercer\n #'clojure.tools.reader.reader-types/ReaderCoercer\n #'clojure.java.io/IOFactory\n #'clojure.data.json/JSONWriter\n #'hiccup.util/ToString\n #'hiccup.util/URLEncode\n #'fipp.ednize/IEdn)\n\nBut notice that one of them; #'clojure.core.async.flow.impl.graph/Graph just feels like it is the one we care about most. Furthermore, it shares a similar namespace with the classname. Let’s try matching by the namespace…\n\n(defn var-ns-name [v]\n  (-&gt; (meta v) (:ns) (ns-name)))\n\n\n(defn ns-match? [p x]\n  (-&gt; (var-ns-name p)\n      (str/starts-with? (.getPackageName (class x)))))\n\n\n(defn protocol-ns-matches [x]\n  (filter #(ns-match? % x) (all-protocol-vars x)))\n\n\n(protocol-ns-matches stats-flow)\n\n\n(#'clojure.core.async.flow.impl.graph/Graph)\n\nNice. In my opinion this is more representative of the object. The #' out front is unnecessary and can be removed…\n\n(defn var-sym [v]\n  (let [m (meta v)]\n    (symbol (str (ns-name (:ns m))) (str (:name m)))))\n\n\n(defn protocol-ns-match-names [x]\n  (-&gt;&gt; (protocol-ns-matches x)\n       (map var-sym)))\n\n\n(protocol-ns-match-names stats-flow)\n\n\n(clojure.core.async.flow.impl.graph/Graph)\n\nThe other protocol of interest is Datafiable, because it indicates I can get a data representation if I would like to.\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans {}}\n\nI think this one is so helpful that it should always be shown on objects, regardless of their type of other protocols, as a hint that it is possible to get more information. I wouldn’t want to print them as data by default, because it would be too spammy. And checking Datafiable is much less of a performance concern.\n\n(satisfies? clojure.core.protocols/Datafiable stats-flow)\n\n\ntrue\n\nBut there is a big problem… everything is Datafiable…\n\n(satisfies? clojure.core.protocols/Datafiable (Object.))\n\n\ntrue\n\nSo there is no way for us to know whether datafy/datafy will do anything useful or not. Sad. But we can improve the print-method to show protocols, bearing in mind it is a performance concern.\nShowing the reified protocol isn’t a big improvement, and probably not worth the performance. Probably not worth including in clojure-plus.\nEven if we don’t care to improve reify (due to performance), I think the Object printer should still be improved to align with the other printers.\nAre we giving up anything? Remember we removed the unique identifiers like /evalNNNNN/. When would those be useful? Hold onto your hats! We are about to try to find an Object by a class-name:\n\n(defn find-class [class-name]\n  (try\n    (Class/forName class-name false (clojure.lang.RT/baseLoader))\n    (catch ClassNotFoundException _ nil)))\n\n\n(defn ddd [x] (inc x))\n\n\n(type (find-class (-&gt; ddd (class) (.getName))))\n\n\njava.lang.Class\n\nWhy would you want to do that? I don’t know, but it’s pretty cool you have to admit. What’s also interesting is that we can get all Clojure classes: https://danielsz.github.io/2021-05-12T13_24.html\n\n(defn class-cache []\n  (some-&gt; (.getDeclaredField clojure.lang.DynamicClassLoader \"classCache\")\n          (doto (.setAccessible true))\n          (.get nil)))\n\n\n(key (first (class-cache)))\n\n\n\"cognitect.transit$read_handler\"\n\nAnd we can find them in memory a similar way:\n\n(defn find-in-memory-class\n  \"Finds a class by name in the DynamicClassLoader's memory cache\"\n  [class-name]\n  (let [method (.getDeclaredMethod clojure.lang.DynamicClassLoader\n                                   \"findInMemoryClass\"\n                                   (into-array Class [String]))\n        _ (.setAccessible method true)]\n    (.invoke method nil (into-array Object [class-name]))))\n\nRight, but why would you want to do that? Honestly I can’t imagine a reason. All of that to say, do we really want those unique identifiers printed out? No! If we need to find them, we can always look them up another way. We don’t need them polluting our REPL output.\n\nsource: notebooks/clojure+/print/objects_and_protocols.clj"
  },
  {
    "objectID": "conferences/scinoj_light_1/notes/hallway_track.html",
    "href": "conferences/scinoj_light_1/notes/hallway_track.html",
    "title": "The Hallway Track: SciNoj Light #1 Data Analysis Stories",
    "section": "",
    "text": "The SciNoj Light #1 Conference brought together Clojure enthusiasts, data scientists, and researchers for an engaging exploration of data analysis stories. The event fostered a collaborative, informal atmosphere where participants exchanged ideas across disciplines from cognitive psychology to urban planning.\nIf you missed it, you can view the talks on the conference sessions playlist. The conference website has detailed information about the talks and speakers. Links to the notebook code presented are on the sessions page, and available as data in the info.edn file.\nThe concluding talk on lane reductions stood out as my favorite because it blended data-driven insights with relatable, human-interest storytelling. As a cyclist, I immediately connected with how lane reductions and protected bike lanes are impactful to my safety. The talk’s compelling visuals, grounded in real case studies, made the story very tangible. Heather’s personal perspective as a car-free parent added emotional weight. She illustrated how community advocacy and smart urban design saves lives, and makes more livable spaces. The mix of passion, rigor, and optimism left me inspired; data analysis can drive tangible, life-improving change.\n\n\n\nBike lane improvements reduce crashes\n\n\nA major focus of the conference was the development of Clojure’s data science Noj toolkit. This suite of libraries demonstrated how Clojure combines functional programming elegance with practical performance. Speakers highlighted Noj’s interoperability with Python and Java ecosystems while emphasizing its advantages for reproducible and maintainable workflows. The community’s collaborative energy was evident throughout.\n\n\n\nNoj core components\n\n\nArtificial intelligence emerged as a recurring theme, with several talks exploring hybrid approaches to enhance reliability. One discussion centered on Retrieval-Augmented Generation (RAG) systems, where combining large language models with Clojure’s logic programming capabilities could improve accuracy in structured domains like government Q&A. Another session delved into probabilistic programming with Inferme, illustrating Bayesian methods for modeling uncertainty. These technical deep dives were balanced by ethical considerations and reflections on technology’s societal implications.\nScientific applications showcased Clojure’s versatility. One talk explored simulating fluid dynamics. Another focused on forecasting tropical cyclone paths using physics-informed machine learning. Cognitive science experiments were also featured, using collaborative games and puzzles to study human planning behavior, and brain wave monitors. The conference also highlighted social impact work, such as data-driven advocacy for safer street designs, proving that technical tools can drive urban change.\nWhat stood out to me was how effectively the SciCloj community uses Clojure notebooks for collaborative work. Presenters shared their research through executable notebooks that cleanly combined code, visualizations and explanations. It’s a practical pattern broadly applicable for sharing ideas and knowledge.\nThroughout the event, a sense of optimism prevailed about Clojure’s untapped potential. While acknowledging gaps in ML tooling compared to Python, speakers demonstrated that Clojure’s functional rigor and JVM scalability make it a good fit for data science. Attendee discussions envisioned collaborating further on logic-guided AI and semantic web ontologies. There was a recurring theme of bridging the gap between academic theory and real-world engineering. SciNoj Light ultimately painted a picture of Clojure not just as a language, but as a catalyst for interdisciplinary innovation.\n\nYou can have the cake of Clojure’s immutable persistent data structures and eat it too;\nGet your answers fast and make your customers happy.\n— Harold\n\nA big thank you to the organizers! The event was an overwhelming success with high quality presentations and valuable discussions. I’m looking forward to the next SciNoj, it’s a rare and valuable blend of science, technology, community and code.\nBelow are my notes about the sessions and conversations from the conference.\n\nPre-conference interview\nEngaging to have a taste of what’s to come, got me really enthusiastic about the coming event. Game as a Research Tool: “Tik Tik” is a controlled environment for studying human cognition and collaboration. Combines cognitive psychology, game design, and data analysis.\n\n\n1.1: Hello\nCommunity-driven event. Informal, interactive, and welcoming. Focus on Clojure for data workflows. Tools and libraries have matured, and the conference shares these advancements. Zulip is the main forum, attendees are encouraged to engage via structured topic threads. The macroexpand session invites ideas for expanding Clojure adoption in various fields. Hosts encourage questions, jokes, and relaxed participation. Sets the tone for an inclusive, engaging, and slightly nerdy gathering of Clojure enthusiasts.\n\n\n1.2: An intro to the Noj toolkit\nNoj is a Clojure-based data science toolkit integrating libraries for data analysis, visualization, and machine learning. Designed for functional, efficient data processing with compatibility across libraries (e.g., Tablecloth, FastMath, Metamorph). Inspired by tools like R’s dplyr/ggplot and Python’s pandas/Plotly, but with a Clojure-centric approach. Tablecloth for tabular data manipulation (similar to pandas/dplyr). TablePlot grammar-of-graphics-inspired visualization (like ggplot). FastMath stats and statistical modeling (logistic regression and more). Metamorph for machine learning workflows. Worked example of predicting success in Kickstarter projects. Data loading/cleaning, exploratory analysis (grouping, aggregation, bar plots), predictive modeling, evaluation (train/test split, accuracy checks). Functional & Immutable, Noj leverages Clojure’s strengths. Efficient columnar storage with zero-copy operations.\n\n\n1.3: Probability and statistics - Daniel Slutsky\nGenerating pseudo-random numbers using seeds for reproducibility in research. Simulating dice rolls to explore distributions. Used histograms and scatter plots to visualize distributions. Computed mean, standard deviation and z-scores for comparison. Bayesian inference for probabilistic models with parameters. Conditioned models on observed data to infer posterior distributions. Highlighted constraints and efficient sampling algorithms. Avoid lazy sequences for large simulations; consider dtype-next or transducers. Visualization matters, histograms and scatter plots reveal patterns. Probabilistic programming models uncertainty and updates beliefs with data. Balanced foundational stats with advanced topics, emphasizing Clojure’s tools for data science.\n\n\n1.4: Customer churn analysis, LLMs & logic programming - Siavash Mohammady\nCustomers leaving significantly impacts revenue. Exploring factors like course format, teacher experience, and registration patterns. High churn in early months, newer teachers correlated with higher churn. User prompt → NLP entity recognition → LLM generates high-level DSL → Clara rule engine translates to low-level DSL → Execution. Mentorship for new teachers can reduce churn. Pairing LLMs abstract reasoning with logic engines concrete execution optimizes complex data tasks. A forward-looking talk blending data science, AI, and Clojure, emphasizing doing less.\n\n\n1.5: Linear Foundations & Nonlinear Frontiers - Jelena Losic\nLinear systems rely on superposition, the whole is the sum of parts. Vector spaces, linear regression, Fourier analysis. Real-world systems are often nonlinear. Linear methods fail when data lies on curved manifolds or exhibits complex interactions. Techniques like t-SNE, UMAP, and autoencoders handle nonlinearity by preserving structures or learning manifold geometry. Nonlinear systems can be deterministic yet unpredictable. Nonlinear methods unlock richer patterns but sacrifice interpretability and require more data. Dimensionality reduction illustrates the trade-off between simplicity and accuracy. Embeddings leverage linear algebra but rely on nonlinear transformations for deeper semantics.\n\n\n1.6: RAGgedy Ann’s Big Adventure - Paula Gearon\nVectors represent concepts in multidimensional space. Embeddings convert text into vectors, capturing meaning. Similarity between vectors is measurable. Neural networks process inputs through weighted connections and activation functions. Transformers contextualize words in sentences. Combining LLMs with vector databases to reduce hallucinations. Augmenting queries with retrieved context. LLMs are built from modular math operations. Vector databases enable semantic search. RAG improves accuracy by grounding LLM outputs in verified data.\n\n\n1.7: Parliamentary Questions - RAG Evaluation - Eoin Carney\nCan RAG effectively answer parliamentary style questions using Irish government data? 10k publicly available Irish parliamentary questions and answers. Compared sentence-based chunking with full document retrieval. Tested multiple LLMs for generation and evaluation. Retrieval Matters More Than Prompting. Smaller, precise chunks of 3–5 sentences improved precision over full document retrieval. Direct answer retrieval outperformed matching questions to answers. Deterministic metrics like word overlap failed to capture nuance. LLM as judge worked better for correctness. Clay notebook visualization helped explore vector embeddings interactively. Government answers should be plain and factual. LLMs are oddly well-suited for that.\n\n\n1.8 - Discussion: RAGs and Structured Knowledge\nShared experiences using Clojure for AI projects. Exploring logic programming as a superset of reasoning techniques and unifying them with embeddings and vector logic. Foundational ontologies and their role in structuring knowledge for AI, particularly in medical domains. The conversation fluidly shifted from technical to philosophical and practical.\n\n\n1.9: Noj Deep Dive - Harold & Daniel Slutsky\nUsing Clojure for functional data science, contrasting it with Python tools like Pandas. The focus is on immutability, performance, and leveraging Clojure’s strengths for data processing. Tech.ml.dataset for tabular data processing. Columnar storage for efficiency and integrates with other libraries in the ecosystem. Layered Architecture. Hamfisted high-performance, immutable collections optimized for JVM memory/CPU. Dtype-next array random access and lazy, non-caching transformations. Tablecloth high-level tabular data tools built atop these foundations. Challenges and solutions for integrating with Python via libpython-clj and stdlang. Hamfisted and Dtype-next enable Clojure to match Java/Python performance while retaining functional idioms. 20x speedup in lazy sequences. Columnar storage in TMD reduces memory overhead. Libraries like FastMath, MetamorphML, and Tableplot extend the stack. Real-world applications in consulting and open-source collaboration. Frequent shoutouts to contributors and emphasis on community input via Zulip. If you think data science needs software engineering, you’re right. A blend of technical rigor, community spirit, and practical focus on building scalable, functional data tools.\n\n\n1.10: Brain data in Clojure - Lorelai Lyons\nEthical and Historical Context of Brain-Computer Interfaces. Morally questionable history of neuroscience. Need for ethical considerations in modern BCIs. The goal is to bridge the gap between continuous human thought and discrete computing. Neurons generate electrical signals that can be recorded and digitized. EEG measures brainwave frequencies via electrodes placed on the scalp. EEG data from a motor imagery study. Applied filters to isolate frequency bands. Developing a low-cost binary file system for efficient EEG data storage. Exploring brain-controlled interfaces for creative applications. Consumer EEG devices make brain data collection feasible for programmers. BCIs require collaboration across neuroscience, hardware, and software. Mixed technical depth with ethical reflection.\n\n\n2.1: 1D Viscous Fluid Flow Data Analysis, Burgers’ Equation - Siyoung Byun\nFluid dynamics is complex, involving variables like friction, pressure, and momentum. CFD uses computational methods to simulate fluid behavior, crucial for fields like aerospace, healthcare, and astrophysics. Astrophysics simulations of binary star collisions use CFD. Burgers’ Equation combines nonlinear convection (steepening fluid motion) and viscosity (smoothing/diffusion). Demonstrated via simulations of a shock in a 1D fluid, visualized over time. Used mutable Java arrays for performance. Extending to 2D/3D simulations and incorporate the Navier-Stokes equations for full fluid dynamics. Visualization Matters. Plotting data is critical for interpreting simulations. Siyoung emphasizes the learning process and invites collaboration. Technical but accessible, viscosity effects are explained with analogies. Passion for both astrophysics, fluid dynamics and Clojure shines through. Simulations of white dwarf collisions brought home the realization that star interactions are fluid. Korean ondol floor heating as an analogy for convection.\n\n\n2.2: UK Electricity Demand Time Series Forecasting - Anton Lobach\nThe Taylor dataset contains electricity demand in Wales/England. Extract day of week, minute of day, weekend flag. Ridge regression regularized linear regression to prevent overfitting. Use rolling origin cross-validation. Root Mean Squared Error to measure forecast accuracy. Clojure has expressive, modular workflows with strong data processing capabilities. Seasonality matters. Minute-of-day was the most predictive feature. Ridge regression achieved reasonable accuracy. Split data into train/test sets before exploratory analysis to avoid bias. Use rolling windows for temporal data. The tutorial is available as an interactive notebook.\n\n\n2.3: Tropical cyclone trajectory modelling - K Ram Narayan, Naimish Mani B\nAccurate trajectory forecasting is crucial for disaster preparedness, evacuation planning, and minimizing loss of life and property. Forecasting relies on a mix of satellite data, computer simulations, and aircraft reconnaissance. Using SINDy (Sparse Identification of Nonlinear Dynamics), to extract governing equations from cyclone trajectory data to predict future paths. Global cyclone track dataset. Satellite imagery used to compute wind velocity and shear via optical flow. Incorporates cyclone dynamics to refine SINDy’s candidate equations. Cyclone movement is driven by steering winds, Coriolis force, beta drift, and interactions with pressure systems. Collect trajectory and satellite data. Construct a candidate library of possible dynamical terms. Use Lasso regression to sparsely select the most relevant terms. Derive interpretable differential equations for forecasting. SINDy achieved a 43.71 km mean absolute error, acceptable in cyclone forecasting. Outperformed by gradient boosting, and random forest in single-step prediction but excels in full trajectory forecasting. Bay of Bengal cyclones curve unpredictably due to land effects. Bridges meteorology, physics, and machine learning for cyclone prediction.\n\n\n2.4: Studying planning with a novel video game - Cvetomir Dimov\nPlanning is a fundamental cognitive ability used in everyday tasks. “Tik Tik” game is designed to study planning. Players control a fireball and an ice cube that must collaborate to navigate obstacles and reach targets. A custom program was developed to generate and solve game levels, identifying optimal paths and measuring problem difficulty. Goal is to understand what incentivizes planning. Difficulty influenced by the number of barriers and their intersections. Problem difficulty predictors were the minimum moves needed and the number of possible paths up to the optimal length. Study 1 high dropout rates, large individual differences in planning ability. Study 2 time limits and stricter move limits reduced dropouts and reinforced planning incentives. Tight constraints encourage planning. Problem difficulty can be systematically manipulated for cognitive research. Demonstrations of the game and solver make abstract concepts tangible. Credits multiple software tools, emphasizing a community-driven approach to research.\n\n\n2.5: Building a Data Science Ecosystem in Clojure - Kira Howe\nInspiration from the Tidyverse (R). A cohesive ecosystem with shared design principles on data and composable tools. Standardized data structures and streamline workflows. Fragmented tools create glue code overhead. Immutable data and pure functions enable reproducibility. JVM handles large-scale data efficiently. Engineering culture emphasis on stability and interoperability. Explosive data growth demands scalable, deterministic tools. Noj as a Clojure based ecosystem inspired by Tidyverse but optimized for scalability and engineering. Simplify onboarding through Jupyter support and Clojure in a box. Need for Shiny-like tools for rapid prototyping. Emphasized grassroots community building and learning together. Data quality should be a philosophy, not an afterthought.\n\n\n2.6: Macroexpand-1\nWays to broaden Clojure’s impact beyond its traditional domains by fostering interdisciplinary collaboration. Need to make Clojure more accessible and visible in fields like data science, education, and specialized industries. Improve tooling, documentation, and community outreach. Developer intuitive libraries, enhancing interoperability with other languages. Lowering barriers for newcomers. Importance of geospatial analysis and modern programming practices. Sustainable community efforts and cross-disciplinary knowledge sharing.\n\n\n2.7: The Impact of Lane Reductions - Heather Moore-Farley\nReducing car lanes, protected bike lanes, and pedestrian crossings decrease traffic injuries and fatalities. California’s crash data used to visualize collision hotspots to push for safer street redesigns. High injury corridors 6% of streets cause 60% of severe/fatal crashes. Correlated lane reductions, protected bike lanes, and raised bus stops led to fewer crashes over time. Local groups use data to advocate for safer streets. Police reported crash data has missing ages, locations and underreporting driver fault. Heather shares her lived experience as a car-free parent in Oakland, tying data to safety. Design solutions and community action work. Advocating for upcoming redesigns. A compelling mix of data science, urbanism, and grassroots advocacy. Number crunching can drive tangible change."
  },
  {
    "objectID": "core/async/flow/visualization/flow_elk.html",
    "href": "core/async/flow/visualization/flow_elk.html",
    "title": "Flow to ELK data transformation",
    "section": "",
    "text": "(defn id-for [x]\n  (cond (keyword? x) (str (symbol x))\n        (vector? x) (str/join \"_\" (map id-for x))\n        (string? x) x\n        :else (str x)))\n\nproblem: graph layout algorithms have different requirements complex: label placement may be important, handled by layout, different for parents complex: ports may be useful or unsupported problem: html nodes need to be measured for layout problem: my data is not the layout is not the view problem: arbitrary data is not transferred problem: visualizations are trees, graphs are not always trees\nidea: A standard view model for graphs (not trees) the view model should just be nodes and edges - port nodes with special properties - what about groups? nodes that have children - ordering parents have children… not a nesting – the viewmodel can calculate what are the parents of x, what are the children – nodes can have a parent identifier. we represent the relation not the hierarchy ** ELK models are hierarchy &lt;– problematic\nWhen do we care?\nA (parents #{B}) B (parents #{C}) C D (parents #{B, C})\n“Parents are an edge with a special property”\nB -&gt; A C -&gt; B C -&gt; D B -&gt; D\nWe represent them as groups\nTrick: layout with parent edges, don’t draw them, but do create borders. Problem: incorrect overlaps, can be solved with Veroni\nEverything is a node or edge, some logic to determine how it’s displayed, and ordering Can be general Output from layout algorithms will need to be transformed\nidea: Structural merge (like Reagent, respecting keys) can combine layout and data\nReagent: define component f (data)\n=&gt; f1 [ [:div {:key 1} “apples”] [:div {:key 2} “pear”] ]\n=&gt; f2 [ [:div {:key 2} “pears”] [:div {:key 1} “apples] ] compute the updates, with the keys: swap the dom elements and update pear to pears without the keys: replace everything\nStructural merge:\n(merge-structure {:a [{:key 1, :happy “yes”} {:key 2, :happy “no”}]} {:a [{:key 2, :happy “absolutely”}]}) =&gt; {:a [{:key 1, :happy “yes”} {:key 2, :happy “absolutely”}]}\n(merge-structure g (layout g)) =&gt; adds x and y, keeps my data.\ntree {:children [{:label … }]} layout {:children [{:label …, :x 1, :y 2}]\n(merge structure\n(merge-dissoc removals\n(merge-replace replacement\nsupporting functions (optional) {:a #(…)}\n\nsource: notebooks/core/async/flow/visualization/flow_elk.clj"
  },
  {
    "objectID": "core/async/flow/visualization.html",
    "href": "core/async/flow/visualization.html",
    "title": "Core Async Flow Visualization",
    "section": "",
    "text": "Visualizing core.async.flows\n\n(defn id-for [x]\n  (cond (keyword? x) (str (symbol x))\n        (vector? x) (str/join \"_\" (map id-for x))\n        (string? x) x\n        :else (str x)))\n\nwould be more interesting if we show the buffer state\n\n(defn conn-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ;; TODO: add channel state\n    ^:kind/table\n    {:row-maps (vec (for [[from to] conns]\n                      {:source (id-for from)\n                       :target (id-for to)}))}))\n\n\n(defn proc-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ^:kind/table\n    {:column-names [\"process\" \"start params\" \"in chans\" \"out chans\"]\n     :row-vectors  (for [[proc-key proc-chans] (group-by first all-proc-chans)]\n                     (let [{:keys [args proc]} (get procs proc-key)\n                           {:keys [desc]} proc\n                           {:keys [params ins outs]} desc]\n                       [(name proc-key)\n                        ^:kind/hiccup\n                        [:div\n                         (for [[k param] params]\n                           [:div\n                            [:div [:strong (name k)] \": \" (get args k)]\n                            [:div param]])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] ins]\n                                [:div [:strong (name k)] \": \" v])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] outs]\n                                [:div [:strong (name k)] \": \" v])]]))}))\n\n\n(defn elkg [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)\n        chans-as-ports true\n        with-content false]\n    {:id            \"G\"\n     :layoutOptions {:elk.algorithm         \"layered\"\n                     :elk.direction         \"DOWN\"\n                     :elk.hierarchyHandling \"INCLUDE_CHILDREN\"}\n     :children\n     (for [[proc-key proc-chans] (group-by first all-proc-chans)]\n       (let [{:keys [args proc]} (get procs proc-key)\n             {:keys [desc]} proc\n             {:keys [params ins outs]} desc\n             width 100\n             height 100\n             content (when with-content\n                       [{:id            (str (name proc-key) \"_content\")\n                         :width         (- width 5)\n                         :height        (- height 5)\n                         ;; nope, do it by id\n                         :layoutOptions {:content (str/join \\newline\n                                                            (for [[k param] params]\n                                                              (str (name k) \" (\" (get args k) \") \" param)))}}])\n             children (for [[_ chan :as proc-chan] proc-chans]\n                        {:id       (id-for proc-chan)\n                         :width    20\n                         :height   20\n                         :labels   [{:text (name chan)}]\n                         :children (vec (when with-content\n                                          [{:id            (str (id-for proc-chan) \"_content\")\n                                            :width         20\n                                            :height        20\n                                            ;; nope, do it by id\n                                            :layoutOptions {:content (str (name chan)\n                                                                          \\newline \\newline\n                                                                          (or (get outs chan)\n                                                                              (get ins chan)))}}]))})]\n         {:id            (id-for proc-key)\n          :width         100\n          :height        100\n          :layoutOptions {:org.eclipse.elk.nodeLabels.placement \"OUTSIDE V_TOP H_LEFT\"}\n          :labels        [{:text (name proc-key)}]\n          :children      (vec (concat content (when (not chans-as-ports) children)))\n\n          :ports\n          (vec (when chans-as-ports children))}))\n     :edges\n     (vec (for [[from to] conns]\n            {:id      (id-for [from to])\n             :sources [(id-for from)]\n             :targets [(id-for to)]}))}))\n\n\nsource: notebooks/core/async/flow/visualization.clj"
  },
  {
    "objectID": "clojure/print_object/remove_extraneous.html",
    "href": "clojure/print_object/remove_extraneous.html",
    "title": "Clean object printing by removing extraneous",
    "section": "",
    "text": "The Clojure default for printing objects is noisy. Clojure’s print-method for Object delegates to clojure.core/print-object\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (#'clojure.core/print-object x w))\n\n\n#object[clojure.lang.MultiFn 0x5722b830 \"clojure.lang.MultiFn@5722b830\"]\n\n\n(Object.)\n\n\n#object[java.lang.Object 0x4bdf1bbe \"java.lang.Object@4bdf1bbe\"]\n\nThe syntax is #object[CLASS-NAME HASH toString())] and as you can see, the toString of an Object is CLASS-NAME@HASH. For most objects this becomes quite a long string.\n\n(async/chan)\n\n\n#object[clojure.core.async.impl.channels.ManyToManyChannel 0x381e35a2 \"clojure.core.async.impl.channels.ManyToManyChannel@381e35a2\"]\n\n\n\n\nObjection!\n\n\nFunctions are printed as objects\n\n(fn [x] x)\n\n\n#object[clojure.print_object.remove_extraneous$eval22346$fn__22347 0x63540ec4 \"clojure.print_object.remove_extraneous$eval22346$fn__22347@63540ec4\"]\n\nIt’s quite easy to miss the fact that it is a function as we are looking for a tiny little fn in a sea of text. If, like me, you are fond of the odd lambda calculus excursion, things get even more hectic.\n\n((fn [x] (fn [v] ((x x) v))) (fn [y] y))\n\n\n#object[clojure.print_object.remove_extraneous$eval22350$fn__22351$fn__22352 0x4b6607a \"clojure.print_object.remove_extraneous$eval22350$fn__22351$fn__22352@4b6607a\"]\n\nYikes! what an eyesore. This is not an academic issue specific to lambda calculus. Any function created from inside a function is helpfully identifiable through the fn$fn nesting. We create these quite regularly, and they are often printed in stack traces. I’m sure you have seen them when you map an inline function across a seq, and there is a bug in the anonymous function.\n\n(defn caesar-cipher [s]\n  (mapv (fn add2 [x] (+ 2 x)) s))\n\n\n(try (caesar-cipher \"hello world\")\n     (catch Exception ex\n       (vec (take 4 (.getStackTrace ex)))))\n\n\n[[clojure.lang.Numbers add \"Numbers.java\" 155]\n [clojure.lang.Numbers add \"Numbers.java\" 3747]\n [clojure.print_object.remove_extraneous$caesar_cipher$add2__22358 invoke \"NO_SOURCE_FILE\" 0]\n [clojure.core$mapv$fn__8565 invoke \"core.clj\" 7059]]\n\nSee that part caesar_cipher$add2? That is very useful information. It tells us that the exception was inside add2, which is inside caesar-cipher. The stack trace doesn’t print functions as objects, but it illustrates that the thing that we care about is that they are a function, what their name is, and whether they were created from inside another function.\nLet’s return to printing a function as an object. An easy improvement is to demunge from Java names to Clojure names. Demunging converts _ to - and $ to /, and munged characters like + which is PLUS in Java.\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(class-name ((fn [] (fn [y] y))))\n\n\n\"clojure.print-object.remove-extraneous/eval22364/fn--22365/fn--22366\"\n\nNext, we don’t need the eval identities.\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(remove-extraneous (class-name ((fn [] (fn [y] y)))))\n\n\n\"clojure.print-object.remove-extraneous/fn/fn\"\n\nMuch nicer. I can actually read that! I’m not particularly fond of the long namespace shown as the name is either defined in this namespace, referred, or part of clojure.core. The multiple slashes form invalid symbols which annoy me; I prefer using / only for namespace/name separation and $ as the name level delimiter: my.namespace/my$nested$name.\n\n(defn format-class-name ^String [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str (str/join \"$\" names))\n      (-&gt; s (str/split #\"\\.\") (last)))))\n\n\n(format-class-name (remove-extraneous (class-name ((fn [] (fn [y] y))))))\n\n\n\"fn$fn\"\n\nSo short, so sweet. If it’s a function, why call it an object?\n\n(defn object-str ^String [x]\n  (str (if (fn? x) \"#fn\" \"#object\")\n       \" [\" (format-class-name (class-name x)) \"]\"))\n\n\n(object-str ((fn [] (fn [y] y))))\n\n\n\"#fn [fn$fn]\"\n\n\n(object-str (async/chan))\n\n\n\"#object [ManyToManyChannel]\"\n\nThis is really all I care to know about when printing objects and functions, and it matters inside notebooks, where we want to print things, eval things that return objects and functions, and datafy complex objects that contain other objects. To print things without knowing if they are objects, functions, or data, we can extend Clojure’s print-method.\n\n(defmethod print-method Object [x ^Writer w]\n  (.write w (object-str x)))\n\n\n#object [MultiFn]\n\n\n((fn [] (fn [y] y)))\n\n\n#fn [fn$fn]\n\n\n(async/chan)\n\n\n#object [ManyToManyChannel]\n\nYou can require this namespace from other notebooks to turn on this nice, concise mode of object printing.\nHappy notebooking!\n\nsource: notebooks/clojure/print_object/remove_extraneous.clj"
  },
  {
    "objectID": "core/async/flow/example/stats.html",
    "href": "core/async/flow/example/stats.html",
    "title": "Core Async Flow Stats Example",
    "section": "",
    "text": "Recently Alex provided a video walkthrough on how to use core.async.flow to build a stats monitor.\n\nThis notebook is adapted from his code.\n\n(defn stat-gen\n  \"Generates a random value between min (inclusive) and max (exclusive)\n  and writes it to out chan, waiting wait ms between until stop-atom is flagged.\"\n  ([out min max wait stop-atom]\n   (loop []\n     (let [val (+ min (rand-int (- max min)))\n           put (a/&gt;!! out val)]\n       ;(println \"stat-gen\" (System/identityHashCode stop-atom) val put (not @stop-atom))\n       (when (and put (not @stop-atom))\n         (^[long] Thread/sleep wait)\n         (recur))))))\n\n\n(defn source\n  \"Source proc for random stats\"\n  ;; describe\n  ([] {:params {:min  \"Min value to generate\"\n                :max  \"Max value to generate\"\n                :wait \"Time in ms to wait between generating\"}\n       :outs   {:out \"Output channel for stats\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:stat (a/chan 100)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [min max wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"transition\" transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (stat-gen (:stat in-ports) min max wait stop-atom))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   ;(println \"source transform\" in msg)\n   [state (when (= in :stat) {:out [msg]})]))\n\n\n(defn aggregator\n  ;; describe\n  ([] {:params   {:min \"Min value, alert if lower\"\n                  :max \"Max value, alert if higher\"}\n       :ins      {:stat \"Channel to receive stat values\"\n                  :poke \"Channel to poke when it is time to report a window of data to the log\"}\n       :outs     {:alert \"Notify of value out of range {:val value, :error :high|:low\"}\n       :workload :compute\n       })\n\n  ;; init\n  ([args] (assoc args :vals []))\n\n  ;; transition\n  ([state transition] state)\n\n  ;; transform\n  ([{:keys [min max vals] :as state} input-id msg]\n   (case input-id\n     :stat (let [state' (assoc state :vals (conj vals msg))\n                 msgs (cond\n                        (&lt; msg min) {:alert [{:val msg, :error :low}]}\n                        (&lt; max msg) {:alert [{:val msg, :error :high}]}\n                        :else nil)]\n             [state' msgs])\n     :poke [(assoc state :vals [])\n            {:clojure.core.async.flow/report (if (empty? vals)\n                                               [{:count 0}]\n                                               [{:avg   (/ (double (reduce + vals)) (count vals))\n                                                 :count (count vals)}])}]\n     [state nil])))\n\n\n(comment\n  ;; test aggregator alert case - no channels involved\n  (let [state {:min 1 :max 5 :vals []}\n        [state' msgs'] (aggregator state :stat 100)]\n    (assert (= msgs' {:alert [{:val 100, :error :high}]})))\n  )\n\n\n(defn scheduler\n  ;; describe\n  ([] {:params {:wait \"Time to wait between pokes\"}\n       :outs   {:out \"Poke channel, will send true when the alarm goes off\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:alarm (a/chan 10)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"scheduler transition\" transition state transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (loop []\n                 (let [put (a/&gt;!! (:alarm in-ports) true)]\n                   (when (and put (not @stop-atom))\n                     (^[long] Thread/sleep wait)\n                     (recur)))))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   [state (when (= in :alarm) {:out [true]})]))\n\n\n(defn printer\n  ;; describe\n  ([] {:params {:prefix \"Log message prefix\"}\n       :ins    {:in \"Channel to receive messages\"}})\n\n  ;; init\n  ([state] state)\n\n  ;; transition\n  ([state _transition] state)\n\n  ;; transform\n  ([{:keys [prefix] :as state} _in msg]\n   (println prefix msg)\n   [state nil]))\n\n\n(def config\n  {:procs {:generator  {:args {:min 0 :max 12 :wait 500} :proc (flow/process #'source)}\n           :aggregator {:args {:min 1 :max 10} :proc (flow/process #'aggregator)}\n           :scheduler  {:args {:wait 3000} :proc (flow/process #'scheduler)}\n           :notifier   {:args      {:prefix \"Alert: \"} :proc (flow/process #'printer)\n                        :chan-opts {:in {:buf-or-n (a/sliding-buffer 3)}}}}\n   :conns [[[:generator :out] [:aggregator :stat]]\n           [[:scheduler :out] [:aggregator :poke]]\n           [[:aggregator :alert] [:notifier :in]]]})\n\n\n(defn create-flow\n  []\n  (flow/create-flow config))\n\n\n(comment\n  (def f (create-flow))\n  (def chs (flow/start f))\n  (flow/resume f)\n  (flow/pause f)\n  (flow/stop f)\n\n  (def server (mon/start-server {:flow f}))\n  (mon/stop-server server)\n\n  @(flow/inject f [:aggregator :poke] [true])\n  @(flow/inject f [:aggregator :stat] [\"abc1000\"])          ;; trigger an alert\n  @(flow/inject f [:notifier :in] [:sandwich])\n\n  (def report-chan (:report-chan chs))\n  (flow/ping f)\n  (a/poll! report-chan)\n  (def error-chan (:error-chan chs))\n  (a/poll! error-chan)\n\n  (flow/stop f)\n  (a/close! stat-chan)\n\n  @(flow/inject f [:aggregator :poke] [true])\n\n  (require '[clojure.datafy :as datafy])\n  (datafy/datafy f)\n\n  (require '[clojure.core.async.flow-static :refer [graph]])\n  (graph f)\n\n  )\n\n\nsource: notebooks/core/async/flow/example/stats.clj"
  },
  {
    "objectID": "core/async/flow/exploration.html",
    "href": "core/async/flow/exploration.html",
    "title": "Core Async Flow Exploration",
    "section": "",
    "text": "One of Clojure’s superpowers is the ability to coordinate asynchronous operations using core.async. While powerful, these operations can become hard to reason about as they grow in complexity.\nThe new core.async.flow library offers a higher-level abstraction for modeling async processes as a Directed Acyclic Graph (DAG). And now, with flow-monitor, we can visualize and analyze those flows.\nLet’s walk through an exploration of such a flow."
  },
  {
    "objectID": "core/async/flow/exploration.html#what-well-explore",
    "href": "core/async/flow/exploration.html#what-well-explore",
    "title": "Core Async Flow Exploration",
    "section": "What We’ll Explore",
    "text": "What We’ll Explore\nIn this notebook, we’ll take a look at:\n\nBasic flow structure: What does a flow look like under the hood?\nStatic visualization: How can we inspect its components?\nDynamic interaction: How do values move through the flow, and what happens when they do?"
  },
  {
    "objectID": "core/async/flow/exploration.html#creating-a-flow",
    "href": "core/async/flow/exploration.html#creating-a-flow",
    "title": "Core Async Flow Exploration",
    "section": "1. Creating a Flow",
    "text": "1. Creating a Flow\nFlows are created from configuration\n\n(def stats-flow\n  (flow/create-flow stats/config))\n\nThis flow models a small system involving aggregation, notification, and reporting. Internally, it consists of processes connected via channels."
  },
  {
    "objectID": "core/async/flow/exploration.html#inspecting-the-flow",
    "href": "core/async/flow/exploration.html#inspecting-the-flow",
    "title": "Core Async Flow Exploration",
    "section": "2. Inspecting the Flow",
    "text": "2. Inspecting the Flow\nFlows implement the Datafy protocol so we can inspect them as data.\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans {}}\n\nThat’s a lot to take in! Fortunately, we can make things more digestible by viewing just the processes involved.\n\n(fv/proc-table stats-flow)\n\n\n\n\n\n\n\n\n\n\n\n\nprocess\nstart params\nin chans\nout chans\n\n\n\n\nnotifier\n\n\n\nprefix: Alert:\n\n\nLog message prefix\n\n\n\n\n\nin: Channel to receive messages\n\n\n\n\n\n\n\naggregator\n\n\n\nmin: 1\n\n\nMin value, alert if lower\n\n\n\n\nmax: 10\n\n\nMax value, alert if higher\n\n\n\n\n\nstat: Channel to receive stat values\n\n\npoke: Channel to poke when it is time to report a window of data to the log\n\n\n\n\nalert: Notify of value out of range {:val value, :error :high|:low\n\n\n\n\nscheduler\n\n\n\nwait: 3000\n\n\nTime to wait between pokes\n\n\n\n\n\n\n\n\nout: Poke channel, will send true when the alarm goes off\n\n\n\n\ngenerator\n\n\n\nmin: 0\n\n\nMin value to generate\n\n\n\n\nmax: 12\n\n\nMax value to generate\n\n\n\n\nwait: 500\n\n\nTime in ms to wait between generating\n\n\n\n\n\n\n\n\nout: Output channel for stats\n\n\n\n\n\n\n\nThis table gives us a clear list of components in the flow, including their names and behaviors.\nNext, let’s examine how these processes are connected.\n\n(fv/conn-table stats-flow)\n\n\n\n\n\n\nsource\ntarget\n\n\n\n\ngenerator_out\naggregator_stat\n\n\nscheduler_out\naggregator_poke\n\n\naggregator_alert\nnotifier_in\n\n\n\n\n\nNow we’re seeing the wiring: who talks to whom, and through what channels."
  },
  {
    "objectID": "core/async/flow/exploration.html#running-the-flow",
    "href": "core/async/flow/exploration.html#running-the-flow",
    "title": "Core Async Flow Exploration",
    "section": "3. Running the Flow",
    "text": "3. Running the Flow\nTime to bring our flow to life! Calling start activates the processes and returns a map of the important channels for interaction.\n\n(def chs (flow/start stats-flow))\n\nWe can now inject values into specific points in the flow. Think of this like poking the system and watching how it reacts.\nWe send a “poke” signal to the aggregator process.\nWe send a stat string that is designed to trigger an alert.\nWe send a notification message into the notifier."
  },
  {
    "objectID": "core/async/flow/exploration.html#observing-the-results",
    "href": "core/async/flow/exploration.html#observing-the-results",
    "title": "Core Async Flow Exploration",
    "section": "4. Observing the Results",
    "text": "4. Observing the Results\nOur flow includes a report-chan, where summaries and reports might be sent.\n\n(def report-chan (:report-chan chs))\n\n\n(flow/ping stats-flow)\n\n\n{:notifier\n #:clojure.core.async.flow{:pid :notifier,\n                           :status :paused,\n                           :state\n                           {:prefix \"Alert: \",\n                            :clojure.core.async.flow/pid :notifier},\n                           :count 0,\n                           :ins\n                           {:in\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}},\n                           :outs {}},\n :scheduler\n #:clojure.core.async.flow{:pid :scheduler,\n                           :status :paused,\n                           :state\n                           {:wait 3000,\n                            :clojure.core.async.flow/pid :scheduler,\n                            :clojure.core.async.flow/in-ports\n                            {:alarm\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 10}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:alarm\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}},\n :aggregator\n #:clojure.core.async.flow{:pid :aggregator,\n                           :status :paused,\n                           :state\n                           {:min 1,\n                            :max 10,\n                            :clojure.core.async.flow/pid :aggregator,\n                            :vals []},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}},\n                            :poke\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:alert\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}}},\n :generator\n #:clojure.core.async.flow{:pid :generator,\n                           :status :paused,\n                           :state\n                           {:min 0,\n                            :max 12,\n                            :wait 500,\n                            :clojure.core.async.flow/pid :generator,\n                            :clojure.core.async.flow/in-ports\n                            {:stat\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 100}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 100}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}}}\n\n\n(async/poll! report-chan)\n\n\nnil\n\nAfter pinging the system, we check if anything landed in the report channel.\nWe can also inspect the error-chan, where any issues in the flow are reported.\n\n(def error-chan (:error-chan chs))\n\n\n(async/poll! error-chan)\n\n\nnil\n\nIf something unexpected occurred (e.g., bad input or failed routing), this is where we’d find it.\n(flow/stop stats-flow) (async/close! stat-chan)\n@(flow/inject stats-flow [:aggregator :poke] [true])"
  },
  {
    "objectID": "core/async/flow/exploration.html#summary",
    "href": "core/async/flow/exploration.html#summary",
    "title": "Core Async Flow Exploration",
    "section": "Summary",
    "text": "Summary\nBy constructing, inspecting, and interacting with a flow, we can understand the lifecycle and structure of asynchronous systems more clearly.\nThis toolset provides a bridge between the abstract beauty of DAGs and the gritty realism of channel communication—unlocking both power and clarity in asynchronous Clojure code.\nHappy flowing!\n\nsource: notebooks/core/async/flow/exploration.clj"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "An open effort to structure learning resources with meaningful connections.\nClojure Civitas is a contributor-friendly platform that makes it easy for you to share Clojure ideas and explorations, without the overhead of setting up a new project, blog, or repo. Whether you’re sketching out a quick experiment or writing a deeper post, Civitas gives you a shared scratch space where publishing is simple. Just open a namespace, write, and submit. No infrastructure required.\n\n\n\n\nNavigate your own path through interconnected topics.\n\n\n\n\n\nWrite notebooks and situate them in a broader context by linking ideas.\n\n\n\n\n\nThe best resources rise through collective refinement.\n\n\n\n“Civitas” refers to a community of citizens, encompassing the rights, duties, and privileges associated with belonging. It’s a term that signifies citizenship, not just a physical city, but also the political and social fabric of the community.\n\n\nSee README.md.\n\n\n\nClojure and markdown are a natural fit for interactive, literate programming. But there is incidental complexity in setup and publishing. Creating a new project, configuring a blog, choosing themes and styling, organizing files, adding analytics, and thinking about SEO all add overhead. This friction discourages experimentation and makes publishing harder than it needs to be.\n\n\nNotebooks combine Clojure and markdown for expressive, interactive literate programming. Compared to blogs, gists, or repos, they better support combining narrative, code, and results in a single document. Civitas removes the friction of publishing by enabling you to submit notebooks or markdown without setting up a new project or hosting workflow. It provides a shared, well-organized platform for short experiments, tutorials, notes, and blog posts.\n\n\n\nCivitas aggregates structured metadata about the content it hosts and links it to other Clojure resources. Instead of scattered, unstructured articles, Civitas supports a connected web of ideas, showing how concepts relate, what builds on what, and where to go next. Its hex-grid interface presents these relationships visually. Each notebook can declare prerequisites, alternatives, and follow-ups. This helps learners discover next steps, helps educators design coherent learning paths, and enables the community to improve content over time. The goal is to make the Clojure knowledge ecosystem easier to explore and navigate.\n\n\n\nClojure Civitas does not aim to centralize all Clojure knowledge. Instead, it offers a flexible publishing pattern that individuals and communities can adopt. Civitas can also be used as a library to help you publish your own content garden, independent of the main site.\n\n\n\n\n\n\n\nAll content is submitted via Pull Requests, which are reviewed to prevent abuse. A small team of reviewers ensures quick turnaround. Community representatives are available to assist and guide contributors.\n\n\n\nMetadata is currently provided by authors. Future improvements may include automated extraction and smarter linking to enrich the knowledge base.\n\n\n\nPage view analytics are publicly available. See the Clojure Civitas Analytics Dashboard.\n\n\n\nMade with Clay. See the README.md in the repository for contribution guidelines and technical details."
  },
  {
    "objectID": "about.html#usage",
    "href": "about.html#usage",
    "title": "About",
    "section": "",
    "text": "See README.md."
  },
  {
    "objectID": "about.html#rationale",
    "href": "about.html#rationale",
    "title": "About",
    "section": "",
    "text": "Clojure and markdown are a natural fit for interactive, literate programming. But there is incidental complexity in setup and publishing. Creating a new project, configuring a blog, choosing themes and styling, organizing files, adding analytics, and thinking about SEO all add overhead. This friction discourages experimentation and makes publishing harder than it needs to be.\n\n\nNotebooks combine Clojure and markdown for expressive, interactive literate programming. Compared to blogs, gists, or repos, they better support combining narrative, code, and results in a single document. Civitas removes the friction of publishing by enabling you to submit notebooks or markdown without setting up a new project or hosting workflow. It provides a shared, well-organized platform for short experiments, tutorials, notes, and blog posts.\n\n\n\nCivitas aggregates structured metadata about the content it hosts and links it to other Clojure resources. Instead of scattered, unstructured articles, Civitas supports a connected web of ideas, showing how concepts relate, what builds on what, and where to go next. Its hex-grid interface presents these relationships visually. Each notebook can declare prerequisites, alternatives, and follow-ups. This helps learners discover next steps, helps educators design coherent learning paths, and enables the community to improve content over time. The goal is to make the Clojure knowledge ecosystem easier to explore and navigate.\n\n\n\nClojure Civitas does not aim to centralize all Clojure knowledge. Instead, it offers a flexible publishing pattern that individuals and communities can adopt. Civitas can also be used as a library to help you publish your own content garden, independent of the main site."
  },
  {
    "objectID": "about.html#how-it-works",
    "href": "about.html#how-it-works",
    "title": "About",
    "section": "",
    "text": "All content is submitted via Pull Requests, which are reviewed to prevent abuse. A small team of reviewers ensures quick turnaround. Community representatives are available to assist and guide contributors.\n\n\n\nMetadata is currently provided by authors. Future improvements may include automated extraction and smarter linking to enrich the knowledge base.\n\n\n\nPage view analytics are publicly available. See the Clojure Civitas Analytics Dashboard.\n\n\n\nMade with Clay. See the README.md in the repository for contribution guidelines and technical details."
  },
  {
    "objectID": "scicloj/noj/intro/getting-started-noj.html",
    "href": "scicloj/noj/intro/getting-started-noj.html",
    "title": "Noj Reload Executable",
    "section": "",
    "text": "Transcript of Noj Reload Executable\nHello code champs, number ninjas and data divers!\nImagine being able to experiment with Clojure without needing to install tooling, set up editors, or even know about deps.edn Sounds like a dream, right? Well, dream no more—meet Noj’s new Code Reload Executable!\n\n\n\nNoj\n\n\nWe can skip the Clojure tooling and editor setup, but we do need to install the recommended Adoptive Java. Now we download the latest Noj jar from the Scicloj Noj GitHub releases page. Let’s check the jar is in the Downloads directory, and that we have java installed by executing java -version.\nLaunch Noj using java -jar and the path to the jar file. Pro tip, if you press tab while typing a path, it will autocomplete. Noj is running, it created a directory called notebooks, and it recommends we create a Clojure file there.\nI’ll create my file with Notepad, being careful to create a .clj file rather than a text file. When I saved that file, a browser window opened. Let’s put them side by side. Every time I save the file, the notebook updates.\nIf I’m interested in one particular top-level form, I can narrow the output by adding ,, anywhere in the form. And removing it renders the full notebook. And check this out—comments are rendered as Markdown. How cool is that? What an easy way to get coding!\nNoj isn’t just a notebook—it’s a fully featured data science environment. It includes interesting datasets that can be queried and the results shown as tables or even better as charts.\nNoj makes experimenting with Clojure easier than ever. No setup headaches, no complicated tooling—just pure coding joy.\nUntil next time, Keep on coding"
  },
  {
    "objectID": "civitas/explorer.html",
    "href": "civitas/explorer.html",
    "title": "Civitas Explorer",
    "section": "",
    "text": "(defn html [s content]\n  [:foreignObject {:x      (- s)\n                   :y      (- s)\n                   :width  (* 2 s)\n                   :height (* 2 s)}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width           \"100%\"\n                  :height          \"100%\"\n                  :text-align      :center\n                  :display         :flex\n                  :justify-content :center\n                  :align-items     :center\n                  :overflow        :visible}}\n    content]])\n\n\n(comment\n  (kind/hiccup [:div (for [i (range 10)]\n                       (/ i 0))]))\n\nOfficial Clojure DocumentationClojure for the Brave and TrueTransducers ExplainedClojureScript GuideReagent Documentationre-frame: A React FrameworkLuminus Web FrameworkTablecloth: Dataframe LibraryNotespace Live Notebookstech.ml Machine Learningdeps.edn ReferenceCIDER for Emacsshadow-cljs Build ToolKaocha Test RunnerSciCloj CommunityClojureCamp EventsClojureTV YouTubeClojurians SlackPracticalli TutorialsJVM Performance GuideComponent LibrarynREPL ProtocolDatomic DatabaseXTDB Documentation\n\n\nidtitleurlformattopicsleveldepends-onclj-docsOfficial Clojure Documentationhttps://clojure.org/guides/getting_startedreference[:core]\n0brave-clojureClojure for the Brave and Truehttps://www.braveclojure.com/interactive-book[:core :core/fp]\n1transducersTransducers Explainedhttps://www.youtube.com/watch?v=6mTbuzafcIIvideo[:core :core/fp]\n2[\"clj-docs\"]\nreagent-docsReagent Documentationhttps://reagent-project.github.io/library-docs[:web :web/frontend]\n1re-framere-frame: A React Frameworkhttps://day8.github.io/re-frame/library-docs[:web :web/frontend]\n2[\"reagent-docs\"]\nluminusLuminus Web Frameworkhttps://luminusweb.com/framework[:web :web/backend]\n2tableclothTablecloth: Dataframe Libraryhttps://github.com/scicloj/tableclothlibrary-docs[:data :data/analysis]\n1notespaceNotespace Live Notebookshttps://github.com/scicloj/notespaceinteractive-tool[:data :data/viz]\n2tech.mltech.ml Machine Learninghttps://github.com/techascent/tech.mllibrary-docs[:data :data/ml]\n3deps-edndeps.edn Referencehttps://clojure.org/reference/deps_and_clireference[:tooling]\n0ciderCIDER for Emacshttps://docs.cider.mx/tool-docs[:tooling :tooling/repl]\n1shadow-cljsshadow-cljs Build Toolhttps://shadow-cljs.github.io/docs/UsersGuide.htmltool-docs[:tooling :tooling/build]\n2sciclojSciCloj Communityhttps://scicloj.github.io/community[:community :community/orgs]\n0clojure-campClojureCamp Eventshttps://clojurecamp.berlin/community[:community :community/events]\n1clojure-tvClojureTV YouTubehttps://www.youtube.com/user/ClojureTVvideo-channel[:community :community/learning]\n0clojuriansClojurians Slackhttps://clojurians.net/community[:community :community/chat]\n0practicalliPracticalli Tutorialshttps://practical.li/tutorials[:community :community/learning]\n1jvm-tuningJVM Performance Guidehttps://clojure.org/reference/jvm_programmingguide[:systems :systems/production]\n3componentComponent Libraryhttps://github.com/stuartsierra/componentlibrary-docs[:systems :systems/design]\n2nreplnREPL Protocolhttps://nrepl.org/protocol[:systems :systems/tooling]\n2datomicDatomic Databasehttps://docs.datomic.com/cloud/database[:systems :systems/data :data/db]\n3clojurescriptClojureScript Guidehttps://clojurescript.org/reference[:core :web :tooling]\n1kaochaKaocha Test Runnerhttps://github.com/lambdaisland/kaochatool-docs[:tooling :tooling/testing]\n2xtdbXTDB Documentationhttps://xtdb.com/database[:systems :systems/data :data/db]\n3\n\n\n\nsource: notebooks/civitas/explorer.clj"
  },
  {
    "objectID": "graph/layout/elk.html",
    "href": "graph/layout/elk.html",
    "title": "Eclipse Layout Kernel",
    "section": "",
    "text": "(defn ^ElkNode elk [g]\n  (-&gt; (json/write-str g)\n      (ElkGraphJson/forGraph)\n      (.toElk)))\n\n\n(defn unelk [^ElkNode g]\n  (-&gt; (ElkGraphJson/forGraph g)\n      (.toJson)\n      (json/read-str {:key-fn keyword})))\n\n\n(defn layout [g]\n  (let [g (elk g)]\n    (.layout (RecursiveGraphLayoutEngine.) g (BasicProgressMonitor.))\n    (unelk g)))\n\nExample\n\n(-&gt; {:id            \"root\",\n     :layoutOptions {:elk.algorithm         \"layered\"\n                     :elk.direction         \"DOWN\"\n                     :elk.hierarchyHandling \"INCLUDE_CHILDREN\"},\n     :children      [{:id       \"node1\",\n                      ;; node1 label is hidden under node2\n                      ;; can treat labels as nodes as a workaround,\n                      ;; or label outside/above, or something\n                      ;; groups label outside, nodes inside\n                      :labels   [{:text \"node1\"}]\n                      :width    50,\n                      :height   50,\n                      :children [{:id     \"node2\",\n                                  :labels [{:text \"node2\"}]\n                                  :width  20,\n                                  :height 20}]}\n                     {:id     \"node3\",\n                      :labels [{:text \"node3\"}]\n                      :width  50,\n                      :height 50}]}\n    (layout)\n    (elk-svg/render-graph)\n    (delay))\n\nnode1node2node3\nTODO: Maybe these are only for layered\n\n(def algorithm-k \"org.eclipse.elk.algorithm\")\n\n\n(def default-layout-algorithm \"org.eclipse.elk.layered\")\n\n\n(def default-layout-options\n  {\"org.eclipse.elk.algorithm\"                                    \"org.eclipse.elk.layered\"\n   \"org.eclipse.elk.direction\"                                    \"DOWN\"\n   \"org.eclipse.elk.hierarchyHandling\"                            \"INCLUDE_CHILDREN\"\n   \"org.eclipse.elk.interactive\"                                  true\n   \"org.eclipse.elk.layered.cycleBreaking.strategy\"               \"DEPTH_FIRST\"\n   \"org.eclipse.elk.layered.crossingMinimization.strategy\"        \"LAYER_SWEEP\"\n   \"org.eclipse.elk.layered.crossingMinimization.semiInteractive\" true\n   \"org.eclipse.elk.radial.compactor\"                             \"RADIAL_COMPACTION\"})\n\n\nsource: notebooks/graph/layout/elk.clj"
  },
  {
    "objectID": "pages.html",
    "href": "pages.html",
    "title": "Pages",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nPrinting Objects in Clojure\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nFlow to ELK data transformation\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nEclipse Layout Kernel\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nELK SVG\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCivitas Explorer\n\n\n\n\n\n\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nClean object printing by removing extraneous\n\n\n\n\n\n\n\n\nJun 5, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nThe Hallway Track: SciNoj Light #1 Data Analysis Stories\n\n\n\n\n\n\n\n\nMay 28, 2025\n\n\nTimothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nFactorization of Eratosthenes\n\n\n\n\n\n\n\n\nMay 28, 2025\n\n\nTim Schafer\n\n\n\n\n\n\n\n\n\n\n\n\nThe Z-Combinator Gambit\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nChris Houser, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Visualization\n\n\n\n\n\n\n\n\nMay 17, 2025\n\n\nDaniel Slutsky, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Exploration\n\n\n\n\n\n\n\n\nMay 16, 2025\n\n\nDaniel Slutsky, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nCore Async Flow Stats Example\n\n\n\n\n\n\n\n\nMay 15, 2025\n\n\nAlex Miller, Timothy Pratley\n\n\n\n\n\n\n\n\n\n\n\n\nNoj Reload Executable\n\n\n\n\n\n\n\n\nMay 6, 2025\n\n\nTimothy Pratley\n\n\n\n\n\nNo matching items"
  }
]