[
  {
    "objectID": "pages/scicloj/noj/intro/getting-started-noj.html",
    "href": "pages/scicloj/noj/intro/getting-started-noj.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "Hello code champs, number ninjas and data divers!\nImagine being able to experiment with Clojure without needing to install tooling, set up editors, or even know about deps.edn Sounds like a dream, right? Well, dream no more—meet Noj’s new Code Reload Executable! We can skip the Clojure tooling and editor setup, but we do need to install the recommended Adoptive Java. Now we download the latest Noj jar from the scicloj noj github releases page. Let’s check the jar is in the Downloads directory, and that we have java installed by executing java -version. Launch Noj using java -jar and the path to the jar file. Pro tip, if you press tab while typing a path, it will autocomplete. Noj is running, it created a directory called notebooks, and it recommends we create a clojure file there. I’ll create my file with Notepad, being careful to create a .clj file rather than a text file. When I saved that file, a browser window opened. Let’s put them side by side. Every time I save the file, the notebook updates. If I’m interested in one particular top-level form, I can narrow the output by adding ,, anywhere in the form. And removing it renders the full notebook. And check this out—comments are rendered as Markdown. How cool is that? What an easy way to get coding!\nNoj isn’t just a notebook—it’s a fully featured data science environment. It includes interesting datasets that can be queried and the results shown as tables or even better as charts.\nNoj makes experimenting with Clojure easier than ever. No setup headaches, no complicated tooling—just pure coding joy.\nUntil next time, Keep on coding"
  },
  {
    "objectID": "ideas/clojure/plus/print/objects/objects_and_protocols.html",
    "href": "ideas/clojure/plus/print/objects/objects_and_protocols.html",
    "title": "Printing Objects in Clojure",
    "section": "",
    "text": "^{:clay {:title \"Printing Objects in Clojure\"}}\n(ns clojure.plus.print.objects.objects-and-protocols\n  (:require [clojure.core.async :as async]\n            [clojure.datafy :as datafy]\n            [clojure.string :as str]\n            [core.async.flow.example.stats :as stats]))\n\n\nPrinting Objects in Clojure\nThe Clojure default for printing objects is noisy:\n\n(Object.)\n\n\n#object[java.lang.Object 0x22765b84 \"java.lang.Object@22765b84\"]\n\nThe syntax is #object[CLASS-NAME HASH toString())] and as you can see, the toString of an Object is CLASS-NAME@HASH. This can get pretty ugly:\n\n(async/chan)\n\n\n#object[clojure.core.async.impl.channels.ManyToManyChannel 0x38979973 \"clojure.core.async.impl.channels.ManyToManyChannel@38979973\"]\n\nclojure-plus provides print-methods to improve printing many things.\n\n(require 'clojure+.print)\n\n\n^:kind/hidden\n(clojure+.print/install-printers!)\n\nOnce activated, we can print functions, atoms, namespaces, and more sensibly\n\ninc\n\n\n#fn clojure.core/inc\n\n\n(atom {})\n\n\n#atom {}\n\n\n*ns*\n\n\n#ns clojure.plus.print.objects.objects-and-protocols\n\nClojure Plus adds printers for many types, but no printer is provided for Object, which remains as Clojure’s default printing method. There are plenty of objects left over that print messily. Going back to our channel example, it still prints the same:\n\n(async/chan)\n\n\n#object[clojure.core.async.impl.channels.ManyToManyChannel 0x4918cd02 \"clojure.core.async.impl.channels.ManyToManyChannel@4918cd02\"]\n\nIt’s not hard to provide an Object print-method:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object \")\n  (.write w (.getName (class x))))\n\n\n#multifn print-method\n\n\n(async/chan)\n\n\n#object clojure.core.async.impl.channels.ManyToManyChannel\n\nMuch nicer! In my opinion this is a big improvement. Especially in the world of notebooks where we like to show things as we go, but also just keeping a tidy REPL or looking into data that contains objects.\n\n(stats/create-flow)\n\n\n#object clojure.core.async.flow.impl$create_flow$reify__43364\n\nHmmmm. not so nice. We’ll dig into this further below. But we also need to be aware that Clojure munges it’s names to make Java valid names. This matters for some things:\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class)\n    (.getName))\n\n\n\"clojure.plus.print.objects.objects_and_protocols$eval47390$_PERCENT__PERCENT___47391$_PERCENT__PERCENT__PERCENT___47392\"\n\nWhoa, that’s pretty gross. We’d prefer to demunge the names at least.\n\n(defn class-name\n  [x]\n  (-&gt; x class .getName Compiler/demunge))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name))\n\n\n\"clojure.plus.print.objects.objects-and-protocols/eval47397/%%--47398/%%%--47399\"\n\nNotice the /evalNNNNN/ part? To create a function, Clojure creates a new class. The /evalNNNNN/ counts every time it evaluates. This is useful in the sense that it identifies the class for that evaluation. But we almost never care for that detail (more on that later). For the same reason our strangely named functions have --NNNNN appended to them, because they are sub evaluations of the top-level evaluation.\nLet’s do away with that noise for the moment:\n\n(defn remove-extraneous\n  \"Clojure compiles with unique names that include things like `/eval32352/` and `--4321`.\n  These are rarely useful when printing a function.\n  They can still be accessed via (class x) or similar.\"\n  [s]\n  (-&gt; s\n      (str/replace #\"/eval\\d+/\" \"/\")\n      (str/replace #\"--\\d+(/|$)\" \"$1\")))\n\n\n(-&gt; ((fn %% [] (fn %%% [])))\n    (class-name)\n    (remove-extraneous))\n\n\n\"clojure.plus.print.objects.objects-and-protocols/%%/%%%\"\n\nLooking better, I can actually see the (strange) name of the functions.\nNotice now that the string is not a valid symbol? That’s a problem if we follow the style of clojure-plus because it prints as tagged literals.\n#object clojure.plus.print.objects.objects-and-protocols/%%/%%% is not a valid Clojure expression. In a sense it doesn’t matter much if we are just printing, but it tends to confuse tools (and people). So I recommend replacing all slashes after the namespace delimiter with $ instead. While we are at it… the namespace isn’t helping us at all here. Let’s just show the name without the namespace.\n\n(defn format-class-name [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str/join \"$\" names)\n      s)))\n\n\n(-&gt; (((fn aaa [] (fn bbb [] (fn ccc [])))))\n    (class-name)\n    (format-class-name))\n\n\n\"aaa$bbb$ccc\"\n\nThat’s really all we need. Notice there is no / slash if we don’t show the namespace, but we still can’t use / because functions can nest arbitrarily.\nSide note about including or omitting the namespace. There are many ways to get whatever representation you want, so changing the printing behavior doesn’t prevent anything. The question is just would you like to see it or not? I would argue that it’s almost never useful, just a distraction. On the other hand, the current behavior for printing vars is fully qualified. Whatever your preference on showing the namespace, it should probably be consistent across printers.\nI’ll assume you prefer including the namespace\n\n(defn format-class-name [s]\n  (let [[ns-str & names] (-&gt; (remove-extraneous s)\n                             (str/split #\"/\"))]\n    (if (and ns-str names)\n      (str ns-str \"/\" (str/join \"$\" names))\n      s)))\n\nLet’s hook this up to the print-method for Object:\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object \")\n  (.write w (-&gt; (class-name x) (format-class-name))))\n\n\n#multifn print-method\n\nNotably this doesn’t change function etc… because they are still using the clojure-plus print-method:\n\n(((fn aaa [] (fn bbb [] (fn ccc [])))))\n\n\n#fn clojure.plus.print.objects.objects-and-protocols/eval47432/aaa--47433/bbb--47434/ccc--47435\n\nIn my opinion, the fn and multi print-methods of clojure-plus should be changed to the cleaner output.\nBut it matters for our reify example:\n\n(stats/create-flow)\n\n\n#object clojure.core.async.flow.impl/create-flow$reify\n\nWhat is this? It’s a reified object that implements protocols. We can see this by the $reify part at the end. The description is not terrible, at least we know where it was made, which hints that it must be a flow. Can we do better?\nAFAIK the only way to check what protocols an object satisfies is to call satisfies? for every possible protocol:\n\n(defn all-protocol-vars [x]\n  (-&gt;&gt; (all-ns)\n       (mapcat ns-publics)\n       (vals)\n       (keep #(-&gt; % meta :protocol))\n       (distinct)\n       (filter #(satisfies? @% x))))\n\nOn the one hand, this is concerning for performance. On the other hand, at my REPL I don’t care about that, it’s faster than I can notice. Leaving aside those concerns, it returns quite a long list…\n\n(def stats-flow\n  (stats/create-flow))\n\n\n(all-protocol-vars stats-flow)\n\n\n(#'charred.api/PToJSON\n #'taoensso.nippy/IFreezable\n #'taoensso.nippy/IFreezableWithMeta\n #'clojure.core.reducers/CollFold\n #'clojure.core.async.flow.impl.graph/Graph\n #'hiccup.compiler/HtmlRenderer\n #'clj-yaml.core/YAMLCodec\n #'portal.runtime.jvm.editor/IResolve\n #'clojure.tools.reader.reader-types/PushbackReaderCoercer\n #'clojure.tools.reader.reader-types/ReaderCoercer\n #'clojure.java.io/IOFactory\n #'tech.v3.io.protocols/IOProvider\n #'tech.v3.io.protocols/ICopyObject\n #'clojure.data.json/JSONWriter\n #'hiccup.util/ToString\n #'hiccup.util/URLEncode\n #'portal.runtime.cson/ToJson\n #'tech.v3.dataset.protocols/PMissing\n #'tech.v3.dataset.protocols/PReducerCombiner\n #'tech.v3.dataset.protocols/PDataset\n #'tech.v3.dataset.protocols/PColumnName\n #'tech.v3.dataset.protocols/PColumn\n #'tech.v3.dataset.protocols/PColumnCount\n #'tech.v3.dataset.protocols/PDatasetReducer\n #'tech.v3.dataset.protocols/PRowCount\n #'clojure.spec.alpha/Specize\n #'ham-fisted.protocols/Reduction\n #'ham-fisted.protocols/BulkSetOps\n #'ham-fisted.protocols/SetOps\n #'ham-fisted.protocols/BitSet\n #'ham-fisted.protocols/ToIterable\n #'ham-fisted.protocols/Finalize\n #'ham-fisted.protocols/ParallelReduction\n #'ham-fisted.protocols/ToCollection\n #'ham-fisted.protocols/ParallelReducer\n #'tech.v3.datatype.index-algebra/PIndexAlgebra\n #'clojure.core.protocols/Navigable\n #'clojure.core.protocols/Datafiable\n #'clojure.core.protocols/CollReduce\n #'clojure.core.protocols/InternalReduce\n #'clojure.core.protocols/IKVReduce\n #'tech.v3.datatype.protocols/PToReader\n #'tech.v3.datatype.protocols/POperator\n #'tech.v3.datatype.protocols/PCopyRawData\n #'tech.v3.datatype.protocols/PToNativeBuffer\n #'tech.v3.datatype.protocols/PSetConstant\n #'tech.v3.datatype.protocols/PToBuffer\n #'tech.v3.datatype.protocols/PTensor\n #'tech.v3.datatype.protocols/PSubBuffer\n #'tech.v3.datatype.protocols/POperationalElemwiseDatatype\n #'tech.v3.datatype.protocols/PConstantTimeMinMax\n #'tech.v3.datatype.protocols/PToWriter\n #'tech.v3.datatype.protocols/PElemwiseReaderCast\n #'tech.v3.datatype.protocols/PToArrayBuffer\n #'tech.v3.datatype.protocols/PDatatype\n #'tech.v3.datatype.protocols/PECount\n #'tech.v3.datatype.protocols/PToBitmap\n #'tech.v3.datatype.protocols/PRangeConvertible\n #'tech.v3.datatype.protocols/PElemwiseCast\n #'tech.v3.datatype.protocols/PClone\n #'tech.v3.datatype.protocols/PApplyUnary\n #'tech.v3.datatype.protocols/PElemwiseDatatype\n #'tech.v3.datatype.protocols/PShape\n #'tech.v3.datatype.protocols/PToTensor\n #'reitit.impl/IntoString\n #'fipp.ednize/IEdn)\n\nBut notice that one of them; #'clojure.core.async.flow.impl.graph/Graph just feels like it is the one we care about most. Furthermore, it shares a similar namespace with the classname. Let’s try matching by the namespace…\n\n(defn var-ns-name [v]\n  (-&gt; (meta v) (:ns) (ns-name)))\n\n\n(defn ns-match? [p x]\n  (-&gt; (var-ns-name p)\n      (str/starts-with? (.getPackageName (class x)))))\n\n\n(defn protocol-ns-matches [x]\n  (filter #(ns-match? % x) (all-protocol-vars x)))\n\n\n(protocol-ns-matches stats-flow)\n\n\n(#'clojure.core.async.flow.impl.graph/Graph)\n\nNice. In my opinion this is more representative of the object. The #' out front is unnecessary and can be removed…\n\n(defn var-sym [v]\n  (let [m (meta v)]\n    (symbol (str (ns-name (:ns m))) (str (:name m)))))\n\n\n(defn protocol-ns-match-names [x]\n  (-&gt;&gt; (protocol-ns-matches x)\n       (map var-sym)))\n\n\n(protocol-ns-match-names stats-flow)\n\n\n(clojure.core.async.flow.impl.graph/Graph)\n\nThe other protocol of interest is Datafiable, because it indicates I can get a data representation if I would like to.\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans {}}\n\nI think this one is so helpful that it should always be shown on objects, regardless of their type of other protocols, as a hint that it is possible to get more information. I wouldn’t want to print them as data by default, because it would be too spammy. And checking Datafiable is much less of a performance concern.\n\n(satisfies? clojure.core.protocols/Datafiable stats-flow)\n\n\ntrue\n\nBut there is a big problem… everything is Datafiable…\n\n(satisfies? clojure.core.protocols/Datafiable (Object.))\n\n\ntrue\n\nSo there is no way for us to know whether datafy/datafy will do anything useful or not. Sad. But we can improve the print-method to show protocols, bearing in mind it is a performance concern.\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (let [class-name (.getName (class x))\n        r (str/includes? class-name \"$reify\")\n        p (when r (first (protocol-ns-match-names x)))]\n    (.write w (if p\n                \"#reify \"\n                \"#object \"))\n    (.write w (if p\n                (str p)\n                class-name))))\n\n\n#multifn print-method\n\n\n(stats/create-flow)\n\n\n#reify clojure.core.async.flow.impl.graph/Graph\n\nShowing the reified protocol isn’t a big improvement, and probably not worth the performance. Probably not worth including in clojure-plus.\nEven if we don’t care to improve reify (due to performance), I think the Object printer should still be improved to align with the other printers. Let’s go back to the basic Object print-method without protocol detection.\n\n(defmethod print-method Object [x ^java.io.Writer w]\n  (.write w \"#object \")\n  (.write w (-&gt; (class-name x) (format-class-name))))\n\n\n#multifn print-method\n\nO.K. Are we giving up anything? Remember we removed the unique identifiers like /evalNNNNN/. When would those be useful? Hold onto your hats! We are about to try to find an Object by it’s class-name:\n\n(defn find-class [class-name]\n  (try\n    (Class/forName class-name false (clojure.lang.RT/baseLoader))\n    (catch ClassNotFoundException _ nil)))\n\n\n(defn ddd [x] (inc x))\n\n\n(type (find-class (-&gt; ddd (class) (.getName))))\n\n\njava.lang.Class\n\nWhy would you want to do that? I don’t know, but it’s pretty cool you have to admit. What’s also interesting is that we can get all Clojure classes: https://danielsz.github.io/2021-05-12T13_24.html\n\n(defn class-cache []\n  (some-&gt; (.getDeclaredField clojure.lang.DynamicClassLoader \"classCache\")\n          (doto (.setAccessible true))\n          (.get nil)))\n\n\n(key (first (class-cache)))\n\n\n\"tech.v3.datatype.protocols$set_and_not\"\n\nAnd we can find them in memory a similar way:\n\n(defn find-in-memory-class\n  \"Finds a class by name in the DynamicClassLoader's memory cache\"\n  [class-name]\n  (let [method (.getDeclaredMethod clojure.lang.DynamicClassLoader\n                                   \"findInMemoryClass\"\n                                   (into-array Class [String]))\n        _ (.setAccessible method true)]\n    (.invoke method nil (into-array Object [class-name]))))\n\nRight, but why would you want to do that? Honestly I can’t imagine a reason. All of that to say, do we really want those unique identifiers printed out? No! If we need to find them, we can always look them up another way. We don’t need them polluting our REPL output.\n\nsource: content/ideas/clojure/plus/print/objects/objects_and_protocols.clj"
  },
  {
    "objectID": "posts/core/async/flow/example/stats.html",
    "href": "posts/core/async/flow/example/stats.html",
    "title": "Core async flow stats example",
    "section": "",
    "text": "(ns core.async.flow.example.stats\n  (:require\n    [clojure.core.async :as a]\n    [clojure.core.async.flow :as flow]\n    [clojure.core.async.flow-monitor :as mon]))\n\n\nCore async flow stats example\nAdapted from https://github.com/puredanger/flow-example\n\n^:kind/video\n{:youtube-id   \"lXFwf3O4BVY\"\n :iframe-width \"100%\"}\n\n\n\n(defn stat-gen\n  \"Generates a random value between min (inclusive) and max (exclusive)\n  and writes it to out chan, waiting wait ms between until stop-atom is flagged.\"\n  ([out min max wait stop-atom]\n   (loop []\n     (let [val (+ min (rand-int (- max min)))\n           put (a/&gt;!! out val)]\n       ;(println \"stat-gen\" (System/identityHashCode stop-atom) val put (not @stop-atom))\n       (when (and put (not @stop-atom))\n         (^[long] Thread/sleep wait)\n         (recur))))))\n\n\n(defn source\n  \"Source proc for random stats\"\n  ;; describe\n  ([] {:params {:min  \"Min value to generate\"\n                :max  \"Max value to generate\"\n                :wait \"Time in ms to wait between generating\"}\n       :outs   {:out \"Output channel for stats\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:stat (a/chan 100)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [min max wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"transition\" transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (stat-gen (:stat in-ports) min max wait stop-atom))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   ;(println \"source transform\" in msg)\n   [state (when (= in :stat) {:out [msg]})]))\n\n\n(defn aggregator\n  ;; describe\n  ([] {:params   {:min \"Min value, alert if lower\"\n                  :max \"Max value, alert if higher\"}\n       :ins      {:stat \"Channel to receive stat values\"\n                  :poke \"Channel to poke when it is time to report a window of data to the log\"}\n       :outs     {:alert \"Notify of value out of range {:val value, :error :high|:low\"}\n       :workload :compute\n       })\n\n  ;; init\n  ([args] (assoc args :vals []))\n\n  ;; transition\n  ([state transition] state)\n\n  ;; transform\n  ([{:keys [min max vals] :as state} input-id msg]\n   (case input-id\n     :stat (let [state' (assoc state :vals (conj vals msg))\n                 msgs (cond\n                        (&lt; msg min) {:alert [{:val msg, :error :low}]}\n                        (&lt; max msg) {:alert [{:val msg, :error :high}]}\n                        :else nil)]\n             [state' msgs])\n     :poke [(assoc state :vals [])\n            {:clojure.core.async.flow/report (if (empty? vals)\n                             [{:count 0}]\n                             [{:avg   (/ (double (reduce + vals)) (count vals))\n                               :count (count vals)}])}]\n     [state nil])))\n\n\n(comment\n  ;; test aggregator alert case - no channels involved\n  (let [state {:min 1 :max 5 :vals []}\n        [state' msgs'] (aggregator state :stat 100)]\n    (assert (= msgs' {:alert [{:val 100, :error :high}]})))\n  )\n\n\n(defn scheduler\n  ;; describe\n  ([] {:params {:wait \"Time to wait between pokes\"}\n       :outs   {:out \"Poke channel, will send true when the alarm goes off\"}})\n\n  ;; init\n  ([args]\n   (assoc args\n     :clojure.core.async.flow/in-ports {:alarm (a/chan 10)}\n     :stop (atom false)))\n\n  ;; transition\n  ([{:keys [wait :clojure.core.async.flow/in-ports] :as state} transition]\n   ;(println \"scheduler transition\" transition state transition)\n   (case transition\n     :clojure.core.async.flow/resume\n     (let [stop-atom (atom false)]\n       (future (loop []\n                 (let [put (a/&gt;!! (:alarm in-ports) true)]\n                   (when (and put (not @stop-atom))\n                     (^[long] Thread/sleep wait)\n                     (recur)))))\n       (assoc state :stop stop-atom))\n\n     (:clojure.core.async.flow/pause :clojure.core.async.flow/stop)\n     (do\n       (reset! (:stop state) true)\n       state)))\n\n  ;; transform\n  ([state in msg]\n   [state (when (= in :alarm) {:out [true]})]))\n\n\n(defn printer\n  ;; describe\n  ([] {:params {:prefix \"Log message prefix\"}\n       :ins    {:in \"Channel to receive messages\"}})\n\n  ;; init\n  ([state] state)\n\n  ;; transition\n  ([state _transition] state)\n\n  ;; transform\n  ([{:keys [prefix] :as state} _in msg]\n   (println prefix msg)\n   [state nil]))\n\n\n(def config\n  {:procs {:generator  {:args {:min 0 :max 12 :wait 500} :proc (flow/process #'source)}\n           :aggregator {:args {:min 1 :max 10} :proc (flow/process #'aggregator)}\n           :scheduler  {:args {:wait 3000} :proc (flow/process #'scheduler)}\n           :notifier   {:args      {:prefix \"Alert: \"} :proc (flow/process #'printer)\n                        :chan-opts {:in {:buf-or-n (a/sliding-buffer 3)}}}}\n   :conns [[[:generator :out] [:aggregator :stat]]\n           [[:scheduler :out] [:aggregator :poke]]\n           [[:aggregator :alert] [:notifier :in]]]})\n\n\n(defn create-flow\n  []\n  (flow/create-flow config))\n\n\n(comment\n  (def f (create-flow))\n  (def chs (flow/start f))\n  (flow/resume f)\n  (flow/pause f)\n  (flow/stop f)\n\n  (def server (mon/start-server {:flow f}))\n  (mon/stop-server server)\n\n  @(flow/inject f [:aggregator :poke] [true])\n  @(flow/inject f [:aggregator :stat] [\"abc1000\"])          ;; trigger an alert\n  @(flow/inject f [:notifier :in] [:sandwich])\n\n  (def report-chan (:report-chan chs))\n  (flow/ping f)\n  (a/poll! report-chan)\n  (def error-chan (:error-chan chs))\n  (a/poll! error-chan)\n\n  (flow/stop f)\n  (a/close! stat-chan)\n\n  @(flow/inject f [:aggregator :poke] [true])\n\n  (require '[clojure.datafy :as datafy])\n  (datafy/datafy f)\n\n  (require '[clojure.core.async.flow-static :refer [graph]])\n  (graph f)\n\n  )\n\n\nsource: content/posts/core/async/flow/example/stats.clj"
  },
  {
    "objectID": "posts/core/async/flow/exploration.html",
    "href": "posts/core/async/flow/exploration.html",
    "title": "Visualizing core.async.flows",
    "section": "",
    "text": "(ns core.async.flow.exploration\n  (:require [clojure.core.async :as async]\n            [clojure.string :as str]\n            [core.async.flow.example.stats :as stats]\n            [clojure.core.async.flow :as flow]\n            [clojure.datafy :as datafy]))"
  },
  {
    "objectID": "posts/core/async/flow/exploration.html#what-well-explore",
    "href": "posts/core/async/flow/exploration.html#what-well-explore",
    "title": "Visualizing core.async.flows",
    "section": "What We’ll Explore",
    "text": "What We’ll Explore\n\nBasic flow structure (processes, channels, connections)\nStatic visualization of a sample flow\nEvolution as the flow changes\n\n\n(defn id-for [x]\n  (cond (keyword? x) (str (symbol x))\n        (vector? x) (str/join \"_\" (map id-for x))\n        (string? x) x\n        :else (str x)))\n\n\n(defn conn-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ;; TODO: add channel state\n    ^:kind/table\n    {:row-maps (vec (for [[from to] conns]\n                      {:source (id-for from)\n                       :target (id-for to)}))}))\n\n\n(defn proc-table [flow]\n  (let [{:keys [conns procs]} (datafy/datafy flow)\n        all-proc-chans (into #{} cat conns)]\n    ^:kind/table\n    {:column-names [\"process\" \"start params\" \"in chans\" \"out chans\"]\n     :row-vectors  (for [[proc-key proc-chans] (group-by first all-proc-chans)]\n                     (let [{:keys [args proc]} (get procs proc-key)\n                           {:keys [desc]} proc\n                           {:keys [params ins outs]} desc]\n                       [(name proc-key)\n                        ^:kind/hiccup\n                        [:div\n                         (for [[k param] params]\n                           [:div\n                            [:div [:strong (name k)] \": \" (get args k)]\n                            [:div param]])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] ins]\n                                [:div [:strong (name k)] \": \" v])]\n                        ^:kind/hiccup\n                        [:div (for [[k v] outs]\n                                [:div [:strong (name k)] \": \" v])]]))}))\n\n\n(def stats-flow\n  (flow/create-flow stats/config))\n\n\n(proc-table stats-flow)\n\n\n\n\n\n\n\n\n\n\n\n\nprocess\nstart params\nin chans\nout chans\n\n\n\n\nnotifier\n\n\n\nprefix: Alert:\n\n\nLog message prefix\n\n\n\n\n\nin: Channel to receive messages\n\n\n\n\n\n\n\naggregator\n\n\n\nmin: 1\n\n\nMin value, alert if lower\n\n\n\n\nmax: 10\n\n\nMax value, alert if higher\n\n\n\n\n\nstat: Channel to receive stat values\n\n\npoke: Channel to poke when it is time to report a window of data to the log\n\n\n\n\nalert: Notify of value out of range {:val value, :error :high|:low\n\n\n\n\nscheduler\n\n\n\nwait: 3000\n\n\nTime to wait between pokes\n\n\n\n\n\n\n\n\nout: Poke channel, will send true when the alarm goes off\n\n\n\n\ngenerator\n\n\n\nmin: 0\n\n\nMin value to generate\n\n\n\n\nmax: 12\n\n\nMax value to generate\n\n\n\n\nwait: 500\n\n\nTime in ms to wait between generating\n\n\n\n\n\n\n\n\nout: Output channel for stats\n\n\n\n\n\n\n\nwould be more interesting if we show the buffer state\n\n(conn-table stats-flow)\n\n\n\n\n\n\nsource\ntarget\n\n\n\n\ngenerator_out\naggregator_stat\n\n\nscheduler_out\naggregator_poke\n\n\naggregator_alert\nnotifier_in\n\n\n\n\n\n\n(def chs (flow/start stats-flow))\n\ntrigger an alert\n\n(def report-chan (:report-chan chs))\n\n\n(flow/ping stats-flow)\n\n\n{:notifier\n #:clojure.core.async.flow{:pid :notifier,\n                           :status :paused,\n                           :state\n                           {:prefix \"Alert: \",\n                            :clojure.core.async.flow/pid :notifier},\n                           :count 0,\n                           :ins\n                           {:in\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}},\n                           :outs {}},\n :aggregator\n #:clojure.core.async.flow{:pid :aggregator,\n                           :status :paused,\n                           :state\n                           {:min 1,\n                            :max 10,\n                            :clojure.core.async.flow/pid :aggregator,\n                            :vals []},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}},\n                            :poke\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:alert\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type SlidingBuffer,\n                              :count 0,\n                              :capacity 3}}}},\n :generator\n #:clojure.core.async.flow{:pid :generator,\n                           :status :paused,\n                           :state\n                           {:min 0,\n                            :max 12,\n                            :wait 500,\n                            :clojure.core.async.flow/pid :generator,\n                            :clojure.core.async.flow/in-ports\n                            {:stat\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 100}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:stat\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 100}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}},\n :scheduler\n #:clojure.core.async.flow{:pid :scheduler,\n                           :status :paused,\n                           :state\n                           {:wait 3000,\n                            :clojure.core.async.flow/pid :scheduler,\n                            :clojure.core.async.flow/in-ports\n                            {:alarm\n                             {:put-count 0,\n                              :take-count 0,\n                              :closed? false,\n                              :buffer\n                              {:type FixedBuffer,\n                               :count 0,\n                               :capacity 10}}},\n                            :stop [false]},\n                           :count 0,\n                           :ins\n                           {:alarm\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}},\n                           :outs\n                           {:out\n                            {:put-count 0,\n                             :take-count 0,\n                             :closed? false,\n                             :buffer\n                             {:type FixedBuffer,\n                              :count 0,\n                              :capacity 10}}}}}\n\n\n(async/poll! report-chan)\n\n\nnil\n\n\n(def error-chan (:error-chan chs))\n\n\n(async/poll! error-chan)\n\n\nnil\n\n(flow/stop stats-flow) (async/close! stat-chan)\n@(flow/inject stats-flow [:aggregator :poke] [true])\n\n(datafy/datafy stats-flow)\n\n\n{:procs\n {:generator\n  {:args {:min 0, :max 12, :wait 500},\n   :proc\n   {:step core.async.flow.example.stats/source,\n    :desc\n    {:params\n     {:min \"Min value to generate\",\n      :max \"Max value to generate\",\n      :wait \"Time in ms to wait between generating\"},\n     :outs {:out \"Output channel for stats\"}}}},\n  :aggregator\n  {:args {:min 1, :max 10},\n   :proc\n   {:step core.async.flow.example.stats/aggregator,\n    :desc\n    {:params\n     {:min \"Min value, alert if lower\",\n      :max \"Max value, alert if higher\"},\n     :ins\n     {:stat \"Channel to receive stat values\",\n      :poke\n      \"Channel to poke when it is time to report a window of data to the log\"},\n     :outs\n     {:alert\n      \"Notify of value out of range {:val value, :error :high|:low\"},\n     :workload :compute}}},\n  :scheduler\n  {:args {:wait 3000},\n   :proc\n   {:step core.async.flow.example.stats/scheduler,\n    :desc\n    {:params {:wait \"Time to wait between pokes\"},\n     :outs\n     {:out \"Poke channel, will send true when the alarm goes off\"}}}},\n  :notifier\n  {:args {:prefix \"Alert: \"},\n   :proc\n   {:step core.async.flow.example.stats/printer,\n    :desc\n    {:params {:prefix \"Log message prefix\"},\n     :ins {:in \"Channel to receive messages\"}}},\n   :chan-opts\n   {:in {:buf-or-n {:type SlidingBuffer, :count 0, :capacity 3}}}}},\n :conns\n [[[:generator :out] [:aggregator :stat]]\n  [[:scheduler :out] [:aggregator :poke]]\n  [[:aggregator :alert] [:notifier :in]]],\n :execs {:mixed nil, :io nil, :compute nil},\n :chans\n {:ins\n  {[:aggregator :stat]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :poke]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:notifier :in]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}}},\n  :outs\n  {[:generator :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}},\n   [:aggregator :alert]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type SlidingBuffer, :count 0, :capacity 3}},\n   [:scheduler :out]\n   {:put-count 0,\n    :take-count 0,\n    :closed? false,\n    :buffer {:type FixedBuffer, :count 0, :capacity 10}}},\n  :error\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}},\n  :report\n  {:put-count 0,\n   :take-count 0,\n   :closed? false,\n   :buffer {:type SlidingBuffer, :count 0, :capacity 100}}}}\n\n\nsource: content/posts/core/async/flow/exploration.clj"
  },
  {
    "objectID": "posts/beating_code_interviews_with_stupid_stuff/z_combinator_gambit.html",
    "href": "posts/beating_code_interviews_with_stupid_stuff/z_combinator_gambit.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "(ns beating-code-interviews-with-stupid-stuff.z-combinator-gambit)\n\nMost obvious solution\n\n(defn REV [LIST]\n  (if (empty? LIST)\n    []\n    (conj (REV (rest LIST))\n          (first LIST))))\n\n\n(REV [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nSee any issues? (stack overflow, and mutability hehehehe)\nExtract the pattern (don’t rely on REV)\n\n(def REV'\n  (fn [SELF LIST]\n    (if (empty? LIST)\n      []\n      (conj (SELF SELF (rest LIST))\n            (first LIST)))))\n\n\n(REV' REV' [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nSELF is an input to the function. REV’ decouples the recursive logic from the function name.\nWhat about Fib?\nOh no, our definition of reverse is intertwined with recursion. Let’s factor that out:\nWe need to introduce some scope\n\n(def REV''\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\nerror\nOh no… SELF isn’t a function that takes a list, it’s a function that returns that function that operates on LIST, and the argument to SELF is… SELF. Therefore, we need (SELF SELF).\n\n(def REV''\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj ((SELF SELF) (rest LIST))\n              (first LIST))))))\n\n\n((REV'' REV'') [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nThat’s a confusing way to write it\nQuite right, because it’s not obvious what (SELF SELF) is… we need to extract it out. What we want is:\n\n(def REV-LOGIC\n  (fn [SELF]\n    (fn [LIST]\n      (if (empty? LIST)\n        []\n        (conj (SELF (rest LIST))\n              (first LIST))))))\n\n\nBelieve me when I say that’s not what I meant… Oh right… now SELF = (SELF SELF) and that’s impossible. Not what I meant, but also not true, consider (identity identity)\n\n\n((identity identity) 1)\n\n\n1\n\n=&gt; 1\n\n(((identity identity) (identity identity)) 1)\n\n\n1\n\n=&gt;1\n\nWhy did you do that? Never-mind So I agree it’s not impossible, we just need to find the right conditions for (SELF SELF) = SELF So what is (SELF SELF) in this brave new world you suggested Not remotely what I’m talking about…\n\n\n(REV-LOGIC REV-LOGIC)\n\n\n#object[beating_code_interviews_with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__46821 0x6b3846d9 \"beating_code_interviews_with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__46821@6b3846d9\"]\n\nWell, it’s a function! That much is clear… &gt; Oh no what are you doing now\nbut it doesn’t work, because (REV-LOGIC REV-LOGIC) not= REV-LOGIC. let’s try something easier:\n\n(def fix\n  (fn [logic]\n    ;; return something like identity where self application does not change it\n    #_fixed))\n\nwhere fix takes the logic function, and makes a function such that (fixed (fix logic)) = fixed (fixed fixed) =&gt; fixed which means that ((fix f) (fix f)) = (fix f) &gt; Right, that sounds way easier… shaking head Exactly! because we just reverse it (fix f) = ((fix f) (fix f)) &gt; why did you call it fix? well, it was broken before right? &gt; I still think it’s broken\n\n(def fix\n  (fn [logic]\n    ((fix logic) (fix logic))))\n\nbut fix can still see itself, we need to parameterize the use of fixed\n\n(def fix\n  (fn [logic]\n    ((fn [fixed]\n       (logic (fixed fixed)))\n     (fn [fixed]\n       (logic (fixed fixed))))))\n\nThere, I lifted it out. &gt; what is fixed? fixed is (fixed fixed) obviously &gt; why? because (fix f) = ((fix f) (fix f)), it was your idea remember? &gt; huh?? this just looks inside out to me\n\nyour right, it is inside out. well of course, before logic gets called, fixed is calling fixed is calling fixed infinitely we can’t pass (fixed fixed) as an argument because it will be evaluated first. Thanks for the tip. &gt; can we fix it?  Instead of calling (fixed fixed) we need a function that will create (fixed fixed) when it’s needed, after logic gets called. logic needs to take itself as it’s argument, so the function we pass to logic should look very much like logic, but of course without any actual logic in it. &gt; very logical logic is a function of itself, returning a function that acts on a value:\n\ndidn’t you say that (fixed fixed) = fixed? Yes but only after we fix it. fixing it requires us to go from fixed to (fixed fixed) remember? ah sure… so while we are fixing logic, let’s replace (logic (fixed fixed)) with our deferring function\n\n\n(def fix\n  (fn [logic]\n    ((fn [fixed]\n       (logic (fn self [v]\n                ((fixed fixed) v))))\n     (fn [fixed]\n       (logic (fn self [v]\n                ((fixed fixed) v)))))))\n\ndid you know this is called continuation passing style? &gt; CSP? No that’s communicating subprocesses &gt; that’s confusing. Isn’t it?\nFortunately, we are about to be unconfused!\n\n(fix REV-LOGIC)\n\n\n#object[beating_code_interviews_with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__46821 0x378cccc8 \"beating_code_interviews_with_stupid_stuff.z_combinator_gambit$REV_LOGIC$fn__46821@378cccc8\"]\n\n\nat least it didn’t blow up\n\n\n((fix REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nI can’t believe something so ridiculous actually worked you’re right, all those silly names, let’s fix that\n\n\n(def Z\n  (fn [f]\n    ((fn [x]\n       (f (fn [v] ((x x) v))))\n     (fn [x]\n       (f (fn [v] ((x x) v)))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nYay, what has this got to do with Fibonacci? We’re factoring out our logic remember? It looks to me like you doubled the code, that’s not great refactoring Hmmm you got me there, there does seem to be a lot of doubling. What if we had a function for f =&gt; (f f)\n\n\n(def W\n  (fn [f]\n    (f f)))\n\n\n(def Z\n  (fn [f]\n    (W (fn [x]\n         (f (fn [v] ((x x) v)))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\n\nThat’s not really better… O.K. we can keep extracting\n\n\n(def E\n  (fn [f]\n    (fn [v]\n      ((f f) v))))\n\n\n(def Z\n  (fn [f]\n    (W (fn [x]\n         (f (E x))))))\n\n\n((Z REV-LOGIC) [1 2 3 4 5])\n\n\n[5 4 3 2 1]\n\n=&gt; [5 4 3 2 1]\nThat’s much nicer, I’m so glad you suggested it &gt; Can we write Fibonacci?\nOh that’s easy now!\n\n(def FIB-LOGIC\n  (fn [SELF]\n    (fn [[b a :as fibs]]\n      (if (&gt; b 10)\n        fibs\n        (SELF (concat [(+ a b) b] fibs))))))\n\n\n((Z FIB-LOGIC) [1 1])\n\n\n(13 8 8 5 5 3 3 2 2 1 1 1)\n\n=&gt; (13 8 8 5 5 3 3 2 2 1 1 1)\n\nThat’s all backward!! Oh my mistake\n\n\n((Z REV-LOGIC) ((Z FIB-LOGIC) [1 1]))\n\n\n[1 1 1 2 2 3 3 5 5 8 8 13]\n\n=&gt; [1 1 1 2 2 3 3 5 5 8 8 13] &gt; You can’t be serious… &gt; this is ridiculous &gt; we’ll be here forever if you keep this up I love where you’re head is at with this challenge an infinite sequence is exactly what we need…\n\n(def FIB-LOGIC-W\n  (fn [SELF]\n    (fn [A]\n      (fn [B]\n        (lazy-seq\n          (cons A ((SELF B) (+ A B))))))))\n\n\n(take 20 (((Z FIB-LOGIC-W) 1) 1))\n\n\n(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\n\n=&gt; (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)\nthat’s so nice &gt; nice it is not.\n\nsource: content/posts/beating_code_interviews_with_stupid_stuff/z_combinator_gambit.clj"
  },
  {
    "objectID": "pages/civitas/view/index.html",
    "href": "pages/civitas/view/index.html",
    "title": "Clojure Civitas",
    "section": "",
    "text": "(defn html [s content]\n  [:foreignObject {:x      (- s)\n                   :y      (- s)\n                   :width  (* 2 s)\n                   :height (* 2 s)}\n   [:div {:xmlns \"http://www.w3.org/1999/xhtml\"\n          :style {:width           \"100%\"\n                  :height          \"100%\"\n                  :text-align      :center\n                  :display         :flex\n                  :justify-content :center\n                  :align-items     :center\n                  :overflow        :visible}}\n    content]])\n\n\n(comment\n  (kind/hiccup [:div (for [i (range 10)]\n                       (/ i 0))]))\n\nOfficial Clojure DocumentationClojure for the Brave and TrueTransducers ExplainedClojureScript GuideReagent Documentationre-frame: A React FrameworkLuminus Web FrameworkTablecloth: Dataframe LibraryNotespace Live Notebookstech.ml Machine Learningdeps.edn ReferenceCIDER for Emacsshadow-cljs Build ToolKaocha Test RunnerSciCloj CommunityClojureCamp EventsClojureTV YouTubeClojurians SlackPracticalli TutorialsJVM Performance GuideComponent LibrarynREPL ProtocolDatomic DatabaseXTDB Documentation\n\n\nidtitleurlformattopicsleveldepends-onclj-docsOfficial Clojure Documentationhttps://clojure.org/guides/getting_startedreference[:core]\n0brave-clojureClojure for the Brave and Truehttps://www.braveclojure.com/interactive-book[:core :core/fp]\n1transducersTransducers Explainedhttps://www.youtube.com/watch?v=6mTbuzafcIIvideo[:core :core/fp]\n2[\"clj-docs\"]\nreagent-docsReagent Documentationhttps://reagent-project.github.io/library-docs[:web :web/frontend]\n1re-framere-frame: A React Frameworkhttps://day8.github.io/re-frame/library-docs[:web :web/frontend]\n2[\"reagent-docs\"]\nluminusLuminus Web Frameworkhttps://luminusweb.com/framework[:web :web/backend]\n2tableclothTablecloth: Dataframe Libraryhttps://github.com/scicloj/tableclothlibrary-docs[:data :data/analysis]\n1notespaceNotespace Live Notebookshttps://github.com/scicloj/notespaceinteractive-tool[:data :data/viz]\n2tech.mltech.ml Machine Learninghttps://github.com/techascent/tech.mllibrary-docs[:data :data/ml]\n3deps-edndeps.edn Referencehttps://clojure.org/reference/deps_and_clireference[:tooling]\n0ciderCIDER for Emacshttps://docs.cider.mx/tool-docs[:tooling :tooling/repl]\n1shadow-cljsshadow-cljs Build Toolhttps://shadow-cljs.github.io/docs/UsersGuide.htmltool-docs[:tooling :tooling/build]\n2sciclojSciCloj Communityhttps://scicloj.github.io/community[:community :community/orgs]\n0clojure-campClojureCamp Eventshttps://clojurecamp.berlin/community[:community :community/events]\n1clojure-tvClojureTV YouTubehttps://www.youtube.com/user/ClojureTVvideo-channel[:community :community/learning]\n0clojuriansClojurians Slackhttps://clojurians.net/community[:community :community/chat]\n0practicalliPracticalli Tutorialshttps://practical.li/tutorials[:community :community/learning]\n1jvm-tuningJVM Performance Guidehttps://clojure.org/reference/jvm_programmingguide[:systems :systems/production]\n3componentComponent Libraryhttps://github.com/stuartsierra/componentlibrary-docs[:systems :systems/design]\n2nreplnREPL Protocolhttps://nrepl.org/protocol[:systems :systems/tooling]\n2datomicDatomic Databasehttps://docs.datomic.com/cloud/database[:systems :systems/data :data/db]\n3clojurescriptClojureScript Guidehttps://clojurescript.org/reference[:core :web :tooling]\n1kaochaKaocha Test Runnerhttps://github.com/lambdaisland/kaochatool-docs[:tooling :tooling/testing]\n2xtdbXTDB Documentationhttps://xtdb.com/database[:systems :systems/data :data/db]\n3\n\n\n\nsource: content/pages/civitas/view/index.clj"
  }
]