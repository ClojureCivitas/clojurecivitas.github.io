---
description: Procedural generation of volumetric clouds using different types of noise
category: clojure
tags: [visualization]
format:
  html: {title: Volumetric Clouds with Clojure and LWJGL}
date: '2026-01-24'
type: post
author:
- name: Jan Wedekind
  url: https://www.wedesoft.de/
  image: https://avatars.githubusercontent.com/u/28663?v=4
  links:
  - {icon: github, href: 'https://github.com/wedesoft'}
draft: true
image: clouds.jpg

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.20.0/plotly.min.js" type="text/javascript"></script>

# Procedural generation of volumetric clouds

Volumetric clouds are commonly used in flight simulators and visual effects.
For a introductory video see [Sebastian Lague's video "Coding Adventure: Clouds](https://www.youtube.com/watch?v=4QOcCGI6xOU).
Note that this article is about procedural generation and not about simulating real weather.


## Worley noise

[Worley noise](https://en.wikipedia.org/wiki/Worley_noise) is a type of structured noise which is defined for each pixel using the distance to the nearest seed point.


### Noise parameters

First we define a function to create parameters of the noise.


* **size** is the size of each dimension of the noise array
* **divisions** is the number of subdividing cells in each dimension
* **dimensions** is the number of dimensions


::: {.sourceClojure}
```clojure
(defn make-noise-params
  [size divisions dimensions]
  {:size size :divisions divisions :cellsize (/ size divisions) :dimensions dimensions})
```
:::


Here is a corresponding Midje test.
Note that ideally you practise [Test Driven Development (TDD)](https://martinfowler.com/bliki/TestDrivenDevelopment.html), i.e. you start with writing one failing test.
Because this is a Clojure notebook, the unit tests are displayed after the implementation.


::: {.sourceClojure}
```clojure
(fact "Noise parameter initialisation"
      (make-noise-params 256 8 2) => {:size 256 :divisions 8 :cellsize 32 :dimensions 2})
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### 2D and 3D vectors

Next we need a function which allows us to create 2D or 3D vectors depending on the number of input parameters.


::: {.sourceClojure}
```clojure
(defn vec-n
  ([x y] (vec2 x y))
  ([x y z] (vec3 x y z)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Generic vector function for creating 2D and 3D vectors"
       (vec-n 2 3) => (vec2 2 3)
       (vec-n 2 3 1) => (vec3 2 3 1))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Random points

The following method generates a random point in a cell specified by the cell indices.


::: {.sourceClojure}
```clojure
(defn random-point-in-cell
  [{:keys [cellsize]} & indices]
  (let [random-seq (repeatedly #(rand cellsize))
        dimensions (count indices)]
    (add (mult (apply vec-n (reverse indices)) cellsize)
         (apply vec-n (take dimensions random-seq)))))
```
:::


We test the method by replacing the random function with a deterministic function.


::: {.sourceClojure}
```clojure
(facts "Place random point in a cell"
       (with-redefs [rand (fn [s] (* 0.5 s))]
         (random-point-in-cell {:cellsize 1} 0 0) => (vec2 0.5 0.5)
         (random-point-in-cell {:cellsize 2} 0 0) => (vec2 1.0 1.0)
         (random-point-in-cell {:cellsize 2} 0 3) => (vec2 7.0 1.0)
         (random-point-in-cell {:cellsize 2} 2 0) => (vec2 1.0 5.0)
         (random-point-in-cell {:cellsize 2} 2 3 5) => (vec3 11.0 7.0 5.0)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


We can now use the `random-point` method to generate a grid of random points.


::: {.sourceClojure}
```clojure
(defn random-points
  [{:keys [divisions dimensions] :as params}]
  (tensor/clone
    (tensor/compute-tensor (repeat dimensions divisions)
                           (partial random-point-in-cell params))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Greate grid of random points"
       (let [params-2d (make-noise-params 32 8 2)
             params-3d (make-noise-params 32 8 3)]
         (with-redefs [rand (fn [s] (* 0.5 s))]
           (dtype/shape (random-points params-2d)) => [8 8]
           ((random-points params-2d) 0 0) => (vec2 2.0 2.0)
           ((random-points params-2d) 0 3) => (vec2 14.0 2.0)
           ((random-points params-2d) 2 0) => (vec2 2.0 10.0)
           (dtype/shape (random-points params-3d)) => [8 8 8]
           ((random-points params-3d) 2 3 5) => (vec3 22.0 14.0 10.0))))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


Here is a scatter plot showing one random point placed in each cell.


::: {.sourceClojure}
```clojure
(let [points  (tensor/reshape (random-points (make-noise-params 256 8 2)) [(* 8 8)])
      scatter (tc/dataset {:x (map first points) :y (map second points)})]
  (-> scatter
      (plotly/base {:=title "Random points"})
      (plotly/layer-point {:=x :x :=y :y})))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[23.42585547694816,18.189507613376424,4.950576028223416,24.728709896750328,17.30017908201772,17.912957826343145,15.061376728832055,5.9565014104797065,57.590699345493704,60.59822635135083,60.614256037229275,56.188915755436284,38.67676798361539,47.55210430565813,60.452568732576495,49.584338275363216,72.08752123891344,77.21692137204286,65.89704278673725,85.01745833150615,78.9016878167404,95.36576790669605,77.83797409146666,90.79499532241007,100.43841585500546,113.7449780192576,116.93093471375731,105.63119770947668,118.86411700672585,102.78888580110478,126.52099663325612,105.50809867376884,139.3403201121717,144.0318412480076,159.9204768495737,142.0455455273587,141.337549944773,155.84249352330957,159.66518602465882,158.00598531261357,186.7402108713804,178.1053397902581,180.37420776731273,165.55902967318016,180.36749305681636,161.47454272969023,186.83818142669162,168.93077070122564,194.53529512000378,198.82500662704712,198.9611062035475,213.0628706062774,197.2841572681701,192.52572635059707,219.1806597116346,211.90641908314743,239.89821240627253,231.1603974359099,249.99203282398702,241.97554665359002,247.34015473176942,237.32029373064915,237.20027846644786,234.7858152773146],"r":null,"name":"","fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[6.078687412026984,49.218267994532326,86.05171083347139,116.55249553496435,154.64984010368676,179.72448799846975,192.24185815231,240.14642668995046,7.347892972139579,45.73671914313597,83.58035365914142,126.27800177123301,149.19757109671465,190.08950988452676,206.27502342989024,233.84681545619256,27.405271241567288,34.7881912025052,67.74400478757154,104.95310916039426,133.12581277342017,170.50463491481523,214.87957107425024,227.59372016873834,24.879583658151212,43.629653162577824,84.27484494626717,115.22717803359933,152.2450763226841,161.5070348372026,215.03840314502463,239.8329369169345,22.451813533055685,56.47422961980907,74.8217772453446,103.0897536533855,140.4986636050698,185.33466372057978,197.68483497546197,226.2982018802836,25.422551058875772,44.88670538011573,92.42406401522167,103.67232843530451,133.34254892085943,184.13426398179746,219.98873356821807,235.6254502354953,5.904374281392762,57.80403439992082,90.6099582370496,110.67509426214147,138.75026115248198,185.79437877726093,219.26764545789115,236.5920738584064,0.6392343796278865,35.18085044269449,70.12033695686193,105.41870706365215,129.84276747342562,169.40335764616154,192.522935259552,240.9811785360252],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"y","showgrid":true},"title":"Random points"}, {});</script></div>
```



### Modular distance

In order to get a periodic noise array, we need to component-wise wrap around distance vectors.


::: {.sourceClojure}
```clojure
(defn mod-vec
  [{:keys [size]} v]
  (let [size2 (/ size 2)
        wrap  (fn [x] (-> x (+ size2) (mod size) (- size2)))]
    (apply vec-n (map wrap v))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Wrap around components of vector to be within -size/2..size/2"
       (mod-vec {:size 8} (vec2 2 3)) => (vec2 2 3)
       (mod-vec {:size 8} (vec2 5 2)) => (vec2 -3 2)
       (mod-vec {:size 8} (vec2 2 5)) => (vec2 2 -3)
       (mod-vec {:size 8} (vec2 -5 2)) => (vec2 3 2)
       (mod-vec {:size 8} (vec2 2 -5)) => (vec2 2 3)
       (mod-vec {:size 8} (vec3 2 3 1)) => (vec3 2 3 1)
       (mod-vec {:size 8} (vec3 5 2 1)) => (vec3 -3 2 1)
       (mod-vec {:size 8} (vec3 2 5 1)) => (vec3 2 -3 1)
       (mod-vec {:size 8} (vec3 2 3 5)) => (vec3 2 3 -3)
       (mod-vec {:size 8} (vec3 -5 2 1)) => (vec3 3 2 1)
       (mod-vec {:size 8} (vec3 2 -5 1)) => (vec3 2 3 1)
       (mod-vec {:size 8} (vec3 2 3 -5)) => (vec3 2 3 3))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



Using the `mod-dist` function we can calculate the distance between two points in the periodic noise array.


::: {.sourceClojure}
```clojure
(defn mod-dist
  [params a b]
  (mag (mod-vec params (sub b a))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Wrapped distance of two points"
         (fact (mod-dist {:size 8} (vec2 ?ax ?ay) (vec2 ?bx ?by)) => ?result)
         ?ax ?ay ?bx ?by ?result
         0   0   0   0   0.0
         0   0   2   0   2.0
         0   0   5   0   3.0
         0   0   0   2   2.0
         0   0   0   5   3.0
         2   0   0   0   2.0
         5   0   0   0   3.0
         0   2   0   0   2.0
         0   5   0   0   3.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Modular lookup

We also need to lookup elements with wrap around.
We recursively use `tensor/select` and then finally the tensor as a function to lookup along each axis.


::: {.sourceClojure}
```clojure
(defn wrap-get
  [t & args]
  (if (> (count (dtype/shape t)) (count args))
    (apply tensor/select t (map mod args (dtype/shape t)))
    (apply t (map mod args (dtype/shape t)))))
```
:::


A tensor with index vectors is used to test the lookup.


::: {.sourceClojure}
```clojure
(facts "Wrapped lookup of tensor values"
       (let [t (tensor/compute-tensor [4 6] vec2)]
         (wrap-get t 2 3) => (vec2 2 3)
         (wrap-get t 2 7) => (vec2 2 1)
         (wrap-get t 5 3) => (vec2 1 3)
         (wrap-get (wrap-get t 5) 3) => (vec2 1 3)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


The following function converts a noise coordinate to the index of a cell in the random point array.


::: {.sourceClojure}
```clojure
(defn division-index
  [{:keys [cellsize]} x]
  (int (floor (/ x cellsize))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Convert coordinate to division index"
       (division-index {:cellsize 4} 3.5)  => 0
       (division-index {:cellsize 4} 7.5)  => 1
       (division-index {:cellsize 4} -0.5) => -1)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Getting indices of Neighbours

The following function determines the neighbouring indices of a cell recursing over each dimension.


::: {.sourceClojure}
```clojure
(defn neighbours
  [& args]
  (if (seq args)
    (mapcat (fn [v] (map (fn [delta] (into [(+ (first args) delta)] v)) [-1 0 1]))
            (apply neighbours (rest args)) )
    [[]]))
```
:::



::: {.sourceClojure}
```clojure
(facts "Get neighbouring indices"
       (neighbours) => [[]]
       (neighbours 0) => [[-1] [0] [1]]
       (neighbours 3) => [[2] [3] [4]]
       (neighbours 1 10) => [[0 9] [1 9] [2 9] [0 10] [1 10] [2 10] [0 11] [1 11] [2 11]])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Sampling Worley noise

Using above functions one can now implement Worley noise.
For each pixel the distance to the closest seed point is calculated.
The distance to each random point in all neighbouring cells is calculated and the minimum is taken.


::: {.sourceClojure}
```clojure
(defn worley-noise
  [{:keys [size dimensions] :as params}]
  (let [random-points (random-points params)]
    (tensor/clone
      (tensor/compute-tensor
        (repeat dimensions size)
        (fn [& coords]
            (let [center   (map #(+ % 0.5) coords)
                  division (map (partial division-index params) center)]
              (apply min
                     (for [neighbour (apply neighbours division)]
                          (mod-dist params (apply vec-n (reverse center))
                                    (apply wrap-get random-points neighbour))))))
        :double))))
```
:::


Here a 256x256 Worley noise tensor is created.


::: {.sourceClojure}
```clojure
(def worley (worley-noise (make-noise-params 256 8 2)))
```
:::


The values are inverted and normalised to be between 0 and 255.


::: {.sourceClojure}
```clojure
(def worley-norm
  (dfn/* (/ 255 (- (dfn/reduce-max worley) (dfn/reduce-min worley)))
         (dfn/- (dfn/reduce-max worley) worley)))
```
:::


Finally one can display the noise.


::: {.sourceClojure}
```clojure
(bufimg/tensor->image worley-norm)
```
:::


::: {.clay-image}
![](main_files/image0.png)
:::



## Perlin noise

[Perlin noise](https://adrianb.io/2014/08/09/perlinnoise.html) is generated by choosing a random gradient vector at each cell corner.
The noise tensor's intermediate values are interpolated with a continuous function, utilizing the gradient at the corner points.


### Random gradients

The 2D or 3D gradients are generated by creating a vector where each component is set to a random number between -1 and 1.
Random vectors are generated until the vector length is greater 0 and lower or equal to 1.
The vector then is normalized and returned.
Random vectors outside the unit circle or sphere are discarded in order to achieve a uniform distribution on the surface of the unit circle or sphere.


::: {.sourceClojure}
```clojure
(defn random-gradient
  [& args]
  (loop [args args]
        (let [random-vector (apply vec-n (map (fn [_x] (- (rand 2.0) 1.0)) args))
              vector-length (mag random-vector)]
          (if (and (> vector-length 0.0) (<= vector-length 1.0))
            (div random-vector vector-length)
            (recur args)))))
```
:::


The function below serves as a Midje checker for a vector with an approximate expected value.


::: {.sourceClojure}
```clojure
(defn roughly-vec
  [expected error]
  (fn [actual]
      (<= (mag (sub actual expected)) error)))
```
:::


In the following tests, the random function is again replaced with a deterministic function.


::: {.sourceClojure}
```clojure
(facts "Create unit vector with random direction"
       (with-redefs [rand (constantly 0.5)]
         (random-gradient 0 0)
         => (roughly-vec (vec2 (- (sqrt 0.5)) (- (sqrt 0.5))) 1e-6))
       (with-redefs [rand (constantly 1.5)]
         (random-gradient 0 0)
         => (roughly-vec (vec2 (sqrt 0.5) (sqrt 0.5)) 1e-6)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


The random gradient function is then used to generate a field of random gradients.


::: {.sourceClojure}
```clojure
(defn random-gradients
 [{:keys [divisions dimensions]}]
 (tensor/clone (tensor/compute-tensor (repeat dimensions divisions) random-gradient)))
```
:::


The function is tested that it generates 2D and 3D random gradient fields correctly.


::: {.sourceClojure}
```clojure
(facts "Random gradients"
       (with-redefs [rand (constantly 1.5)]
         (dtype/shape (random-gradients {:divisions 8 :dimensions 2}))
         => [8 8]
         ((random-gradients {:divisions 8 :dimensions 2}) 0 0)
         => (roughly-vec (vec2 (sqrt 0.5) (sqrt 0.5)) 1e-6)
         (dtype/shape (random-gradients {:divisions 8 :dimensions 3})) => [8 8 8]
         ((random-gradients {:divisions 8 :dimensions 3}) 0 0 0)
         => (vec3 (/ 1 (sqrt 3)) (/ 1 (sqrt 3)) (/ 1 (sqrt 3)))))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


The gradient field can be plotted with Plotly as a scatter plot of disconnected lines/


::: {.sourceClojure}
```clojure
(let [gradients (tensor/reshape (random-gradients (make-noise-params 256 8 2))
                                [(* 8 8)])
      points    (tensor/reshape (tensor/compute-tensor [8 8] (fn [y x] (vec2 x y)))
                                [(* 8 8)])
      scatter   (tc/dataset {:x (mapcat (fn [point gradient]
                                            [(point 0)
                                             (+ (point 0) (* 0.5 (gradient 0)))
                                             nil])
                                        points gradients)
                             :y (mapcat (fn [point gradient]
                                            [(point 1)
                                             (+ (point 1) (* 0.5 (gradient 1)))
                                             nil])
                                        points gradients)})]
  (-> scatter
      (plotly/base {:=title "Random gradients" :=mode "lines"})
      (plotly/layer-point {:=x :x :=y :y})))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,-0.20604936002203628,null,0.0,0.15863087919023647,null,0.0,-0.38085674430926364,null,0.0,0.4999952322475774,null,0.0,0.49896122067290766,null,0.0,0.4620479921178867,null,0.0,-0.4967620754481247,null,0.0,0.2861663871022829,null,1.0,0.5561035581092595,null,1.0,0.8794854493438875,null,1.0,0.5023510978381946,null,1.0,1.1147734779998841,null,1.0,1.3172216220698991,null,1.0,1.2925113717621732,null,1.0,1.0112994126167834,null,1.0,1.2966272296641015,null,2.0,1.930324927040028,null,2.0,1.6762709208065099,null,2.0,1.9736544837928423,null,2.0,1.5843483042620767,null,2.0,1.5574981400464725,null,2.0,2.1243591769536927,null,2.0,2.3112898781434685,null,2.0,1.6086687582437202,null,3.0,2.5110511386278627,null,3.0,2.883209548448048,null,3.0,3.327007025316867,null,3.0,3.4996457318979135,null,3.0,2.5531451244109484,null,3.0,3.4539580068409967,null,3.0,3.0237712303452655,null,3.0,2.6294921346023856,null,4.0,4.022458960608534,null,4.0,3.962791227393187,null,4.0,3.5247006460601287,null,4.0,3.720620458647807,null,4.0,4.2041832251573075,null,4.0,3.5639673862707104,null,4.0,4.4982593574891006,null,4.0,3.7428105582185895,null,5.0,5.4707657818602415,null,5.0,4.850514171988135,null,5.0,5.482401274376597,null,5.0,4.662394737778072,null,5.0,5.211720736349805,null,5.0,4.61596959479211,null,5.0,4.596018090714494,null,5.0,4.512705196737749,null,6.0,5.561748617744251,null,6.0,6.475508303727065,null,6.0,5.527581826337281,null,6.0,6.264397279259755,null,6.0,6.365721288944369,null,6.0,5.686262443223099,null,6.0,6.365904483257755,null,6.0,6.310197807040303,null,7.0,6.930384638284146,null,7.0,6.526560443669684,null,7.0,7.4964011763910765,null,7.0,6.5622140205456665,null,7.0,6.9216251721324165,null,7.0,7.275662472632201,null,7.0,6.502540684237719,null,7.0,7.27668785788522,null],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,-0.4555696008674298,null,1.0,1.4741690038027926,null,2.0,2.323957003804746,null,3.0,2.997816486846595,null,4.0,4.032213355376332,null,5.0,5.1910802265537415,null,6.0,6.056810565887621,null,7.0,7.410010730216694,null,0.0,-0.23012159585041211,null,1.0,1.4852589443587365,null,2.0,1.9515689131120322,null,3.0,3.4866487940474222,null,4.0,3.6135152752160287,null,5.0,4.594491556943864,null,6.0,6.499872306969006,null,7.0,7.402507498839215,null,0.0,-0.4951215852778211,null,1.0,1.3810504996513389,null,2.0,1.500694568649831,null,3.0,2.7220905402290363,null,4.0,3.7672080243271506,null,5.0,5.4842879258327635,null,6.0,5.608721823039637,null,7.0,7.311223166273798,null,0.0,0.10454191007864061,null,1.0,1.4861686851559768,null,2.0,2.378241200021116,null,3.0,2.981181323208093,null,4.0,3.7756771965173996,null,5.0,4.790423932604533,null,6.0,6.499434608940822,null,7.0,7.335743833418431,null,0.0,0.4994953404070796,null,1.0,1.4986135850948052,null,2.0,1.8447887757140577,null,3.0,3.414665011634498,null,4.0,3.5435909613467755,null,5.0,4.755305170131439,null,6.0,6.041684681533494,null,7.0,6.571218480999745,null,0.0,0.16846239529792836,null,1.0,0.522869004126113,null,2.0,2.1314876818558854,null,3.0,2.631187463716235,null,4.0,4.452961731054066,null,5.0,5.3201884568123345,null,6.0,5.705383949911012,null,7.0,6.888001005747354,null,0.0,-0.24069841285501906,null,1.0,0.8454301029093653,null,2.0,2.163771393085548,null,3.0,3.4243749270633685,null,4.0,4.340951519739786,null,5.0,5.389318308672558,null,6.0,5.659245089350314,null,7.0,6.607855485174933,null,0.0,-0.4951299843608451,null,1.0,1.1607948584431518,null,2.0,2.059882151577536,null,3.0,3.241543859771284,null,4.0,3.5061808161313226,null,5.0,4.582854700155568,null,6.0,5.949658872069417,null,7.0,7.416465880113711,null],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"y","showgrid":true},"title":"Random gradients"}, {});</script></div>
```



### Corner vectors

The next step is to determine the vectors to the corners of the cell for a given point.
First we define a function to determine the fractional part of a number.


::: {.sourceClojure}
```clojure
(defn frac
  [x]
  (mod x 1.0))
```
:::



::: {.sourceClojure}
```clojure
(facts "Fractional part of floating point number"
       (frac 0.25) => 0.25
       (frac 1.75) => 0.75
       (frac -0.25) => 0.75)
```
:::



::: {.printedClojure}
```clojure
true

```
:::


This function can be used to determine the relative position of a point in a cell.


::: {.sourceClojure}
```clojure
(defn cell-pos
  [{:keys [cellsize]} point]
  (apply vec-n (map frac (div point cellsize))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Relative position of point in a cell"
       (cell-pos {:cellsize 4} (vec2 2 3)) => (vec2 0.5 0.75)
       (cell-pos {:cellsize 4} (vec2 7 5)) => (vec2 0.75 0.25)
       (cell-pos {:cellsize 4} (vec3 7 5 2)) => (vec3 0.75 0.25 0.5))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


A tensor converting the corner vectors can be computed by subtracting the corner coordinates from the point coordinates.


::: {.sourceClojure}
```clojure
(defn corner-vectors
  [{:keys [dimensions] :as params} point]
  (let [cell-pos (cell-pos params point)]
    (tensor/compute-tensor
      (repeat dimensions 2)
      (fn [& args] (sub cell-pos (apply vec-n (reverse args)))))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Compute relative vectors from cell corners to point in cell"
       (let [v2 (corner-vectors {:cellsize 4 :dimensions 2} (vec2 7 6))
             v3 (corner-vectors {:cellsize 4 :dimensions 3} (vec3 7 6 5))]
         (v2 0 0) => (vec2 0.75 0.5)
         (v2 0 1) => (vec2 -0.25 0.5)
         (v2 1 0) => (vec2 0.75 -0.5)
         (v2 1 1) => (vec2 -0.25 -0.5)
         (v3 0 0 0) => (vec3 0.75 0.5 0.25)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Extract gradients of cell corners

The function below retrieves the gradient values at a cell's corners, utilizing `wrap-get` for modular access.


::: {.sourceClojure}
```clojure
(defn corner-gradients
  [{:keys [dimensions] :as params} gradients point]
  (let [division (map (partial division-index params) point)]
    (tensor/compute-tensor
      (repeat dimensions 2)
      (fn [& coords] (apply wrap-get gradients (map + (reverse division) coords))))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Get 2x2 tensor of gradients from a larger tensor using wrap around"
       (let [gradients2 (tensor/compute-tensor [4 6] (fn [y x] (vec2 x y)))
             gradients3 (tensor/compute-tensor [4 6 8] (fn [z y x] (vec3 x y z))) ]
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 0 0)
         => (vec2 2 1)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 0 1)
         => (vec2 3 1)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 1 0)
         => (vec2 2 2)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 1 1)
         => (vec2 3 2)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 23 15)) 1 1)
         => (vec2 0 0)
         ((corner-gradients {:cellsize 4 :dimensions 3} gradients3 (vec3 9 6 3)) 0 0 0)
         => (vec3 2 1 0)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Influence values

The influence value is the function value of the function with the selected random gradient at a corner.


::: {.sourceClojure}
```clojure
(defn influence-values
  [gradients vectors]
  (tensor/compute-tensor
    (repeat (count (dtype/shape gradients)) 2)
    (fn [& args] (dot (apply gradients args) (apply vectors args)))
    :double))
```
:::



::: {.sourceClojure}
```clojure
(facts "Compute influence values from corner vectors and gradients"
       (let [gradients2 (tensor/compute-tensor [2 2] (fn [_y x] (vec2 x 10)))
             vectors2   (tensor/compute-tensor [2 2] (fn [y _x] (vec2 1 y)))
             influence2 (influence-values gradients2 vectors2)
             gradients3 (tensor/compute-tensor [2 2 2] (fn [z y x] (vec3 x y z)))
             vectors3   (tensor/compute-tensor [2 2 2] (fn [_z _y _x] (vec3 1 10 100)))
             influence3 (influence-values gradients3 vectors3)]
         (influence2 0 0) => 0.0
         (influence2 0 1) => 1.0
         (influence2 1 0) => 10.0
         (influence2 1 1) => 11.0
         (influence3 1 1 1) => 111.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Interpolating the influence values

For interpolation the following "ease curve" is used.


::: {.sourceClojure}
```clojure
(defn ease-curve
  [t]
  (-> t (* 6.0) (- 15.0) (* t) (+ 10.0) (* t t t)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Monotonously increasing function with zero derivative at zero and one"
       (ease-curve 0.0) => 0.0
       (ease-curve 0.25) => (roughly 0.103516 1e-6)
       (ease-curve 0.5) => 0.5
       (ease-curve 0.75) => (roughly 0.896484 1e-6)
       (ease-curve 1.0) => 1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::


The ease curve monotonously increases in the interval from zero to one.


::: {.sourceClojure}
```clojure
(-> (tc/dataset {:t (range 0.0 1.025 0.025)
                 :ease (map ease-curve (range 0.0 1.025 0.025))})
    (plotly/base {:=title "Ease Curve"})
    (plotly/layer-line {:=x :t :=y :ease}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,1.5044921875000003E-4,0.001158125,0.003758378906250001,0.008560000000000002,0.01605224609375,0.026611875,0.04051017578124999,0.05791999999999999,0.07892279296874999,0.10351562499999996,0.13161822265624998,0.16308000000000003,0.19768708984375005,0.23516937500000007,0.27520751953125006,0.31744000000000017,0.36147013671875017,0.4068731250000002,0.4532030664062503,0.5000000000000001,0.5467969335937503,0.5931268750000003,0.6385298632812504,0.6825600000000003,0.7247924804687504,0.7648306250000004,0.8023129101562504,0.8369200000000006,0.8683817773437502,0.8964843750000004,0.9210772070312503,0.9420800000000003,0.9594898242187506,0.9733881249999998,0.9839477539062503,0.9914399999999999,0.9962416210937496,0.9988418749999993,0.9998495507812496,1.0000000000000013],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,0.025,0.05,0.07500000000000001,0.1,0.125,0.15000000000000002,0.17500000000000002,0.2,0.225,0.25,0.275,0.30000000000000004,0.325,0.35000000000000003,0.375,0.4,0.42500000000000004,0.45,0.47500000000000003,0.5,0.525,0.55,0.5750000000000001,0.6000000000000001,0.625,0.65,0.675,0.7000000000000001,0.7250000000000001,0.75,0.775,0.8,0.8250000000000001,0.8500000000000001,0.875,0.9,0.925,0.9500000000000001,0.9750000000000001,1.0],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"t","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"ease","showgrid":true},"title":"Ease Curve"}, {});</script></div>
```


The interpolation weights are recursively calculated from the ease curve and the coordinate distances of the point to upper and lower cell boundary.


::: {.sourceClojure}
```clojure
(defn interpolation-weights
  ([params point]
   (interpolation-weights (cell-pos params point)))
  ([pos]
   (if (seq pos)
     (let [w1   (- 1.0 (last pos))
           w2   (last pos)
           elem (interpolation-weights (butlast pos))]
       (tensor/->tensor [(dfn/* (ease-curve w1) elem) (dfn/* (ease-curve w2) elem)]))
     1.0)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Interpolation weights"
       (let [weights2 (interpolation-weights {:cellsize 8} (vec2 2 7))
             weights3 (interpolation-weights {:cellsize 8} (vec3 2 7 3))]
         (weights2 0 0) => (roughly 0.014391 1e-6)
         (weights2 0 1) => (roughly 0.001662 1e-6)
         (weights2 1 0) => (roughly 0.882094 1e-6)
         (weights2 1 1) => (roughly 0.101854 1e-6)
         (weights3 0 0 0) => (roughly 0.010430 1e-6)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Sampling Perlin noise

A Perlin noise sample is computed by

* Getting the random gradients for the cell corners.
* Getting the corner vectors for the cell corners.
* Computing the influence values which have the desired gradients.
* Determining the interpolation weights.
* Computing the weighted sum of the influence values.


::: {.sourceClojure}
```clojure
(defn perlin-sample
  [params gradients point]
  (let [gradients (corner-gradients params gradients point)
        vectors   (corner-vectors params point)
        influence (influence-values gradients vectors)
        weights   (interpolation-weights params point)]
    (dfn/reduce-+ (dfn/* weights influence))))
```
:::


Now one can sample the Perlin noise by performing above computation for the center of each pixel.


::: {.sourceClojure}
```clojure
(defn perlin-noise
  [{:keys [size dimensions] :as params}]
  (let [gradients (random-gradients params)]
    (tensor/clone
      (tensor/compute-tensor
        (repeat dimensions size)
        (fn [& args]
            (let [center (apply vec-n (map #(+ % 0.5) (reverse args)))]
              (perlin-sample params gradients center)))
        :double))))
```
:::


Here a 256x256 Perlin noise tensor is created.


::: {.sourceClojure}
```clojure
(def perlin (perlin-noise (make-noise-params 256 8 2)))
```
:::


The values are normalised to be between 0 and 255.


::: {.sourceClojure}
```clojure
(def perlin-norm
  (dfn/* (/ 255 (- (dfn/reduce-max perlin) (dfn/reduce-min perlin)))
         (dfn/- perlin (dfn/reduce-min perlin))))
```
:::


Finally one can display the noise.


::: {.sourceClojure}
```clojure
(bufimg/tensor->image perlin-norm)
```
:::


::: {.clay-image}
![](main_files/image1.png)
:::



## Mixing noise values


### Combination of Worley and Perlin noise

One can mix Worley and Perlin noise by simply doing a linear combination of the two.


::: {.sourceClojure}
```clojure
(def perlin-worley-norm (dfn/+ (dfn/* 0.3 perlin-norm) (dfn/* 0.7 worley-norm)))
```
:::


Here for example is the average of Perlin and Worley noise.


::: {.sourceClojure}
```clojure
(bufimg/tensor->image (dfn/+ (dfn/* 0.5 perlin-norm) (dfn/* 0.5 worley-norm)))
```
:::


::: {.clay-image}
![](main_files/image2.png)
:::



### Interpolation

One can linearly interpolate tensor values by recursing over the dimensions as follows.


::: {.sourceClojure}
```clojure
(defn interpolate
  [tensor & args]
  (if (seq args)
    (let [x  (first args)
          xc (- x 0.5)
          xf (frac xc)
          x0 (int (Math/floor xc))]
      (+ (* (- 1.0 xf) (apply interpolate (wrap-get tensor      x0 ) (rest args)))
         (*        xf  (apply interpolate (wrap-get tensor (inc x0)) (rest args)))))
    tensor))
```
:::


Here x-, y-,  and z-ramps are used to test that interpolation works.


::: {.sourceClojure}
```clojure
(facts "Interpolate values of tensor"
       (let [x2 (tensor/compute-tensor [4 6] (fn [_y x] x))
             y2 (tensor/compute-tensor [4 6] (fn [y _x] y))
             x3 (tensor/compute-tensor [4 6 8] (fn [_z _y x] x))
             y3 (tensor/compute-tensor [4 6 8] (fn [_z y _x] y))
             z3 (tensor/compute-tensor [4 6 8] (fn [z _y _x] z))]
         (interpolate x2 2.5 3.5) => 3.0
         (interpolate y2 2.5 3.5) => 2.0
         (interpolate x2 2.5 4.0) => 3.5
         (interpolate y2 3.0 3.5) => 2.5
         (interpolate x2 0.0 0.0) => 2.5
         (interpolate y2 0.0 0.0) => 1.5
         (interpolate x3 2.5 3.5 5.5) => 5.0
         (interpolate y3 2.5 3.5 3.0) => 3.0
         (interpolate z3 2.5 3.5 5.5) => 2.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Octaves of noise


::: {.sourceClojure}
```clojure
(defn fractal-brownian-motion
  [base octaves & args]
  (let [scales (take (count octaves) (iterate #(* 2 %) 1))]
    (reduce + 0.0
            (map (fn [amplitude scale] (* amplitude (apply base (map #(* scale %) args))))
                 octaves scales))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Fractal Brownian motion"
       (let [base1 (fn [x] (if (>= (mod x 2.0) 1.0) 1.0 0.0))
             base2 (fn [y x] (if (= (Math/round (mod y 2.0)) (Math/round (mod x 2.0)))
                               0.0 1.0))]
         (fractal-brownian-motion base2 [1.0] 0 0) => 0.0
         (fractal-brownian-motion base2 [1.0] 0 1) => 1.0
         (fractal-brownian-motion base2 [1.0] 1 0) => 1.0
         (fractal-brownian-motion base2 [1.0] 1 1) => 0.0
         (fractal-brownian-motion base2 [0.5] 0 1) => 0.5
         (fractal-brownian-motion base2 [] 0 1) => 0.0
         (fractal-brownian-motion base2 [0.0 1.0] 0 0) => 0.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.0 0.5) => 1.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.5 0.0) => 1.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.5 0.5) => 0.0
         (fractal-brownian-motion base1 [1.0] 0) => 0.0
         (fractal-brownian-motion base1 [1.0] 1) => 1.0
         (fractal-brownian-motion base1 [0.0 1.0] 0.0) => 0.0
         (fractal-brownian-motion base1 [0.0 1.0] 0.5) => 1.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn remap
  [value low1 high1 low2 high2]
  (dfn/+ low2 (dfn/* (dfn/- value low1) (/ (- high2 low2) (- high1 low1)))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Remap values of tensor"
       (fact ((remap (tensor/->tensor [?value]) ?low1 ?high1 ?low2 ?high2) 0)
             => ?expected)
       ?value ?low1 ?high1 ?low2 ?high2 ?expected
       0      0     1      0     1      0
       1      0     1      0     1      1
       0      0     1      2     3      2
       1      0     1      2     3      3
       2      2     3      0     1      0
       3      2     3      0     1      1
       1      0     2      0     4      2)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn clamp
  [value low high]
  (dfn/max low (dfn/min value high)))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Clamp values of tensor"
       (fact ((clamp (tensor/->tensor [?value]) ?low ?high) 0) => ?expected)
       ?value ?low ?high ?expected
       2      2    3      2
       3      2    3      3
       0      2    3      2
       4      2    3      3)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn octaves
  [n decay]
  (let [series (take n (iterate #(* % decay) 1.0))
        sum    (apply + series)]
    (mapv #(/ % sum) series)))
```
:::



::: {.sourceClojure}
```clojure
(octaves 4 0.5)
```
:::



::: {.printedClojure}
```clojure
[0.5333333333333333
 0.26666666666666666
 0.13333333333333333
 0.06666666666666667]

```
:::



::: {.sourceClojure}
```clojure
(defn noise-octaves
  [tensor octaves low high]
  (tensor/clone
    (clamp
      (remap
        (tensor/compute-tensor (dtype/shape tensor)
                               (fn [& args]
                                   (apply fractal-brownian-motion
                                     (partial interpolate tensor)
                                     octaves
                                     (map #(+ % 0.5) args)))
                               :double)
        low high 0 255)
      0 255)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves worley-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image3.png)
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves perlin-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image4.png)
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves perlin-worley-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image5.png)
:::



## Testing shaders


::: {.sourceClojure}
```clojure
(GLFW/glfwInit)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def window-width 640)
```
:::



::: {.sourceClojure}
```clojure
(def window-height 480)
```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwDefaultWindowHints)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwWindowHint GLFW/GLFW_VISIBLE GLFW/GLFW_FALSE)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(def window (GLFW/glfwCreateWindow window-width window-height "Invisible Window" 0 0))
```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwMakeContextCurrent window)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GL/createCapabilities)
```
:::



::: {.printedClojure}
```clojure
#object[org.lwjgl.opengl.GLCapabilities 0x39d3f717 "org.lwjgl.opengl.GLCapabilities@39d3f717"]

```
:::



::: {.sourceClojure}
```clojure
(defn make-shader [source shader-type]
  (let [shader (GL20/glCreateShader shader-type)]
    (GL20/glShaderSource shader source)
    (GL20/glCompileShader shader)
    (when (zero? (GL20/glGetShaderi shader GL20/GL_COMPILE_STATUS))
      (throw (Exception. (GL20/glGetShaderInfoLog shader 1024))))
    shader))
```
:::



::: {.sourceClojure}
```clojure
(defn make-program [& shaders]
  (let [program (GL20/glCreateProgram)]
    (doseq [shader shaders]
           (GL20/glAttachShader program shader)
           (GL20/glDeleteShader shader))
    (GL20/glLinkProgram program)
    (when (zero? (GL20/glGetProgrami program GL20/GL_LINK_STATUS))
      (throw (Exception. (GL20/glGetProgramInfoLog program 1024))))
    program))
```
:::



::: {.sourceClojure}
```clojure
(defn make-program-with-shaders
  [vertex-sources fragment-sources]
  (let [vertex-shaders   (map #(make-shader % GL20/GL_VERTEX_SHADER) vertex-sources)
        fragment-shaders (map #(make-shader % GL20/GL_FRAGMENT_SHADER) fragment-sources)
        program          (apply make-program (concat vertex-shaders fragment-shaders))]
    program))
```
:::



::: {.sourceClojure}
```clojure
(def vertex-test "
#version 130
in vec3 point;
void main()
{
  gl_Position = vec4(point, 1);
}")
```
:::



::: {.sourceClojure}
```clojure
(def fragment-test "
#version 130
out vec4 fragColor;
void main()
{
  fragColor = vec4(1, 1, 1, 1);
}")
```
:::



::: {.sourceClojure}
```clojure
(defmacro def-make-buffer [method create-buffer]
  `(defn ~method [data#]
     (let [buffer# (~create-buffer (count data#))]
       (.put buffer# data#)
       (.flip buffer#)
       buffer#)))
```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-float-buffer BufferUtils/createFloatBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-float-buffer

```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-int-buffer BufferUtils/createIntBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-int-buffer

```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-byte-buffer BufferUtils/createByteBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-byte-buffer

```
:::



::: {.sourceClojure}
```clojure
(defn setup-vao [vertices indices]
  (let [vao (GL30/glGenVertexArrays)
        vbo (GL15/glGenBuffers)
        ibo (GL15/glGenBuffers)]
    (GL30/glBindVertexArray vao)
    (GL15/glBindBuffer GL15/GL_ARRAY_BUFFER vbo)
    (GL15/glBufferData GL15/GL_ARRAY_BUFFER (make-float-buffer vertices)
                       GL15/GL_STATIC_DRAW)
    (GL15/glBindBuffer GL15/GL_ELEMENT_ARRAY_BUFFER ibo)
    (GL15/glBufferData GL15/GL_ELEMENT_ARRAY_BUFFER (make-int-buffer indices)
                       GL15/GL_STATIC_DRAW)
    {:vao vao :vbo vbo :ibo ibo}))
```
:::



::: {.sourceClojure}
```clojure
(defn teardown-vao [{:keys [vao vbo ibo]}]
  (GL15/glBindBuffer GL15/GL_ELEMENT_ARRAY_BUFFER 0)
  (GL15/glDeleteBuffers ibo)
  (GL15/glBindBuffer GL15/GL_ARRAY_BUFFER 0)
  (GL15/glDeleteBuffers vbo)
  (GL30/glBindVertexArray 0)
  (GL15/glDeleteBuffers vao))
```
:::



::: {.sourceClojure}
```clojure
(defn float-buffer->array
  "Convert float buffer to flaot array"
  [buffer]
  (let [result (float-array (.limit buffer))]
    (.get buffer result)
    (.flip buffer)
    result))
```
:::



::: {.sourceClojure}
```clojure
(defn make-texture-2d
  [width height]
  (let [texture (GL11/glGenTextures)]
    (GL11/glBindTexture GL11/GL_TEXTURE_2D texture)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_MIN_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_MAG_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_WRAP_S GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_WRAP_T GL11/GL_REPEAT)
    (GL42/glTexStorage2D GL11/GL_TEXTURE_2D 1 GL30/GL_RGBA32F width height)
    texture))
```
:::



::: {.sourceClojure}
```clojure
(defn read-texture-2d
  [texture width height]
  (let [buffer (BufferUtils/createFloatBuffer (* height width 4))]
    (GL11/glBindTexture GL11/GL_TEXTURE_2D texture)
    (GL11/glGetTexImage GL11/GL_TEXTURE_2D 0 GL12/GL_RGBA GL11/GL_FLOAT buffer)
    (float-buffer->array buffer)))
```
:::



::: {.sourceClojure}
```clojure
(defmacro framebuffer-render
  [texture width height & body]
  `(let [fbo# (GL30/glGenFramebuffers)]
     (try
       (GL30/glBindFramebuffer GL30/GL_FRAMEBUFFER fbo#)
       (GL11/glBindTexture GL11/GL_TEXTURE_2D ~texture)
       (GL32/glFramebufferTexture GL30/GL_FRAMEBUFFER GL30/GL_COLOR_ATTACHMENT0
                                  ~texture 0)
       (GL20/glDrawBuffers (volumetric-clouds.main/make-int-buffer
                             (int-array [GL30/GL_COLOR_ATTACHMENT0])))
       (GL11/glViewport 0 0 ~width ~height)
       ~@body
       (finally
         (GL30/glBindFramebuffer GL30/GL_FRAMEBUFFER 0)
         (GL30/glDeleteFramebuffers fbo#)))))
```
:::



::: {.sourceClojure}
```clojure
(defn setup-point-attribute
  [program]
  (let [point-attribute (GL20/glGetAttribLocation program "point")]
    (GL20/glVertexAttribPointer point-attribute 3 GL11/GL_FLOAT false
                                (* 3 Float/BYTES) (* 0 Float/BYTES))
    (GL20/glEnableVertexAttribArray point-attribute)))
```
:::



::: {.sourceClojure}
```clojure
(defn setup-quad-vao
  []
  (let [vertices (float-array [1.0 1.0 0.0, -1.0 1.0 0.0, -1.0 -1.0 0.0, 1.0 -1.0 0.0])
        indices  (int-array [0 1 2 3])]
    (setup-vao vertices indices)))
```
:::



::: {.sourceClojure}
```clojure
(defmacro render-array
  [width height & body]
  `(let [texture# (volumetric-clouds.main/make-texture-2d ~width ~height)]
     (try
       (volumetric-clouds.main/framebuffer-render texture# ~width ~height ~@body)
       (volumetric-clouds.main/read-texture-2d texture# ~width ~height)
       (finally
         (GL11/glDeleteTextures texture#)))))
```
:::



::: {.sourceClojure}
```clojure
(defn render-pixel
  [vertex-sources fragment-sources]
  (let [program (make-program-with-shaders vertex-sources fragment-sources)
        vao     (setup-quad-vao)]
    (setup-point-attribute program)
    (try
      (render-array 1 1
                    (GL20/glUseProgram program)
                    (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))
      (finally
        (teardown-vao vao)
        (GL20/glDeleteProgram program)))))
```
:::



::: {.sourceClojure}
```clojure
(render-pixel [vertex-test] [fragment-test])
```
:::



::: {.printedClojure}
```clojure
[1.0, 1.0, 1.0, 1.0]

```
:::



## Noise octaves shader


::: {.sourceClojure}
```clojure
(def noise-mock
"#version 130
float noise(vec3 idx)
{
  ivec3 v = ivec3(floor(idx.x), floor(idx.y), floor(idx.z)) % 2;
  return ((v.x == 1) == (v.y == 1)) == (v.z == 1) ? 1.0 : 0.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def noise-probe
  (template/fn [x y z]
"#version 130
out vec4 fragColor;
float noise(vec3 idx);
void main()
{
  fragColor = vec4(noise(vec3(<%= x %>, <%= y %>, <%= z %>)));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test noise mock"
         (fact (nth (render-pixel [vertex-test] [noise-mock (noise-probe ?x ?y ?z)]) 0)
               => ?result)
         ?x ?y ?z ?result
         0  0  0  0.0
         1  0  0  1.0
         0  1  0  1.0
         1  1  0  0.0
         0  0  1  1.0
         1  0  1  0.0
         0  1  1  0.0
         1  1  1  1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def noise-octaves
  (template/fn [octaves]
"#version 130
out vec4 fragColor;
float noise(vec3 idx);
float octaves(vec3 idx)
{
  float result = 0.0;
<% (doseq [multiplier octaves] %>
  result += <%= multiplier %> * noise(idx);
  idx *= 2.0;
<%= ) %>
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def octaves-probe
  (template/fn [x y z]
"#version 130
out vec4 fragColor;
float octaves(vec3 idx);
void main()
{
  fragColor = vec4(octaves(vec3(<%= x %>, <%= y %>, <%= z %>)));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test octaves of noise"
         (fact (first (render-pixel [vertex-test]
                                    [noise-mock (noise-octaves ?octaves)
                                     (octaves-probe ?x ?y ?z)]))
               => ?result)
         ?x  ?y ?z ?octaves  ?result
         0   0  0  [1.0]     0.0
         1   0  0  [1.0]     1.0
         1   0  0  [0.5]     0.5
         0.5 0  0  [0.0 1.0] 1.0
         0.5 0  0  [0.0 1.0] 1.0
         1   0  0  [1.0 0.0] 1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



## Shader for intersecting a ray with a box


::: {.sourceClojure}
```clojure
(def ray-box
"#version 130
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction)
{
  vec3 inv_dir = 1.0 / direction;
  vec3 smin = (box_min - origin) * inv_dir;
  vec3 smax = (box_max - origin) * inv_dir;
  vec3 s1 = min(smin, smax);
  vec3 s2 = max(smin, smax);
  float s_near = max(max(s1.x, s1.y), s1.z);
  float s_far = min(min(s2.x, s2.y), s2.z);
  if (isinf(s_near) || isinf(s_far))
    return vec2(0.0, 0.0);
  else
    return vec2(max(s_near, 0.0), max(0.0, s_far));
}")
```
:::



::: {.sourceClojure}
```clojure
(def ray-box-probe
  (template/fn [ox oy oz dx dy dz]
"#version 130
out vec4 fragColor;
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
void main()
{
  vec3 box_min = vec3(-1, -1, -1);
  vec3 box_max = vec3(1, 1, 1);
  vec3 origin = vec3(<%= ox %>, <%= oy %>, <%= oz %>);
  vec3 direction = vec3(<%= dx %>, <%= dy %>, <%= dz %>);
  fragColor = vec4(ray_box(box_min, box_max, origin, direction), 0, 0);
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test intersection of ray with box"
         (fact ((juxt first second)
                (render-pixel [vertex-test]
                              [ray-box (ray-box-probe ?ox ?oy ?oz ?dx ?dy ?dz)]))
               => ?result)
         ?ox ?oy ?oz ?dx ?dy ?dz ?result
         -2   0   0   1   0   0  [1.0 3.0]
         -2   0   0   2   0   0  [0.5 1.5]
         -2   2   2   1   0   0  [0.0 0.0]
          0  -2   0   0   1   0  [1.0 3.0]
          0  -2   0   0   2   0  [0.5 1.5]
          2  -2   2   0   1   0  [0.0 0.0]
          0   0  -2   0   0   1  [1.0 3.0]
          0   0  -2   0   0   2  [0.5 1.5]
          2   2  -2   0   0   1  [0.0 0.0]
          0   0   0   1   0   0  [0.0 1.0]
          2   0   0   1   0   0  [0.0 0.0])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



## Shader for light transfer through clouds


::: {.sourceClojure}
```clojure
(def fog
  (template/fn [v]
"#version 130
float fog(vec3 idx)
{
  return <%= v %>;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def cloud-transfer
  (template/fn [noise step]
"#version 130
#define STEP <%= step %>
float <%= noise %>(vec3 idx);
float in_scatter(vec3 point, vec3 direction);
float shadow(vec3 point);
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval)
{
  vec4 result = vec4(0, 0, 0, 0);
  for (float t = interval.x + 0.5 * STEP; t < interval.y; t += STEP) {
    vec3 point = origin + direction * t;
    float density = <%= noise %>(point);
    float transmittance = exp(-density * STEP);
    vec3 color = vec3(in_scatter(point, direction) * shadow(point));
    result.rgb += color * (1.0 - result.a) * (1.0 - transmittance);
    result.a = 1.0 - (1.0 - result.a) * transmittance;
  };
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def constant-scatter
"#version 130
float in_scatter(vec3 point, vec3 direction)
{
  return 1.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def no-shadow
"#version 130
float shadow(vec3 point)
{
  return 1.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def cloud-transfer-probe
  (template/fn [a b]
"#version 130
out vec4 fragColor;
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval);
void main()
{
  vec3 origin = vec3(0, 0, 0);
  vec3 direction = vec3(1, 0, 0);
  vec2 interval = vec2(<%= a %>, <%= b %>);
  fragColor = cloud_transfer(origin, direction, interval);
}"))
```
:::



::: {.sourceClojure}
```clojure
(defn roughly-vector
  [expected error]
  (fn [actual]
      (and (== (count expected) (count actual))
           (<= (apply + (mapv (fn [a b] (* (- b a) (- b a))) actual expected))
               (* error error)))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test cloud transfer"
         (fact (seq (render-pixel [vertex-test]
                                  [(fog ?density) constant-scatter no-shadow
                                   (cloud-transfer "fog" ?step)
                                   (cloud-transfer-probe ?a ?b)]))
               => (roughly-vector ?result 1e-3))
         ?a ?b ?step ?density ?result
         0  0  1     0.0      [0.0 0.0 0.0 0.0]
         0  1  1     1.0      [0.632 0.632 0.632 0.632]
         0  1  0.5   1.0      [0.632 0.632 0.632 0.632]
         0  1  0.5   0.5      [0.393 0.393 0.393 0.393])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



## Rendering of fog box


::: {.sourceClojure}
```clojure
(def fragment-cloud
"#version 130
uniform vec2 resolution;
uniform vec3 light;
uniform mat3 rotation;
uniform float focal_length;
uniform float distance;
out vec4 fragColor;
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval);
void main()
{
  vec3 direction = normalize(rotation * vec3(gl_FragCoord.xy - 0.5 * resolution, focal_length));
  vec3 origin = rotation * vec3(0, 0, -distance);
  vec2 interval = ray_box(vec3(-0.5, -0.5, -0.5), vec3(0.5, 0.5, 0.5), origin, direction);
  vec4 transfer = cloud_transfer(origin, direction, interval);
  vec3 background = mix(vec3(0.125, 0.125, 0.25), vec3(1, 1, 1), pow(dot(direction, light), 1000.0));
  fragColor = vec4(background * (1.0 - transfer.a) + transfer.rgb, 1.0);
}")
```
:::



::: {.sourceClojure}
```clojure
(defn setup-fog-uniforms
  [program width height]
  (let [rotation     (mulm (rotation-matrix-3d-y (to-radians 40.0))
                           (rotation-matrix-3d-x (to-radians -20.0)))
        focal-length (/ (* 0.5 width) (tan (to-radians 30.0)))
        light        (normalize (vec3 6 1 10))]
    (GL20/glUseProgram program)
    (GL20/glUniform2f (GL20/glGetUniformLocation program "resolution") width height)
    (GL20/glUniform3f (GL20/glGetUniformLocation program "light")
                      (light 0) (light 1) (light 2))
    (GL20/glUniformMatrix3fv (GL20/glGetUniformLocation program "rotation") true
                             (make-float-buffer (mat->float-array rotation)))
    (GL20/glUniform1f (GL20/glGetUniformLocation program "focal_length") focal-length)
    (GL20/glUniform1f (GL20/glGetUniformLocation program "distance") 2.0)))
```
:::



::: {.sourceClojure}
```clojure
(defn render-fog
  [width height]
  (let [fragment-sources [ray-box constant-scatter no-shadow (cloud-transfer "fog" 0.01)
                          (fog 1.0) fragment-cloud]
        program          (make-program-with-shaders [vertex-test] fragment-sources)
        vao              (setup-quad-vao)]
    (setup-point-attribute program)
    (try
      (render-array width height
                    (setup-fog-uniforms program width height)
                    (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))
      (finally
        (teardown-vao vao)
        (GL20/glDeleteProgram program)))))
```
:::



::: {.sourceClojure}
```clojure
(defn rgba-array->bufimg [data width height]
  (-> data
      tensor/->tensor
      (tensor/reshape [height width 4])
      (tensor/select :all :all [2 1 0]) (dfn/* 255) (clamp 0 255)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-fog 640 480) 640 480))
```
:::


::: {.clay-image}
![](main_files/image6.png)
:::



## Rendering of 3D noise


::: {.sourceClojure}
```clojure
(defn float-array->texture3d
  [data size]
  (let [buffer  (make-float-buffer data)
        texture (GL11/glGenTextures)]
    (GL11/glBindTexture GL12/GL_TEXTURE_3D texture)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_MIN_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_MAG_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_WRAP_S GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_WRAP_T GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL12/GL_TEXTURE_WRAP_R GL11/GL_REPEAT)
    (GL12/glTexImage3D GL12/GL_TEXTURE_3D 0 GL30/GL_R32F size size size 0
                       GL11/GL_RED GL11/GL_FLOAT buffer)
    texture))
```
:::



::: {.sourceClojure}
```clojure
(def noise3d (dfn/- (dfn/* 0.3 (perlin-noise (make-noise-params 32 4 3)))
                    (dfn/* 0.7 (worley-noise (make-noise-params 32 4 3)))))
```
:::



::: {.sourceClojure}
```clojure
(def noise-3d-norm (dfn/* (/ 1.0 (- (dfn/reduce-max noise3d) (dfn/reduce-min noise3d)))
                          (dfn/- noise3d (dfn/reduce-min noise3d))))
```
:::



::: {.sourceClojure}
```clojure
(def noise-texture (float-array->texture3d (dtype/->float-array noise-3d-norm) 32))
```
:::



::: {.sourceClojure}
```clojure
(def noise-shader
"#version 130
uniform sampler3D noise3d;
float noise(vec3 idx)
{
  return texture(noise3d, idx).r;
}")
```
:::



::: {.sourceClojure}
```clojure
(defn setup-noise-uniforms
  [program width height]
  (setup-fog-uniforms program width height)
  (GL20/glUniform1i (GL20/glGetUniformLocation program "noise3d") 0)
  (GL13/glActiveTexture GL13/GL_TEXTURE0)
  (GL11/glBindTexture GL12/GL_TEXTURE_3D noise-texture))
```
:::



::: {.sourceClojure}
```clojure
(defn render-noise
  [width height & cloud-shaders]
  (let [fragment-sources (concat cloud-shaders [ray-box fragment-cloud])
        program          (make-program-with-shaders [vertex-test] fragment-sources)
        vao              (setup-quad-vao)]
    (try
      (setup-point-attribute program)
      (render-array width height
                    (setup-noise-uniforms program width height)
                    (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))
      (finally
        (teardown-vao vao)
        (GL20/glDeleteProgram program)))))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image
  (rgba-array->bufimg
    (render-noise 640 480
                  constant-scatter no-shadow (cloud-transfer "noise" 0.01) noise-shader)
    640 480))
```
:::


::: {.clay-image}
![](main_files/image7.png)
:::



## Remap and clamp 3D noise


::: {.sourceClojure}
```clojure
(def remap-clamp
"#version 130
float remap_clamp(float value, float low1, float high1, float low2, float high2)
{
  float t = (value - low1) / (high1 - low1);
  return clamp(low2 + t * (high2 - low2), low2, high2);
}")
```
:::



::: {.sourceClojure}
```clojure
(def remap-probe
  (template/fn [value low1 high1 low2 high2]
"#version 130
out vec4 fragColor;
float remap_clamp(float value, float low1, float high1, float low2, float high2);
void main()
{
  fragColor = vec4(remap_clamp(<%= value %>, <%= low1 %>, <%= high1 %>, <%= low2 %>, <%= high2 %>));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Remap and clamp input parameter values"
       (fact (first (render-pixel
                      [vertex-test]
                      [remap-clamp (remap-probe ?value ?low1 ?high1 ?low2 ?high2)]))
             => ?expected)
       ?value ?low1 ?high1 ?low2 ?high2 ?expected
       0      0     1      0     1      0.0
       1      0     1      0     1      1.0
       0      0     1      2     3      2.0
       1      0     1      2     3      3.0
       2      2     3      0     1      0.0
       3      2     3      0     1      1.0
       1      0     2      0     4      2.0
       0      1     2      1     2      1.0
       3      1     2      1     2      2.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def remap-noise
  (template/fn [base low1 high1 high2]
"#version 130
float <%= base %>(vec3 idx);
float remap_clamp(float value, float low1, float high1, float low2, float high2);
float remap_noise(vec3 idx)
{
  return remap_clamp(<%= base %>(idx), <%= low1 %>, <%= high1 %>, 0.0, <%= high2 %>);
}"))
```
:::



::: {.sourceClojure}
```clojure
(def cloud-strength 6.5)
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image
  (rgba-array->bufimg
    (render-noise 640 480
                  constant-scatter no-shadow (cloud-transfer "remap_noise" 0.01)
                  remap-clamp (remap-noise "noise" 0.45 0.9 cloud-strength) noise-shader)
    640 480))
```
:::


::: {.clay-image}
![](main_files/image8.png)
:::



## Octaves of 3D noise


::: {.sourceClojure}
```clojure
(bufimg/tensor->image
  (rgba-array->bufimg
    (render-noise 640 480 constant-scatter no-shadow (cloud-transfer "remap_noise" 0.01)
                  remap-clamp (remap-noise "octaves" 0.45 0.9 cloud-strength)
                  (noise-octaves (octaves 4 0.5)) noise-shader)
    640 480))
```
:::


::: {.clay-image}
![](main_files/image9.png)
:::



## Mie scattering


::: {.sourceClojure}
```clojure
(def mie-scatter
  (template/fn [g]
"#version 450 core
#define M_PI 3.1415926535897932384626433832795
#define ANISOTROPIC 0.25
#define G <%= g %>
uniform vec3 light;
float mie(float mu)
{
  return 3 * (1 - G * G) * (1 + mu * mu) / (8 * M_PI * (2 + G * G) * pow(1 + G * G - 2 * G * mu, 1.5));
}
float in_scatter(vec3 point, vec3 direction)
{
  return mix(1.0, mie(dot(light, direction)), ANISOTROPIC);
}"))
```
:::



::: {.sourceClojure}
```clojure
(def mie-probe
  (template/fn [mu]
"#version 450 core
out vec4 fragColor;
float mie(float mu);
void main()
{
  float result = mie(<%= mu %>);
  fragColor = vec4(result, 0, 0, 1);
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Shader function for scattering phase function"
         (fact (first (render-pixel [vertex-test] [(mie-scatter ?g) (mie-probe ?mu)]))
               => (roughly ?result 1e-6))
         ?g  ?mu ?result
         0   0   (/ 3 (* 16 PI))
         0   1   (/ 6 (* 16 PI))
         0  -1   (/ 6 (* 16 PI))
         0.5 0   (/ (* 3 0.75) (* 8 PI 2.25 (pow 1.25 1.5)))
         0.5 1   (/ (* 6 0.75) (* 8 PI 2.25 (pow 0.25 1.5))))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn scatter-amount [theta]
  (first (render-pixel [vertex-test] [(mie-scatter 0.76) (mie-probe (cos theta))])))
```
:::



::: {.sourceClojure}
```clojure
(let [scatter
      (tc/dataset {:x (map (fn [theta]
                               (* (cos (to-radians theta))
                                  (+ 0.75 (* 0.25 (scatter-amount (to-radians theta))))))
                           (range 361))
                   :y (map (fn [theta]
                               (* (sin (to-radians theta))
                                  (+ 0.75 (* 0.25 (scatter-amount (to-radians theta))))))
                           (range 361)) })]
  (-> scatter
      (plotly/base {:=title "Mixed Mie and isotropic scattering" :=mode "lines"})
      (plotly/layer-point {:=x :x :=y :y})
      plotly/plot
      (assoc-in [:layout :yaxis :scaleanchor] "x")))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,0.025360926517815807,0.05026768547516574,0.07430991828057171,0.09715754239814561,0.11858169268939363,0.1384616278283216,0.15677607450298436,0.17358643197273366,0.1890130078449121,0.20321283539058999,0.21636004603964937,0.22862934013934708,0.24018581148892965,0.2511779530048358,0.26173469813490297,0.2719642194848011,0.28195509698295684,0.29177820496081974,0.3014883312512414,0.3111273886502506,0.3207258082385,0.3303052618584426,0.33988014253376003,0.34945889639953376,0.35904580497324945,0.3686413787230056,0.37824377096570716,0.3878490171811543,0.39745192434568677,0.40704606100916857,0.4166245092493745,0.4261798169674456,0.43570431582429453,0.44519024293778037,0.4546298234856557,0.4640153795311734,0.4733393662581841,0.4825944325730872,0.49177343328248807,0.5008694291703009,0.5098757320495632,0.5187858878903102,0.5275936842374551,0.5362931395697995,0.5448785141830071,0.5533442762704586,0.5616851076335537,0.5698959217886479,0.5779718188920269,0.5859080941630679,0.5937002248402926,0.6013438749545835,0.6088348664904691,0.6161691952748931,0.62334301119101,0.6303526110639879,0.6371944413501998,0.6438650835022438,0.6503612585839843,0.6566798127061101,0.6628177172143734,0.6687720730987843,0.6745400885739925,0.6801190923717032,0.6855065227577498,0.6906999283666247,0.6956969619936821,0.7004953800411007,0.7050930410845857,0.7094879040457471,0.7136780207548138,0.7176615440109427,0.7214367184553174,0.7250018813729326,0.7283554608303329,0.7314959760673239,0.7344220343582156,0.7371323315619472,0.7396256507881467,0.741900859614676,0.743956912756113,0.7457928474085281,0.7474077864032767,0.7488009326521377,0.7499715742565256,0.7509190802240712,0.7516428990221123,0.75214256164854,0.7524176785427296,0.7524679391644895,0.7522931117029785,0.7518930438535638,0.7512676607103084,0.7504169651362478,0.7493410364291085,0.7480400321651451,0.7465141834814171,0.7447638007224227,0.742789266527615,0.7405910390499166,0.7381696530092189,0.7355257142855391,0.7326599031912869,0.7295729740057649,0.7262657525522122,0.7227391366968671,0.7189940966742707,0.7150316733573406,0.7108529777428106,0.7064591912816467,0.7018515658212814,0.6970314204734881,0.6920001442391364,0.6867591925151003,0.681310089401197,0.6756544251377091,0.6697938557884047,0.6637301030917812,0.6574649535501379,0.6510002576103171,0.6443379296302819,0.6374799462048368,0.6304283462894203,0.6231852305750591,0.6157527599760481,0.6081331553770281,0.6003286969546965,0.592341723657082,0.5841746312849689,0.5758298727883504,0.5673099574889241,0.5586174494993552,0.5497549670438436,0.5407251823361603,0.5315308201341193,0.5221746568978521,0.5126595192134085,0.5029882848480691,0.4931638794460417,0.4831892774438777,0.4730674999720495,0.4628016143836867,0.452394733149158,0.44185001309511857,0.4311706538630154,0.42035989760294057,0.4094210274739456,0.39835736656986853,0.38717227714119057,0.37586915917927394,0.3644514500094941,0.3529226226065232,0.34128618416161416,0.32954567629653203,0.3177046724452901,0.30576677799377117,0.2937356279139821,0.2816148871090065,0.26940824760370413,0.2571194288806228,0.24475217578413103,0.23231025759109408,0.2197974668117835,0.2072176183796385,0.19457454786078107,0.1818721106724072,0.16911418060327282,0.15630464879745518,0.14344742259440596,0.13054642406455352,0.11760558906028022,0.10462886564818821,0.09162021328120996,0.07858360127518772,0.06552300766634107,0.05244241794028889,0.03934582381937251,0.026237222072321924,0.013120613137373302,9.206821122027452E-17,-0.01312061313737345,-0.026237222072321743,-0.03934582381937232,-0.0524424179402887,-0.0655230076663409,-0.07858360127518754,-0.0916202132812098,-0.10462886564818835,-0.11760558906028003,-0.13054642406455366,-0.14344742259440577,-0.15630464879745531,-0.16911418060327266,-0.18187211067240702,-0.1945745478607809,-0.20721761837963834,-0.21979746681178364,-0.23231025759109392,-0.24475217578413117,-0.2571194288806226,-0.2694082476037043,-0.28161488710900634,-0.29373562791398194,-0.305766777993771,-0.31770467244528994,-0.3295456762965322,-0.34128618416161405,-0.3529226226065233,-0.3644514500094939,-0.3758691591792741,-0.3871722771411904,-0.3983573665698684,-0.40942102747394543,-0.4203598976029404,-0.43117065386301556,-0.4418500130951184,-0.4523947331491582,-0.46280161438368655,-0.47306749997204967,-0.4831892774438775,-0.4931638794460415,-0.502988284848069,-0.5126595192134082,-0.5221746568978523,-0.5315308201341192,-0.5407251823361604,-0.5497549670438436,-0.5586174494993553,-0.567309957488924,-0.5758298727883503,-0.5841746312849686,-0.592341723657082,-0.6003286969546966,-0.608133155377028,-0.615752759976048,-0.6231852305750593,-0.6304283462894205,-0.6374799462048367,-0.6443379296302818,-0.6510002576103169,-0.6574649535501379,-0.6637301030917813,-0.6697938557884046,-0.675654425137709,-0.681310089401197,-0.6867591925151004,-0.6920001442391364,-0.697031420473488,-0.7018515658212813,-0.7064591912816467,-0.7108529777428106,-0.7150316733573405,-0.7189940966742705,-0.7227391366968671,-0.7262657525522122,-0.7295729740057649,-0.7326599031912868,-0.735525714285539,-0.7381696530092189,-0.7405910390499166,-0.7427892665276149,-0.7447638007224225,-0.7465141834814171,-0.7480400321651453,-0.7493410364291085,-0.7504169651362478,-0.7512676607103084,-0.7518930438535638,-0.7522931117029785,-0.7524679391644895,-0.7524176785427296,-0.75214256164854,-0.7516428990221123,-0.7509190802240713,-0.7499715742565256,-0.7488009326521378,-0.7474077864032767,-0.7457928474085281,-0.743956912756113,-0.7419008596146761,-0.7396256507881467,-0.7371323315619472,-0.7344220343582156,-0.731495976067324,-0.728355460830333,-0.7250018813729325,-0.7214367184553174,-0.7176615440109428,-0.7136780207548139,-0.7094879040457471,-0.7050930410845857,-0.7004953800411007,-0.6956969619936821,-0.6906999283666249,-0.6855065227577498,-0.6801190923717032,-0.6745400885739926,-0.6687720730987845,-0.6628177172143734,-0.6566798127061101,-0.6503612585839843,-0.6438650835022439,-0.6371944413502,-0.6303526110639878,-0.62334301119101,-0.6161691952748932,-0.6088348664904693,-0.6013438749545833,-0.5937002248402925,-0.5859080941630679,-0.577971818892027,-0.5698959217886481,-0.5616851076335537,-0.5533442762704586,-0.5448785141830074,-0.5362931395697997,-0.5275936842374549,-0.5187858878903101,-0.5098757320495633,-0.5008694291703011,-0.4917734332824884,-0.4825944325730871,-0.4733393662581841,-0.4640153795311736,-0.4546298234856561,-0.4451902429377801,-0.4357043158242945,-0.4261798169674457,-0.4166245092493748,-0.407046061009169,-0.39745192434568666,-0.3878490171811543,-0.3782437709657074,-0.36864137872300595,-0.3590458049732493,-0.3494588963995337,-0.33988014253376014,-0.33030526185844294,-0.3207258082385005,-0.31112738865025047,-0.3014883312512414,-0.29177820496081996,-0.28195509698295723,-0.2719642194848009,-0.2617346981349029,-0.251177953004836,-0.24018581148893,-0.22862934013934766,-0.2163600460396492,-0.20321283539059004,-0.1890130078449124,-0.1735864319727342,-0.15677607450298403,-0.13846162782832153,-0.11858169268939384,-0.09715754239814607,-0.07430991828057246,-0.050267685475165524,-0.025360926517815876,-3.569842744991019E-16],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[1.4574989080429077,1.452926507126177,1.439478173212784,1.4179177079655019,1.3894175881582194,1.3553949495897417,1.3173743900835797,1.2768386623702594,1.2351316422754952,1.1933811645740997,1.1524772588636192,1.1130759437487994,1.0756164775297632,1.040359047809661,1.007419744836358,0.976807191543161,0.9484519472392144,0.9222335672616542,0.8980009779144618,0.875585691112187,0.8548154748904458,0.8355192958071976,0.8175342112400585,0.800707437884673,0.7848975322813364,0.7699762135450587,0.7558268349608668,0.742345198539181,0.7294379111711611,0.7170222519441439,0.705024458688661,0.6933796225880876,0.6820302766733982,0.6709258105206349,0.6600216777422576,0.6492786762165587,0.638662379207277,0.6281425548620099,0.6176927057148899,0.6072896144200244,0.5969129416343172,0.5865449337585023,0.5761700996077531,0.5657749585828894,0.5553478031024442,0.5448785141830073,0.5343583561981262,0.5237798365271452,0.513136592807344,0.502423236994361,0.4916352657160133,0.4807689625799547,0.4698213260898689,0.458789979487687,0.4476731248140497,0.4364694753262847,0.42517820477652146,0.41379890855606555,0.4023315574450921,0.390776468424316,0.3791342666372658,0.36740586011518905,0.35559241889842363,0.3436953418326754,0.33171624545551504,0.3196569412771426,0.3075194210493724,0.29530584007984856,0.2830185046129697,0.2706598598261214,0.25823247864456755,0.24573904954379727,0.23318237087807409,0.22056533956264396,0.20789094415014306,0.1951622575322859,0.18238243080068894,0.16955468659503733,0.15668231389261433,0.14376866264638624,0.13081713856087063,0.11783119925244687,0.10481434928986781,0.09177013686893824,0.07870214939262823,0.06561401071413667,0.05250937730762238,0.039391935151616195,0.0262653970202614,0.013133499432102156,4.6075372657939866E-17,-0.013131325109826309,-0.026256683666858856,-0.039372269744992534,-0.052474266000302236,-0.06555884580231348,-0.07862217552882966,-0.09166041622655606,-0.10466972620965473,-0.11764626225804907,-0.13058618185541665,-0.14348564534801433,-0.15634081684842127,-0.1691478665600026,-0.18190297253721718,-0.19460232188674692,-0.20724211255513084,-0.21981855514097864,-0.23232787410417374,-0.24476630922603348,-0.2571301173502928,-0.2694155740520818,-0.28161897410242165,-0.2937366340429274,-0.30576489240705007,-0.3177001122660448,-0.329538681748394,-0.3412770154391934,-0.3529115558915458,-0.36443877476581565,-0.3758551739738321,-0.3871572872605879,-0.39834168084020916,-0.4094049550472993,-0.4203437455932887,-0.431154724208663,-0.44183460007150277,-0.4523801209831447,-0.46278807467349214,-0.4730552890121481,-0.48317863387756493,-0.4931550222762089,-0.5029814107445638,-0.5126548004474971,-0.5221722388375385,-0.5315308201341192,-0.540727686310916,-0.5497600273007567,-0.5586250839647362,-0.5673201464972769,-0.5758425572967414,-0.5841897105646295,-0.5923590536958476,-0.6003480879539376,-0.6081543695840722,-0.6157755098801598,-0.6232091769141317,-0.6304530956560963,-0.6375050486196236,-0.6443628769810116,-0.6510244806966965,-0.657487820295043,-0.663750916555524,-0.6698118504193493,-0.6756687660866271,-0.681319868737147,-0.6867634276122159,-0.6919977739478803,-0.6970213048098158,-0.7018324797707298,-0.7064298249525794,-0.7108119312470986,-0.7149774553050525,-0.7189251198575035,-0.7226537153554646,-0.7261620984761764,-0.7294491938268117,-0.7325139932824091,-0.7353555569839629,-0.7379730139886408,-0.7403655614134065,-0.7425324660635944,-0.7444730627205243,-0.7461867567670925,-0.7476730226574447,-0.7489314046605108,-0.7499615166590711,-0.7507630423887196,-0.7513357367031108,-0.7516794232121576,-0.7517939971294254,-0.7516794232121576,-0.7513357367031108,-0.7507630423887196,-0.7499615166590711,-0.7489314046605108,-0.7476730226574447,-0.7461867567670926,-0.7444730627205242,-0.7425324660635944,-0.7403655614134065,-0.7379730139886408,-0.7353555569839628,-0.7325139932824091,-0.7294491938268117,-0.7261620984761765,-0.7226537153554646,-0.7189251198575034,-0.7149774553050525,-0.7108119312470985,-0.7064298249525796,-0.7018324797707298,-0.697021304809816,-0.6919977739478803,-0.686763427612216,-0.6813198687371471,-0.675668766086627,-0.6698118504193494,-0.6637509165555239,-0.6574878202950432,-0.6510244806966964,-0.6443628769810117,-0.6375050486196238,-0.6304530956560963,-0.6232091769141319,-0.6157755098801598,-0.6081543695840724,-0.6003480879539375,-0.5923590536958477,-0.5841897105646294,-0.5758425572967415,-0.567320146497277,-0.5586250839647363,-0.5497600273007568,-0.5407276863109158,-0.5315308201341195,-0.5221722388375384,-0.5126548004474972,-0.5029814107445637,-0.493155022276209,-0.483178633877565,-0.47305528901214855,-0.462788074673492,-0.45238012098314456,-0.44183460007150294,-0.4311547242086632,-0.4203437455932886,-0.40940495504729923,-0.3983416808402093,-0.38715728726058807,-0.3758551739738326,-0.36443877476581554,-0.3529115558915457,-0.3412770154391936,-0.3295386817483942,-0.31770011226604467,-0.3057648924070499,-0.29373663404292744,-0.2816189741024218,-0.26941557405208216,-0.2571301173502927,-0.24476630922603348,-0.2323278741041739,-0.21981855514097898,-0.20724211255513073,-0.19460232188674675,-0.18190297253721718,-0.16914786656000277,-0.1563408168484216,-0.1434856453480142,-0.13058618185541668,-0.11764626225804924,-0.10466972620965509,-0.09166041622655591,-0.07862217552882952,-0.0655588458023135,-0.05247426600030242,-0.03937226974499288,-0.02625668366685871,-0.013131325109826324,-1.382261179738196E-16,0.013133499432101804,0.026265397020261552,0.03939193515161618,0.052509377307622375,0.06561401071413649,0.07870214939262787,0.0917701368689384,0.10481434928986781,0.11783119925244669,0.13081713856087027,0.1437686626463864,0.15668231389261433,0.16955468659503733,0.18238243080068878,0.19516225753228555,0.20789094415014323,0.2205653395626439,0.23318237087807392,0.24573904954379694,0.25823247864456766,0.2706598598261214,0.2830185046129697,0.2953058400798484,0.3075194210493721,0.3196569412771427,0.331716245455515,0.3436953418326753,0.3555924188984233,0.3674058601151892,0.3791342666372658,0.390776468424316,0.4023315574450919,0.4137989085560652,0.42517820477652163,0.43646947532628466,0.44767312481404953,0.4587899794876867,0.46982132608986904,0.4807689625799547,0.49163526571601324,0.5024232369943608,0.5131365928073437,0.5237798365271452,0.5343583561981262,0.544878514183007,0.5553478031024439,0.5657749585828896,0.5761700996077531,0.5865449337585021,0.5969129416343171,0.6072896144200242,0.61769270571489,0.6281425548620099,0.6386623792072769,0.6492786762165585,0.6600216777422578,0.6709258105206349,0.6820302766733982,0.6933796225880875,0.7050244586886608,0.717022251944144,0.7294379111711611,0.742345198539181,0.7558268349608666,0.7699762135450589,0.7848975322813365,0.8007074378846729,0.8175342112400584,0.8355192958071974,0.8548154748904458,0.875585691112187,0.8980009779144618,0.9222335672616541,0.9484519472392144,0.976807191543161,1.007419744836358,1.0403590478096607,1.0756164775297632,1.1130759437487994,1.1524772588636192,1.1933811645740995,1.2351316422754952,1.2768386623702594,1.3173743900835797,1.3553949495897417,1.3894175881582194,1.4179177079655019,1.439478173212784,1.452926507126177,1.4574989080429077],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"y","showgrid":true,"scaleanchor":"x"},"title":"Mixed Mie and isotropic scattering"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(bufimg/tensor->image
  (rgba-array->bufimg
    (render-noise 640 480 (mie-scatter 0.76) no-shadow (cloud-transfer "remap_noise" 0.01)
                  remap-clamp (remap-noise "octaves" 0.45 0.9 cloud-strength)
                  (noise-octaves (octaves 4 0.5)) noise-shader)
    640 480))
```
:::


::: {.clay-image}
![](main_files/image10.png)
:::



## Self-shading of clouds


::: {.sourceClojure}
```clojure
(def shadow
  (template/fn [noise step]
"#version 130
#define STEP <%= step %>
uniform vec3 light;
float <%= noise %>(vec3 idx);
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
float shadow(vec3 point)
{
  vec2 interval = ray_box(vec3(-0.5, -0.5, -0.5), vec3(0.5, 0.5, 0.5), point, light);
  float result = 1.0;
  for (float t = interval.x + 0.5 * STEP; t < interval.y; t += STEP) {
    float density = <%= noise %>(point + t * light);
    float transmittance = exp(-density * STEP);
    result *= transmittance;
  };
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image
  (rgba-array->bufimg
    (render-noise 640 480
                  (mie-scatter 0.76) (shadow "remap_noise" 0.01)
                  (cloud-transfer "remap_noise" 0.01) remap-clamp
                  (remap-noise "octaves" 0.45 0.9 cloud-strength)
                  (noise-octaves (octaves 4 0.5)) noise-shader)
    640 480))
```
:::


::: {.clay-image}
![](main_files/image11.png)
:::



## Tidy up


::: {.sourceClojure}
```clojure
(GL11/glBindTexture GL12/GL_TEXTURE_3D 0)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GL11/glDeleteTextures noise-texture)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwDestroyWindow window)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwTerminate)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



## Further topics


* [Vertical density profile](https://www.wedesoft.de/software/2023/05/03/volumetric-clouds/)
* [Powder function](https://advances.realtimerendering.com/s2015/index.html)
* [Curl noise](https://www.wedesoft.de/software/2023/03/20/procedural-global-cloud-cover/)
* [Deep opacity maps](https://www.wedesoft.de/software/2023/05/03/volumetric-clouds/)


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/ClojureCivitas/clojurecivitas.github.io/blob/main/src/volumetric_clouds/main.clj">src/volumetric_clouds/main.clj</a></small></small></pre></div>
```