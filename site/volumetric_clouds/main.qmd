---
description: Procedural generation of volumetric clouds using different types of noise
category: clojure
tags: [visualization]
format:
  html: {title: Volumetric Clouds with Clojure and LWJGL}
date: '2026-01-24'
type: post
author:
- name: Jan Wedekind
  url: https://www.wedesoft.de/
  image: https://avatars.githubusercontent.com/u/28663?v=4
  links:
  - {icon: github, href: 'https://github.com/wedesoft'}
draft: true
image: clouds.jpg

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.20.0/plotly.min.js" type="text/javascript"></script>
Procedural generation of volumetric clouds


* Midje testing of shaders
* Generating OpenGL shaders using templates
* cloud shadows
* powder function
* video showing TDD with tmux

References

* https://adrianb.io/2014/08/09/perlinnoise.html
* https://www.wedesoft.de/software/2023/05/03/volumetric-clouds/


# Worley noise


::: {.sourceClojure}
```clojure
(defn make-noise-params
  [size divisions dimensions]
  {:size size :divisions divisions :cellsize (/ size divisions) :dimensions dimensions})
```
:::



::: {.sourceClojure}
```clojure
(fact "Noise parameter initialisation"
      (make-noise-params 256 8 2) => {:size 256 :divisions 8 :cellsize 32 :dimensions 2})
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn vec-n
  ([x y] (vec2 x y))
  ([x y z] (vec3 x y z)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Generic vector function for creating 2D and 3D vectors"
       (vec-n 2 3) => (vec2 2 3)
       (vec-n 2 3 1) => (vec3 2 3 1))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn random-point-in-cell
  [{:keys [cellsize]} & args]
  (let [random-seq (repeatedly #(rand cellsize))
        dimensions (count args)]
    (add (mult (apply vec-n (reverse args)) cellsize)
         (apply vec-n (take dimensions random-seq)))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Place random point in a cell"
       (with-redefs [rand (fn [s] (* 0.5 s))]
         (random-point-in-cell {:cellsize 1} 0 0) => (vec2 0.5 0.5)
         (random-point-in-cell {:cellsize 2} 0 0) => (vec2 1.0 1.0)
         (random-point-in-cell {:cellsize 2} 0 3) => (vec2 7.0 1.0)
         (random-point-in-cell {:cellsize 2} 2 0) => (vec2 1.0 5.0)
         (random-point-in-cell {:cellsize 2} 2 3 5) => (vec3 11.0 7.0 5.0)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn random-points
  [{:keys [divisions dimensions] :as params}]
  (tensor/clone (tensor/compute-tensor (repeat dimensions divisions) (partial random-point-in-cell params))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Greate grid of random points"
       (let [params-2d (make-noise-params 32 8 2)
             params-3d (make-noise-params 32 8 3)]
         (with-redefs [rand (fn [s] (* 0.5 s))]
           (dtype/shape (random-points params-2d)) => [8 8]
           ((random-points params-2d) 0 0) => (vec2 2.0 2.0)
           ((random-points params-2d) 0 3) => (vec2 14.0 2.0)
           ((random-points params-2d) 2 0) => (vec2 2.0 10.0)
           (dtype/shape (random-points params-3d)) => [8 8 8]
           ((random-points params-3d) 2 3 5) => (vec3 22.0 14.0 10.0))))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(let [points  (tensor/reshape (random-points (make-noise-params 256 8 2)) [(* 8 8)])
      scatter (tc/dataset {:x (map first points) :y (map second points)})]
  (-> scatter
      (plotly/base {:=title "Random points"})
      (plotly/layer-point {:=x :x :=y :y})))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[17.888350937655158,1.6708197450519293,10.275679361189276,19.923353852845384,5.046912456661946,15.454493995872532,15.251079908413114,5.443515518328123,34.10494638936682,50.38218042072107,32.27317965559706,44.26311863614815,55.36754240570593,63.17132339981927,57.853584736390005,55.23285177642265,67.33456638228226,73.15608465192808,71.96358165709668,93.88215058071152,79.5161180024531,90.1423571896289,77.43651553773499,80.00174529321728,104.9530715009261,126.74910197572767,123.13774125770999,124.77504216618473,108.56769114302095,127.36101547083261,113.02715274572569,109.5833252930651,133.46932554572933,133.81752684462228,139.2392933885786,152.60979462928518,131.340182205892,151.96311992783293,133.30604254645533,151.36742842311628,183.02617418327802,183.18398463794648,165.64687852677372,181.2756703192759,171.45785389374404,189.05599748556105,171.45172468670023,178.4109529611962,217.0264176156084,213.22902898028627,193.0813687643843,222.55604095003588,217.53978922711642,220.67258016575025,221.11046091694925,216.67320903948558,234.883788951059,246.4077458641412,228.13809415513953,230.92624295439626,246.51336677577362,237.85050805196403,229.4909576322936,227.3762717981416],"r":null,"name":"","fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[31.721131022929942,51.438908448049915,66.98789462069877,108.97114520225645,129.97262990708663,164.0705448823744,206.38317950235552,232.28333167821626,3.466216889570415,62.856716103311726,69.9259220715069,120.38549154620395,157.9725790432141,178.15935204725642,193.6504907217103,237.50095640278528,12.125893093307415,46.41603823169634,78.14677144431096,114.90809714702985,156.41774873538594,173.34145844584674,194.16445126241942,254.2677458447969,8.693031242822371,53.16204704261405,88.28174403162869,99.54632345881649,147.2727537473833,171.00884088722702,209.76358028307328,228.6596685662977,18.82884495391311,47.593534488522806,79.73424237248199,123.96256993440066,158.1358852949124,169.29274100440963,215.78945588199036,232.7090011747458,16.824804200310943,38.76545287233225,65.17293498924717,108.60806153938975,138.263521236204,173.2287064251919,207.64237868388403,241.60061464213996,15.689549748316804,45.51645354187124,73.14992198318467,118.98163751228745,130.71954361819803,163.04662776509733,219.46203878860405,236.9932648504909,5.360806483163511,39.82142534034887,78.84389838920671,110.01354256282205,140.64974998845517,176.5857774028681,202.93317678362783,236.46588092633246],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"y","showgrid":true},"title":"Random points"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(defn mod-vec
  [{:keys [size]} v]
  (let [size2 (/ size 2)
        wrap  (fn [x] (-> x (+ size2) (mod size) (- size2)))]
    (apply vec-n (map wrap v))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Wrap around components of vector to be within -size/2..size/2"
       (mod-vec {:size 8} (vec2 2 3)) => (vec2 2 3)
       (mod-vec {:size 8} (vec2 5 2)) => (vec2 -3 2)
       (mod-vec {:size 8} (vec2 2 5)) => (vec2 2 -3)
       (mod-vec {:size 8} (vec2 -5 2)) => (vec2 3 2)
       (mod-vec {:size 8} (vec2 2 -5)) => (vec2 2 3)
       (mod-vec {:size 8} (vec3 2 3 1)) => (vec3 2 3 1)
       (mod-vec {:size 8} (vec3 5 2 1)) => (vec3 -3 2 1)
       (mod-vec {:size 8} (vec3 2 5 1)) => (vec3 2 -3 1)
       (mod-vec {:size 8} (vec3 2 3 5)) => (vec3 2 3 -3)
       (mod-vec {:size 8} (vec3 -5 2 1)) => (vec3 3 2 1)
       (mod-vec {:size 8} (vec3 2 -5 1)) => (vec3 2 3 1)
       (mod-vec {:size 8} (vec3 2 3 -5)) => (vec3 2 3 3))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn mod-dist
  [params a b]
  (mag (mod-vec params (sub b a))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Wrapped distance of two points"
         (fact (mod-dist {:size 8} (vec2 ?ax ?ay) (vec2 ?bx ?by)) => ?result)
         ?ax ?ay ?bx ?by ?result
         0   0   0   0   0.0
         0   0   2   0   2.0
         0   0   5   0   3.0
         0   0   0   2   2.0
         0   0   0   5   3.0
         2   0   0   0   2.0
         5   0   0   0   3.0
         0   2   0   0   2.0
         0   5   0   0   3.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn wrap-get
  [t & args]
  (if (> (count (dtype/shape t)) (count args))
    (apply tensor/select t (map mod args (dtype/shape t)))
    (apply t (map mod args (dtype/shape t)))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Wrapped lookup of tensor values"
       (let [t (tensor/compute-tensor [4 6] vec2)]
         (wrap-get t 2 3) => (vec2 2 3)
         (wrap-get t 2 7) => (vec2 2 1)
         (wrap-get t 5 3) => (vec2 1 3)
         (wrap-get (wrap-get t 5) 3) => (vec2 1 3)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn division-index
  [{:keys [cellsize]} x]
  (int (/ x cellsize)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Convert coordinate to division index"
       (division-index {:cellsize 4} 3.5) => 0
       (division-index {:cellsize 4} 7.5) => 1)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn neighbours
  [& args]
  (if (seq args)
    (mapcat (fn [v] (map (fn [delta] (into [(+ (first args) delta)] v)) [-1 0 1])) (apply neighbours (rest args)) )
    [[]]))
```
:::



::: {.sourceClojure}
```clojure
(facts "Get neighbouring indices"
       (neighbours) => [[]]
       (neighbours 3) => [[2] [3] [4]]
       (neighbours 1 10) => [[0 9] [1 9] [2 9] [0 10] [1 10] [2 10] [0 11] [1 11] [2 11]])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn worley-noise
  [{:keys [size dimensions] :as params}]
  (let [random-points (random-points params)]
    (tensor/clone
      (tensor/compute-tensor (repeat dimensions size)
                             (fn [& coords]
                                 (let [center   (map #(+ % 0.5) coords)
                                       division (map (partial division-index params) center)]
                                   (apply min
                                          (for [neighbour (apply neighbours division)]
                                               (mod-dist params (apply vec-n (reverse center))
                                                         (apply wrap-get random-points neighbour))))))
                             :double))))
```
:::



::: {.sourceClojure}
```clojure
(def worley (worley-noise (make-noise-params 256 8 2)))
```
:::



::: {.sourceClojure}
```clojure
(def worley-norm (dfn/* (/ 255 (- (dfn/reduce-max worley) (dfn/reduce-min worley))) (dfn/- (dfn/reduce-max worley) worley)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image worley-norm)
```
:::


::: {.clay-image}
![](main_files/image0.png)
:::



# Perlin noise


::: {.sourceClojure}
```clojure
(defmulti random-gradient (fn [& args] (count args)))
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/random-gradient

```
:::



::: {.sourceClojure}
```clojure
(defmethod random-gradient 2
  [& args]
  (loop [args args]
        (let [random-vector (apply vec-n (map (fn [_x] (- (rand 2.0) 1.0)) args))
              vector-length (mag random-vector)]
          (if (and (> vector-length 0.0) (<= vector-length 1.0))
            (div random-vector vector-length)
            (recur args)))))
```
:::



::: {.printedClojure}
```clojure
#object[clojure.lang.MultiFn 0x50404204 "clojure.lang.MultiFn@50404204"]

```
:::



::: {.sourceClojure}
```clojure
(defmethod random-gradient 3
  [& _args]
  (apply vec3
          (rand-nth [[1  1  0] [-1  1  0] [1 -1  0] [-1 -1  0]
                     [1  0  1] [-1  0  1] [1  0 -1] [-1  0 -1]
                     [0  1  1] [ 0 -1  1] [0  1 -1] [ 0 -1 -1]])))
```
:::



::: {.printedClojure}
```clojure
#object[clojure.lang.MultiFn 0x50404204 "clojure.lang.MultiFn@50404204"]

```
:::



::: {.sourceClojure}
```clojure
(defn roughly-vec
  [expected error]
  (fn [actual]
      (<= (mag (sub actual expected)) error)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Create unit vector with random direction"
       (with-redefs [rand (constantly 0.5)]
         (random-gradient 0 0) => (roughly-vec (vec2 (- (sqrt 0.5)) (- (sqrt 0.5))) 1e-6))
       (with-redefs [rand (constantly 1.5)]
         (random-gradient 0 0) => (roughly-vec (vec2 (sqrt 0.5) (sqrt 0.5)) 1e-6)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn random-gradients
 [{:keys [divisions dimensions]}]
 (tensor/clone (tensor/compute-tensor (repeat dimensions divisions) random-gradient)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Random gradients"
       (with-redefs [rand (constantly 1.5)
                     rand-nth (fn [x] (first x))]
         (dtype/shape (random-gradients {:divisions 8 :dimensions 2})) => [8 8]
         ((random-gradients {:divisions 8 :dimensions 2}) 0 0) => (roughly-vec (vec2 (sqrt 0.5) (sqrt 0.5)) 1e-6)
         (dtype/shape (random-gradients {:divisions 8 :dimensions 3})) => [8 8 8]
         ((random-gradients {:divisions 8 :dimensions 3}) 0 0 0) => (vec3 1 1 0)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(let [gradients (tensor/reshape (random-gradients (make-noise-params 256 8 2)) [(* 8 8)])
      points    (tensor/reshape (tensor/compute-tensor [8 8] (fn [y x] (vec2 x y))) [(* 8 8)])
      scatter   (tc/dataset {:x (mapcat (fn [point gradient] [(point 0) (+ (point 0) (* 0.5 (gradient 0))) nil]) points gradients)
                             :y (mapcat (fn [point gradient] [(point 1) (+ (point 1) (* 0.5 (gradient 1))) nil]) points gradients)})]
  (-> scatter
      (plotly/base {:=title "Random gradients" :=mode "lines"})
      (plotly/layer-point {:=x :x :=y :y})))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,-0.4996444077497972,null,0.0,-0.25134720905599756,null,0.0,-0.49006576145337827,null,0.0,-0.40332339071498785,null,0.0,-0.018260924930915537,null,0.0,-0.20416750780788992,null,0.0,0.4731011135714833,null,0.0,-0.4441226584305075,null,1.0,1.2374395364860624,null,1.0,1.2748893178481069,null,1.0,1.2298398293430142,null,1.0,0.6727964696492921,null,1.0,0.8687605261094852,null,1.0,0.5474369059808706,null,1.0,0.7700153364974228,null,1.0,0.9737372123223091,null,2.0,2.4327942588817364,null,2.0,2.4580588141834108,null,2.0,1.9147140401766438,null,2.0,2.4989834003055913,null,2.0,2.4694831903726877,null,2.0,2.4157137566201463,null,2.0,2.3508653111480635,null,2.0,1.514315645760009,null,3.0,2.623508938883648,null,3.0,3.494410605294328,null,3.0,2.5145149421433066,null,3.0,2.598119965620603,null,3.0,2.989219850527056,null,3.0,3.29570585645775,null,3.0,2.6209199025415018,null,3.0,2.684494377560891,null,4.0,4.49531934706067,null,4.0,3.582987338402254,null,4.0,3.7903766751263275,null,4.0,3.6696417910201466,null,4.0,4.2448943801230925,null,4.0,3.688664311441035,null,4.0,4.497761985844884,null,4.0,4.383434682579847,null,5.0,5.013105865531607,null,5.0,4.79117841214687,null,5.0,5.497532139080703,null,5.0,5.122579423513565,null,5.0,4.744772843337293,null,5.0,4.748476187859123,null,5.0,4.500592047470685,null,5.0,4.639613076061148,null,6.0,6.1520056183419864,null,6.0,5.50017290456935,null,6.0,5.500345022548548,null,6.0,6.436561948639803,null,6.0,6.447546137376384,null,6.0,6.192072362847898,null,6.0,6.243329678142006,null,6.0,6.273993354283344,null,7.0,7.440268745634359,null,7.0,6.5514167360292905,null,7.0,7.14346105418004,null,7.0,6.808793289118144,null,7.0,6.8904802270111025,null,7.0,7.499122941752274,null,7.0,6.842022635865806,null,7.0,7.467051981165919,null],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,0.018853800793326835,null,1.0,0.5677679089889776,null,2.0,1.900825661327536,null,3.0,3.2955169073033983,null,4.0,4.499666427349955,null,5.0,4.543583930217707,null,6.0,5.8382120636839,null,7.0,7.229684706214016,null,0.0,0.4400255293881071,null,1.0,1.417655196224113,null,2.0,1.555957600169112,null,3.0,3.3780712230863825,null,4.0,4.482468859609551,null,5.0,4.787428492191845,null,6.0,5.556032597420028,null,7.0,7.49930978959299,null,0.0,0.25037797323049116,null,1.0,0.7995452102121585,null,2.0,1.507327385521573,null,3.0,2.968132050278215,null,4.0,4.172004459120927,null,5.0,4.722183383224174,null,6.0,6.356221186109098,null,7.0,7.1187885013226575,null,0.0,0.329020487051313,null,1.0,1.074553023899077,null,2.0,2.119600412197798,null,3.0,2.7025232144062086,null,4.0,3.50011622513094,null,5.0,5.403184878754882,null,6.0,6.326034169544935,null,7.0,7.387886842016212,null,0.0,-0.06825499562223415,null,1.0,1.2758630821026327,null,2.0,1.5460638132194053,null,3.0,2.624682196319408,null,4.0,4.4359205691225485,null,5.0,4.608758272893196,null,6.0,6.0472546870453945,null,7.0,7.320901611393418,null,0.0,-0.4998282067757555,null,1.0,1.4543055628610524,null,2.0,1.9503837669529458,null,3.0,2.515258538052415,null,4.0,3.570047562512003,null,5.0,4.567870653708729,null,6.0,6.024324821694668,null,7.0,6.6534148516541824,null,0.0,0.47633422299103206,null,1.0,0.986851818629168,null,2.0,2.0185715779617537,null,3.0,3.2437491846136464,null,4.0,4.222940473937503,null,5.0,5.461636445084252,null,6.0,6.43679591085003,null,7.0,6.581756480255148,null,0.0,-0.2369882520665281,null,1.0,1.220846225427072,null,2.0,1.5210230423772437,null,3.0,2.5380043358279836,null,4.0,3.5121420090595414,null,5.0,5.029602179253496,null,6.0,6.474387133490373,null,7.0,6.821499448491076,null],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"y","showgrid":true},"title":"Random gradients"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(defn frac
  [x]
  (- x (Math/floor x)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Fractional part of floating point number"
       (frac 0.25) => 0.25
       (frac 1.75) => 0.75
       (frac -0.25) => 0.75)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn cell-pos
  [{:keys [cellsize]} point]
  (apply vec-n (map frac (div point cellsize))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Relative position of point in a cell"
       (cell-pos {:cellsize 4} (vec2 2 3)) => (vec2 0.5 0.75)
       (cell-pos {:cellsize 4} (vec2 7 5)) => (vec2 0.75 0.25)
       (cell-pos {:cellsize 4} (vec3 7 5 2)) => (vec3 0.75 0.25 0.5))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn corner-vectors
  [{:keys [dimensions] :as params} point]
  (let [cell-pos (cell-pos params point)]
    (tensor/compute-tensor (repeat dimensions 2) (fn [& args] (sub cell-pos (apply vec-n (reverse args)))))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Compute relative vectors from cell corners to point in cell"
       (let [v2 (corner-vectors {:cellsize 4 :dimensions 2} (vec2 7 6))
             v3 (corner-vectors {:cellsize 4 :dimensions 3} (vec3 7 6 5))]
         (v2 0 0) => (vec2 0.75 0.5)
         (v2 0 1) => (vec2 -0.25 0.5)
         (v2 1 0) => (vec2 0.75 -0.5)
         (v2 1 1) => (vec2 -0.25 -0.5)
         (v3 0 0 0) => (vec3 0.75 0.5 0.25)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn corner-gradients
  [{:keys [dimensions] :as params} gradients point]
  (let [division (map (partial division-index params) point)]
    (tensor/compute-tensor (repeat dimensions 2) (fn [& coords] (apply wrap-get gradients (map + (reverse division) coords))))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Get 2x2 tensor of gradients from a larger tensor using wrap around"
       (let [gradients2 (tensor/compute-tensor [4 6] (fn [y x] (vec2 x y)))
             gradients3 (tensor/compute-tensor [4 6 8] (fn [z y x] (vec3 x y z))) ]
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 0 0) => (vec2 2 1)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 0 1) => (vec2 3 1)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 1 0) => (vec2 2 2)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 9 6)) 1 1) => (vec2 3 2)
         ((corner-gradients {:cellsize 4 :dimensions 2} gradients2 (vec2 23 15)) 1 1) => (vec2 0 0)
         ((corner-gradients {:cellsize 4 :dimensions 3} gradients3 (vec3 9 6 3)) 0 0 0) => (vec3 2 1 0)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn influence-values
  [gradients vectors]
  (tensor/compute-tensor (repeat (count (dtype/shape gradients)) 2)
                         (fn [& args] (dot (apply gradients args) (apply vectors args))) :double))
```
:::



::: {.sourceClojure}
```clojure
(facts "Compute influence values from corner vectors and gradients"
       (let [gradients2 (tensor/compute-tensor [2 2] (fn [_y x] (vec2 x 10)))
             vectors2   (tensor/compute-tensor [2 2] (fn [y _x] (vec2 1 y)))
             influence2 (influence-values gradients2 vectors2)
             gradients3 (tensor/compute-tensor [2 2 2] (fn [z y x] (vec3 x y z)))
             vectors3   (tensor/compute-tensor [2 2 2] (fn [_z _y _x] (vec3 1 10 100)))
             influence3 (influence-values gradients3 vectors3)]
         (influence2 0 0) => 0.0
         (influence2 0 1) => 1.0
         (influence2 1 0) => 10.0
         (influence2 1 1) => 11.0
         (influence3 1 1 1) => 111.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn ease-curve
  [t]
  (-> t (* 6.0) (- 15.0) (* t) (+ 10.0) (* t t t)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Monotonously increasing function with zero derivative at zero and one"
       (ease-curve 0.0) => 0.0
       (ease-curve 0.25) => (roughly 0.103516 1e-6)
       (ease-curve 0.5) => 0.5
       (ease-curve 0.75) => (roughly 0.896484 1e-6)
       (ease-curve 1.0) => 1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(-> (tc/dataset {:t (range 0.0 1.025 0.025) :ease (map ease-curve (range 0.0 1.025 0.025))})
    (plotly/base {:=title "Ease Curve"})
    (plotly/layer-line {:=x :t :=y :ease}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,1.5044921875000003E-4,0.001158125,0.003758378906250001,0.008560000000000002,0.01605224609375,0.026611875,0.04051017578124999,0.05791999999999999,0.07892279296874999,0.10351562499999996,0.13161822265624998,0.16308000000000003,0.19768708984375005,0.23516937500000007,0.27520751953125006,0.31744000000000017,0.36147013671875017,0.4068731250000002,0.4532030664062503,0.5000000000000001,0.5467969335937503,0.5931268750000003,0.6385298632812504,0.6825600000000003,0.7247924804687504,0.7648306250000004,0.8023129101562504,0.8369200000000006,0.8683817773437502,0.8964843750000004,0.9210772070312503,0.9420800000000003,0.9594898242187506,0.9733881249999998,0.9839477539062503,0.9914399999999999,0.9962416210937496,0.9988418749999993,0.9998495507812496,1.0000000000000013],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,0.025,0.05,0.07500000000000001,0.1,0.125,0.15000000000000002,0.17500000000000002,0.2,0.225,0.25,0.275,0.30000000000000004,0.325,0.35000000000000003,0.375,0.4,0.42500000000000004,0.45,0.47500000000000003,0.5,0.525,0.55,0.5750000000000001,0.6000000000000001,0.625,0.65,0.675,0.7000000000000001,0.7250000000000001,0.75,0.775,0.8,0.8250000000000001,0.8500000000000001,0.875,0.9,0.925,0.9500000000000001,0.9750000000000001,1.0],"text":null}], {"width":500,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"t","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"ease","showgrid":true},"title":"Ease Curve"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(defn interpolation-weights
  ([params point]
   (interpolation-weights (cell-pos params point)))
  ([pos]
   (if (seq pos)
     (let [w1   (- 1.0 (last pos))
           w2   (last pos)
           elem (interpolation-weights (butlast pos))]
       (tensor/->tensor [(dfn/* (ease-curve w1) elem) (dfn/* (ease-curve w2) elem)]))
     1.0)))
```
:::



::: {.sourceClojure}
```clojure
(facts "Interpolation weights"
       (let [weights2 (interpolation-weights {:cellsize 8} (vec2 2 7))
             weights3 (interpolation-weights {:cellsize 8} (vec3 2 7 3))]
         (weights2 0 0) => (roughly 0.014391 1e-6)
         (weights2 0 1) => (roughly 0.001662 1e-6)
         (weights2 1 0) => (roughly 0.882094 1e-6)
         (weights2 1 1) => (roughly 0.101854 1e-6)
         (weights3 0 0 0) => (roughly 0.010430 1e-6)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn perlin-sample
  [params gradients point]
  (let [gradients (corner-gradients params gradients point)
        vectors   (corner-vectors params point)
        influence (influence-values gradients vectors)
        weights   (interpolation-weights params point)]
    (dfn/reduce-+ (dfn/* weights influence))))
```
:::



::: {.sourceClojure}
```clojure
(defn perlin-noise
  [{:keys [size dimensions] :as params}]
  (let [gradients (random-gradients params)]
    (tensor/clone
      (tensor/compute-tensor (repeat dimensions size)
                             (fn [& args]
                                 (let [center (add (apply vec-n (reverse args)) (apply vec-n (repeat dimensions 0.5)))]
                                   (perlin-sample params gradients center)))
                             :double))))
```
:::



::: {.sourceClojure}
```clojure
(def perlin (perlin-noise (make-noise-params 256 8 2)))
```
:::



::: {.sourceClojure}
```clojure
(def perlin-norm (dfn/* (/ 255 (- (dfn/reduce-max perlin) (dfn/reduce-min perlin))) (dfn/- perlin (dfn/reduce-min perlin))))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image perlin-norm)
```
:::


::: {.clay-image}
![](main_files/image1.png)
:::



# Combination of Worley and Perlin noise


::: {.sourceClojure}
```clojure
(def perlin-worley-norm (dfn/+ (dfn/* 0.3 perlin-norm) (dfn/* 0.7 worley-norm)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (dfn/+ (dfn/* 0.5 perlin-norm) (dfn/* 0.5 worley-norm)))
```
:::


::: {.clay-image}
![](main_files/image2.png)
:::



# Interpolation


::: {.sourceClojure}
```clojure
(defn interpolate
  [tensor & args]
  (if (seq args)
    (let [x  (first args)
          xc (- x 0.5)
          xf (frac xc)
          x0 (int (Math/floor xc))]
      (+ (* (- 1.0 xf) (apply interpolate (wrap-get tensor      x0 ) (rest args)))
         (*        xf  (apply interpolate (wrap-get tensor (inc x0)) (rest args)))))
    tensor))
```
:::



::: {.sourceClojure}
```clojure
(facts "Interpolate values of tensor"
       (let [x2 (tensor/compute-tensor [4 6] (fn [_y x] x))
             y2 (tensor/compute-tensor [4 6] (fn [y _x] y))
             x3 (tensor/compute-tensor [4 6 8] (fn [_z _y x] x))
             y3 (tensor/compute-tensor [4 6 8] (fn [_z y _x] y))
             z3 (tensor/compute-tensor [4 6 8] (fn [z _y _x] z))]
         (interpolate x2 2.5 3.5) => 3.0
         (interpolate y2 2.5 3.5) => 2.0
         (interpolate x2 2.5 4.0) => 3.5
         (interpolate y2 3.0 3.5) => 2.5
         (interpolate x2 0.0 0.0) => 2.5
         (interpolate y2 0.0 0.0) => 1.5
         (interpolate x3 2.5 3.5 5.5) => 5.0
         (interpolate y3 2.5 3.5 3.0) => 3.0
         (interpolate z3 2.5 3.5 5.5) => 2.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



# Octaves of noise


::: {.sourceClojure}
```clojure
(defn fractal-brownian-motion
  [base octaves & args]
  (let [scales (take (count octaves) (iterate #(* 2 %) 1))]
    (reduce + 0.0 (map (fn [amplitude scale] (* amplitude (apply base (map #(* scale %) args)))) octaves scales))))
```
:::



::: {.sourceClojure}
```clojure
(facts "Fractal Brownian motion"
       (let [base1 (fn [x] (if (>= (mod x 2.0) 1.0) 1.0 0.0))
             base2 (fn [y x] (if (= (Math/round (mod y 2.0)) (Math/round (mod x 2.0))) 0.0 1.0))]
         (fractal-brownian-motion base2 [1.0] 0 0) => 0.0
         (fractal-brownian-motion base2 [1.0] 0 1) => 1.0
         (fractal-brownian-motion base2 [1.0] 1 0) => 1.0
         (fractal-brownian-motion base2 [1.0] 1 1) => 0.0
         (fractal-brownian-motion base2 [0.5] 0 1) => 0.5
         (fractal-brownian-motion base2 [] 0 1) => 0.0
         (fractal-brownian-motion base2 [0.0 1.0] 0 0) => 0.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.0 0.5) => 1.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.5 0.0) => 1.0
         (fractal-brownian-motion base2 [0.0 1.0] 0.5 0.5) => 0.0
         (fractal-brownian-motion base1 [1.0] 0) => 0.0
         (fractal-brownian-motion base1 [1.0] 1) => 1.0
         (fractal-brownian-motion base1 [0.0 1.0] 0.0) => 0.0
         (fractal-brownian-motion base1 [0.0 1.0] 0.5) => 1.0))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn remap
  [value low1 high1 low2 high2]
  (dfn/+ low2 (dfn/* (dfn/- value low1) (/ (- high2 low2) (- high1 low1)))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Remap values of tensor"
       (fact ((remap (tensor/->tensor [?value]) ?low1 ?high1 ?low2 ?high2) 0) => ?expected)
       ?value ?low1 ?high1 ?low2 ?high2 ?expected
       0      0     1      0     1      0
       1      0     1      0     1      1
       0      0     1      2     3      2
       1      0     1      2     3      3
       2      2     3      0     1      0
       3      2     3      0     1      1
       1      0     2      0     4      2)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn clamp
  [value low high]
  (dfn/max low (dfn/min value high)))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Clamp values of tensor"
       (fact ((clamp (tensor/->tensor [?value]) ?low ?high) 0) => ?expected)
       ?value ?low ?high ?expected
       2      2    3      2
       3      2    3      3
       0      2    3      2
       4      2    3      3)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(defn octaves
  [n decay]
  (let [series (take n (iterate #(* % decay) 1.0))
        sum    (apply + series)]
    (mapv #(/ % sum) series)))
```
:::



::: {.sourceClojure}
```clojure
(octaves 4 0.5)
```
:::



::: {.printedClojure}
```clojure
[0.5333333333333333
 0.26666666666666666
 0.13333333333333333
 0.06666666666666667]

```
:::



::: {.sourceClojure}
```clojure
(defn noise-octaves
  [tensor octaves low high]
  (tensor/clone
    (clamp
      (remap
        (tensor/compute-tensor (dtype/shape tensor)
                               (fn [& args]
                                   (apply fractal-brownian-motion
                                     (partial interpolate tensor)
                                     octaves
                                     (map #(+ % 0.5) args)))
                               :double)
        low high 0 255)
      0 255)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves worley-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image3.png)
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves perlin-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image4.png)
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (noise-octaves perlin-worley-norm (octaves 4 0.6) 120 230))
```
:::


::: {.clay-image}
![](main_files/image5.png)
:::



# Testing shaders


::: {.sourceClojure}
```clojure
(GLFW/glfwInit)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def window-width 640)
```
:::



::: {.sourceClojure}
```clojure
(def window-height 480)
```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwDefaultWindowHints)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwWindowHint GLFW/GLFW_VISIBLE GLFW/GLFW_FALSE)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(def window (GLFW/glfwCreateWindow window-width window-height "Invisible Window" 0 0))
```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwMakeContextCurrent window)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GL/createCapabilities)
```
:::



::: {.printedClojure}
```clojure
#object[org.lwjgl.opengl.GLCapabilities 0x6aa8f2e2 "org.lwjgl.opengl.GLCapabilities@6aa8f2e2"]

```
:::



::: {.sourceClojure}
```clojure
(defn make-shader [source shader-type]
  (let [shader (GL20/glCreateShader shader-type)]
    (GL20/glShaderSource shader source)
    (GL20/glCompileShader shader)
    (when (zero? (GL20/glGetShaderi shader GL20/GL_COMPILE_STATUS))
      (throw (Exception. (GL20/glGetShaderInfoLog shader 1024))))
    shader))
```
:::



::: {.sourceClojure}
```clojure
(defn make-program [& shaders]
  (let [program (GL20/glCreateProgram)]
    (doseq [shader shaders]
           (GL20/glAttachShader program shader)
           (GL20/glDeleteShader shader))
    (GL20/glLinkProgram program)
    (when (zero? (GL20/glGetProgrami program GL20/GL_LINK_STATUS))
      (throw (Exception. (GL20/glGetProgramInfoLog program 1024))))
    program))
```
:::



::: {.sourceClojure}
```clojure
(defn make-program-with-shaders
  [vertex-shader-sources fragment-shader-sources]
  (let [vertex-shaders   (map #(make-shader % GL20/GL_VERTEX_SHADER) vertex-shader-sources)
        fragment-shaders (map #(make-shader % GL20/GL_FRAGMENT_SHADER) fragment-shader-sources)
        program          (apply make-program (concat vertex-shaders fragment-shaders))]
    program))
```
:::



::: {.sourceClojure}
```clojure
(def vertex-test "
#version 130
in vec3 point;
void main()
{
  gl_Position = vec4(point, 1);
}")
```
:::



::: {.sourceClojure}
```clojure
(def fragment-test "
#version 130
out vec4 fragColor;
void main()
{
  fragColor = vec4(1, 1, 1, 1);
}")
```
:::



::: {.sourceClojure}
```clojure
(defmacro def-make-buffer [method create-buffer]
  `(defn ~method [data#]
     (let [buffer# (~create-buffer (count data#))]
       (.put buffer# data#)
       (.flip buffer#)
       buffer#)))
```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-float-buffer BufferUtils/createFloatBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-float-buffer

```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-int-buffer BufferUtils/createIntBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-int-buffer

```
:::



::: {.sourceClojure}
```clojure
(def-make-buffer make-byte-buffer BufferUtils/createByteBuffer)
```
:::



::: {.printedClojure}
```clojure
#'volumetric-clouds.main/make-byte-buffer

```
:::



::: {.sourceClojure}
```clojure
(defn setup-vao [vertices indices]
  (let [vao (GL30/glGenVertexArrays)
        vbo (GL15/glGenBuffers)
        ibo (GL15/glGenBuffers)]
    (GL30/glBindVertexArray vao)
    (GL15/glBindBuffer GL15/GL_ARRAY_BUFFER vbo)
    (GL15/glBufferData GL15/GL_ARRAY_BUFFER (make-float-buffer vertices)
                       GL15/GL_STATIC_DRAW)
    (GL15/glBindBuffer GL15/GL_ELEMENT_ARRAY_BUFFER ibo)
    (GL15/glBufferData GL15/GL_ELEMENT_ARRAY_BUFFER (make-int-buffer indices)
                       GL15/GL_STATIC_DRAW)
    {:vao vao :vbo vbo :ibo ibo}))
```
:::



::: {.sourceClojure}
```clojure
(defn teardown-vao [{:keys [vao vbo ibo]}]
  (GL15/glBindBuffer GL15/GL_ELEMENT_ARRAY_BUFFER 0)
  (GL15/glDeleteBuffers ibo)
  (GL15/glBindBuffer GL15/GL_ARRAY_BUFFER 0)
  (GL15/glDeleteBuffers vbo)
  (GL30/glBindVertexArray 0)
  (GL15/glDeleteBuffers vao))
```
:::



::: {.sourceClojure}
```clojure
(defn float-buffer->array
  "Convert float buffer to flaot array"
  [buffer]
  (let [result (float-array (.limit buffer))]
    (.get buffer result)
    (.flip buffer)
    result))
```
:::



::: {.sourceClojure}
```clojure
(defn make-texture-2d
  [width height]
  (let [texture (GL11/glGenTextures)]
    (GL11/glBindTexture GL11/GL_TEXTURE_2D texture)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_MIN_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_MAG_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_WRAP_S GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_2D GL11/GL_TEXTURE_WRAP_T GL11/GL_REPEAT)
    (GL42/glTexStorage2D GL11/GL_TEXTURE_2D 1 GL30/GL_RGBA32F width height)
    texture))
```
:::



::: {.sourceClojure}
```clojure
(defn read-texture-2d
  [texture width height]
  (let [buffer (BufferUtils/createFloatBuffer (* height width 4))]
    (GL11/glBindTexture GL11/GL_TEXTURE_2D texture)
    (GL11/glGetTexImage GL11/GL_TEXTURE_2D 0 GL12/GL_RGBA GL11/GL_FLOAT buffer)
    (float-buffer->array buffer)))
```
:::



::: {.sourceClojure}
```clojure
(defmacro framebuffer-render
  [texture width height & body]
  `(let [fbo# (GL30/glGenFramebuffers)]
     (GL30/glBindFramebuffer GL30/GL_FRAMEBUFFER fbo#)
     (GL11/glBindTexture GL11/GL_TEXTURE_2D ~texture)
     (GL32/glFramebufferTexture GL30/GL_FRAMEBUFFER GL30/GL_COLOR_ATTACHMENT0 ~texture 0)
     (GL20/glDrawBuffers (volumetric-clouds.main/make-int-buffer (int-array [GL30/GL_COLOR_ATTACHMENT0])))
     (GL11/glViewport 0 0 ~width ~height)
     (let [result# (do ~@body)]
       (GL30/glBindFramebuffer GL30/GL_FRAMEBUFFER 0)
       (GL30/glDeleteFramebuffers fbo#)
       result#)))
```
:::



::: {.sourceClojure}
```clojure
(defn setup-point-attribute
  [program]
  (let [point-attribute (GL20/glGetAttribLocation program "point")]
    (GL20/glVertexAttribPointer point-attribute 3 GL11/GL_FLOAT false (* 3 Float/BYTES) (* 0 Float/BYTES))
    (GL20/glEnableVertexAttribArray point-attribute)))
```
:::



::: {.sourceClojure}
```clojure
(defn setup-quad-vao
  []
  (let [vertices (float-array [1.0 1.0 0.0, -1.0 1.0 0.0, -1.0 -1.0 0.0, 1.0 -1.0 0.0])
        indices  (int-array [0 1 2 3])]
    (setup-vao vertices indices)))
```
:::



::: {.sourceClojure}
```clojure
(defmacro render-array
  [width height & body]
  `(let [texture# (volumetric-clouds.main/make-texture-2d ~width ~height)]
     (volumetric-clouds.main/framebuffer-render texture# ~width ~height ~@body)
     (let [result# (volumetric-clouds.main/read-texture-2d texture# ~width ~height)]
       (GL11/glDeleteTextures texture#)
       result#)))
```
:::



::: {.sourceClojure}
```clojure
(defn render-pixel
  [vertex-sources fragment-sources]
  (let [program (make-program-with-shaders vertex-sources fragment-sources)
        vao     (setup-quad-vao)]
    (setup-point-attribute program)
    (let [result
          (render-array 1 1
                        (GL20/glUseProgram program)
                        (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))]
      (teardown-vao vao)
      (GL20/glDeleteProgram program)
      result)))
```
:::



::: {.sourceClojure}
```clojure
(render-pixel [vertex-test] [fragment-test])
```
:::



::: {.printedClojure}
```clojure
[1.0, 1.0, 1.0, 1.0]

```
:::



# Noise octaves shader


::: {.sourceClojure}
```clojure
(def noise-mock
"#version 130
float noise(vec3 idx)
{
  ivec3 v = ivec3(floor(idx.x), floor(idx.y), floor(idx.z)) % 2;
  return ((v.x == 1) == (v.y == 1)) == (v.z == 1) ? 1.0 : 0.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def noise-probe
  (template/fn [x y z]
"#version 130
out vec4 fragColor;
float noise(vec3 idx);
void main()
{
  fragColor = vec4(noise(vec3(<%= x %>, <%= y %>, <%= z %>)));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test noise mock"
         (fact (nth (render-pixel [vertex-test] [noise-mock (noise-probe ?x ?y ?z)]) 0) => ?result)
         ?x ?y ?z ?result
         0  0  0  0.0
         1  0  0  1.0
         0  1  0  1.0
         1  1  0  0.0
         0  0  1  1.0
         1  0  1  0.0
         0  1  1  0.0
         1  1  1  1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def noise-octaves
  (template/fn [octaves]
"#version 130
out vec4 fragColor;
float noise(vec3 idx);
float octaves(vec3 idx)
{
  float result = 0.0;
<% (doseq [multiplier octaves] %>
  result += <%= multiplier %> * noise(idx);
  idx *= 2.0;
<%= ) %>
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def octaves-probe
  (template/fn [x y z]
"#version 130
out vec4 fragColor;
float octaves(vec3 idx);
void main()
{
  fragColor = vec4(octaves(vec3(<%= x %>, <%= y %>, <%= z %>)));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test octaves of noise"
         (fact (first (render-pixel [vertex-test] [noise-mock (noise-octaves ?octaves) (octaves-probe ?x ?y ?z)]))
               => ?result)
         ?x  ?y ?z ?octaves  ?result
         0   0  0  [1.0]     0.0
         1   0  0  [1.0]     1.0
         1   0  0  [0.5]     0.5
         0.5 0  0  [0.0 1.0] 1.0
         0.5 0  0  [0.0 1.0] 1.0
         1   0  0  [1.0 0.0] 1.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



# Shader for intersecting a ray with a box


::: {.sourceClojure}
```clojure
(def ray-box
"#version 130
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction)
{
  vec3 inv_dir = 1.0 / direction;
  vec3 smin = (box_min - origin) * inv_dir;
  vec3 smax = (box_max - origin) * inv_dir;
  vec3 s1 = min(smin, smax);
  vec3 s2 = max(smin, smax);
  float s_near = max(max(s1.x, s1.y), s1.z);
  float s_far = min(min(s2.x, s2.y), s2.z);
  if (isinf(s_near) || isinf(s_far))
    return vec2(0.0, 0.0);
  else
    return vec2(max(s_near, 0.0), max(0.0, s_far));
}")
```
:::



::: {.sourceClojure}
```clojure
(def ray-box-probe
  (template/fn [ox oy oz dx dy dz]
"#version 130
out vec4 fragColor;
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
void main()
{
  vec3 box_min = vec3(-1, -1, -1);
  vec3 box_max = vec3(1, 1, 1);
  vec3 origin = vec3(<%= ox %>, <%= oy %>, <%= oz %>);
  vec3 direction = vec3(<%= dx %>, <%= dy %>, <%= dz %>);
  fragColor = vec4(ray_box(box_min, box_max, origin, direction), 0, 0);
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test intersection of ray with box"
         (fact ((juxt first second) (render-pixel [vertex-test] [ray-box (ray-box-probe ?ox ?oy ?oz ?dx ?dy ?dz)]))
               => ?result)
         ?ox ?oy ?oz ?dx ?dy ?dz ?result
         -2   0   0   1   0   0  [1.0 3.0]
         -2   0   0   2   0   0  [0.5 1.5]
         -2   2   2   1   0   0  [0.0 0.0]
          0  -2   0   0   1   0  [1.0 3.0]
          0  -2   0   0   2   0  [0.5 1.5]
          2  -2   2   0   1   0  [0.0 0.0]
          0   0  -2   0   0   1  [1.0 3.0]
          0   0  -2   0   0   2  [0.5 1.5]
          2   2  -2   0   0   1  [0.0 0.0]
          0   0   0   1   0   0  [0.0 1.0]
          2   0   0   1   0   0  [0.0 0.0])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



# Shader for light transfer through clouds


::: {.sourceClojure}
```clojure
(def fog
  (template/fn [v]
"#version 130
float fog(vec3 idx)
{
  return <%= v %>;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def cloud-transfer
  (template/fn [noise step]
"#version 130
#define STEP <%= step %>
float <%= noise %>(vec3 idx);
float in_scatter(vec3 point, vec3 direction);
float shadow(vec3 point);
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval)
{
  vec4 result = vec4(0, 0, 0, 0);
  for (float t = interval.x + 0.5 * STEP; t < interval.y; t += STEP) {
    vec3 point = origin + direction * t;
    float density = <%= noise %>(point);
    float transmittance = exp(-density * STEP);
    vec3 color = vec3(in_scatter(point, direction) * shadow(point));
    result.rgb += color * (1.0 - result.a) * (1.0 - transmittance);
    result.a = 1.0 - (1.0 - result.a) * transmittance;
  };
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(def constant-scatter
"#version 130
float in_scatter(vec3 point, vec3 direction)
{
  return 1.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def no-shadow
"#version 130
float shadow(vec3 point)
{
  return 1.0;
}")
```
:::



::: {.sourceClojure}
```clojure
(def cloud-transfer-probe
  (template/fn [a b]
"#version 130
out vec4 fragColor;
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval);
void main()
{
  vec3 origin = vec3(0, 0, 0);
  vec3 direction = vec3(1, 0, 0);
  vec2 interval = vec2(<%= a %>, <%= b %>);
  fragColor = cloud_transfer(origin, direction, interval);
}"))
```
:::



::: {.sourceClojure}
```clojure
(defn roughly-vector
  [expected error]
  (fn [actual]
      (and (== (count expected) (count actual))
           (<= (apply + (mapv (fn [a b] (* (- b a) (- b a))) actual expected)) (* error error)))))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Test cloud transfer"
         (fact (seq (render-pixel [vertex-test] [(fog ?density) constant-scatter no-shadow (cloud-transfer "fog" ?step) (cloud-transfer-probe ?a ?b)]))
               => (roughly-vector ?result 1e-3))
         ?a ?b ?step ?density ?result
         0  0  1     0.0      [0.0 0.0 0.0 0.0]
         0  1  1     1.0      [0.632 0.632 0.632 0.632]
         0  1  0.5   1.0      [0.632 0.632 0.632 0.632]
         0  1  0.5   0.5      [0.393 0.393 0.393 0.393])
```
:::



::: {.printedClojure}
```clojure
true

```
:::



# Rendering of fog box


::: {.sourceClojure}
```clojure
(def fragment-cloud
"#version 130
uniform vec2 resolution;
uniform vec3 light;
uniform mat3 rotation;
uniform float focal_length;
uniform float distance;
out vec4 fragColor;
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
vec4 cloud_transfer(vec3 origin, vec3 direction, vec2 interval);
void main()
{
  vec3 direction = normalize(rotation * vec3(gl_FragCoord.xy - 0.5 * resolution, focal_length));
  vec3 origin = rotation * vec3(0, 0, -distance);
  vec2 interval = ray_box(vec3(-0.5, -0.5, -0.5), vec3(0.5, 0.5, 0.5), origin, direction);
  vec4 transfer = cloud_transfer(origin, direction, interval);
  vec3 background = mix(vec3(0.125, 0.125, 0.25), vec3(1, 1, 1), pow(dot(direction, light), 1000.0));
  fragColor = vec4(background * (1.0 - transfer.a) + transfer.rgb, 1.0);
}")
```
:::



::: {.sourceClojure}
```clojure
(defn setup-fog-uniforms
  [program width height]
  (let [rotation     (mulm (rotation-matrix-3d-y (to-radians 30.0)) (rotation-matrix-3d-x (to-radians -20.0)))
        focal-length (/ (* 0.5 width) (tan (to-radians 30.0)))
        light        (normalize (vec3 4 1 10))]
    (GL20/glUseProgram program)
    (GL20/glUniform2f (GL20/glGetUniformLocation program "resolution") width height)
    (GL20/glUniform3f (GL20/glGetUniformLocation program "light") (light 0) (light 1) (light 2))
    (GL20/glUniformMatrix3fv (GL20/glGetUniformLocation program "rotation") true
                             (make-float-buffer (mat->float-array rotation)))
    (GL20/glUniform1f (GL20/glGetUniformLocation program "focal_length") focal-length)
    (GL20/glUniform1f (GL20/glGetUniformLocation program "distance") 2.0)))
```
:::



::: {.sourceClojure}
```clojure
(defn render-fog
  [width height]
  (let [fragment-sources [ray-box constant-scatter no-shadow (cloud-transfer "fog" 0.01) (fog 1.0) fragment-cloud]
        program          (make-program-with-shaders [vertex-test] fragment-sources)
        vao              (setup-quad-vao)]
    (setup-point-attribute program)
    (let [result
          (render-array width height
                        (setup-fog-uniforms program width height)
                        (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))]
      (teardown-vao vao)
      (GL20/glDeleteProgram program)
      result)))
```
:::



::: {.sourceClojure}
```clojure
(defn rgba-array->bufimg [data width height]
  (-> data tensor/->tensor (tensor/reshape [height width 4]) (tensor/select :all :all [2 1 0]) (dfn/* 255) (clamp 0 255)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-fog 640 480) 640 480))
```
:::


::: {.clay-image}
![](main_files/image6.png)
:::



# Rendering of 3D noise


::: {.sourceClojure}
```clojure
(defn float-array->texture3d
  [data size]
  (let [buffer  (make-float-buffer data)
        texture (GL11/glGenTextures)]
    (GL11/glBindTexture GL12/GL_TEXTURE_3D texture)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_MIN_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_MAG_FILTER GL11/GL_LINEAR)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_WRAP_S GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL11/GL_TEXTURE_WRAP_T GL11/GL_REPEAT)
    (GL11/glTexParameteri GL12/GL_TEXTURE_3D GL12/GL_TEXTURE_WRAP_R GL11/GL_REPEAT)
    (GL12/glTexImage3D GL12/GL_TEXTURE_3D 0 GL30/GL_R32F size size size 0 GL11/GL_RED GL11/GL_FLOAT buffer)
    texture))
```
:::



::: {.sourceClojure}
```clojure
(def noise3d (dfn/- (dfn/* 0.3 (perlin-noise (make-noise-params 32 4 3)))
                    (dfn/* 0.7 (worley-noise (make-noise-params 32 4 3)))))
```
:::



::: {.sourceClojure}
```clojure
(def noise-3d-norm (dfn/* (/ 1.0 (- (dfn/reduce-max noise3d) (dfn/reduce-min noise3d))) (dfn/- noise3d (dfn/reduce-min noise3d))))
```
:::



::: {.sourceClojure}
```clojure
(def noise-texture (float-array->texture3d (dtype/->float-array noise-3d-norm) 32))
```
:::



::: {.sourceClojure}
```clojure
(def noise-shader
"#version 130
uniform sampler3D noise3d;
float noise(vec3 idx)
{
  return texture(noise3d, idx).r;
}")
```
:::



::: {.sourceClojure}
```clojure
(defn setup-noise-uniforms
  [program width height]
  (setup-fog-uniforms program width height)
  (GL20/glUniform1i (GL20/glGetUniformLocation program "noise3d") 0)
  (GL13/glActiveTexture GL13/GL_TEXTURE0)
  (GL11/glBindTexture GL12/GL_TEXTURE_3D noise-texture))
```
:::



::: {.sourceClojure}
```clojure
(defn render-noise
  [width height & cloud-shaders]
  (let [fragment-sources (concat cloud-shaders [ray-box fragment-cloud])
        program          (make-program-with-shaders [vertex-test] fragment-sources)
        vao              (setup-quad-vao)]
    (setup-point-attribute program)
    (let [result
          (render-array width height
                        (setup-noise-uniforms program width height)
                        (GL11/glDrawElements GL11/GL_QUADS 4 GL11/GL_UNSIGNED_INT 0))]
      (teardown-vao vao)
      (GL20/glDeleteProgram program)
      result)))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-noise 640 480 constant-scatter no-shadow (cloud-transfer "noise" 0.01) noise-shader) 640 480))
```
:::


::: {.clay-image}
![](main_files/image7.png)
:::



# Remap and clamp 3D noise


::: {.sourceClojure}
```clojure
(def remap-clamp
"#version 130
float remap_clamp(float value, float low1, float high1, float low2, float high2)
{
  float t = (value - low1) / (high1 - low1);
  return clamp(low2 + t * (high2 - low2), low2, high2);
}")
```
:::



::: {.sourceClojure}
```clojure
(def remap-probe
  (template/fn [value low1 high1 low2 high2]
"#version 130
out vec4 fragColor;
float remap_clamp(float value, float low1, float high1, float low2, float high2);
void main()
{
  fragColor = vec4(remap_clamp(<%= value %>, <%= low1 %>, <%= high1 %>, <%= low2 %>, <%= high2 %>));
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Remap and clamp input parameter values"
       (fact (first (render-pixel [vertex-test] [remap-clamp (remap-probe ?value ?low1 ?high1 ?low2 ?high2)]))
             => ?expected)
       ?value ?low1 ?high1 ?low2 ?high2 ?expected
       0      0     1      0     1      0.0
       1      0     1      0     1      1.0
       0      0     1      2     3      2.0
       1      0     1      2     3      3.0
       2      2     3      0     1      0.0
       3      2     3      0     1      1.0
       1      0     2      0     4      2.0
       0      1     2      1     2      1.0
       3      1     2      1     2      2.0)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(def remap-noise
  (template/fn [base low1 high1 high2]
"#version 130
float <%= base %>(vec3 idx);
float remap_clamp(float value, float low1, float high1, float low2, float high2);
float remap_noise(vec3 idx)
{
  return remap_clamp(<%= base %>(idx), <%= low1 %>, <%= high1 %>, 0.0, <%= high2 %>);
}"))
```
:::



::: {.sourceClojure}
```clojure
(def cloud-strength 5.0)
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-noise 640 480 constant-scatter no-shadow (cloud-transfer "remap_noise" 0.01) remap-clamp (remap-noise "noise" 0.45 0.9 cloud-strength) noise-shader) 640 480))
```
:::


::: {.clay-image}
![](main_files/image8.png)
:::



# Octaves of 3D noise


::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-noise 640 480 constant-scatter no-shadow (cloud-transfer "remap_noise" 0.01) remap-clamp (remap-noise "octaves" 0.45 0.9 cloud-strength) (noise-octaves (octaves 4 0.5)) noise-shader) 640 480))
```
:::


::: {.clay-image}
![](main_files/image9.png)
:::



::: {.sourceClojure}
```clojure
(def mie-scatter
  (template/fn [g]
"#version 450 core
#define M_PI 3.1415926535897932384626433832795
#define ANISOTROPIC 0.25
#define G <%= g %>
uniform vec3 light;
float mie(float mu)
{
  return 3 * (1 - G * G) * (1 + mu * mu) / (8 * M_PI * (2 + G * G) * pow(1 + G * G - 2 * G * mu, 1.5));
}
float in_scatter(vec3 point, vec3 direction)
{
  return mix(1.0, mie(dot(light, direction)), ANISOTROPIC);
}"))
```
:::



# Mie scattering


::: {.sourceClojure}
```clojure
(def mie-probe
  (template/fn [mu]
"#version 450 core
out vec4 fragColor;
float mie(float mu);
void main()
{
  float result = mie(<%= mu %>);
  fragColor = vec4(result, 0, 0, 1);
}"))
```
:::



::: {.sourceClojure}
```clojure
(tabular "Shader function for scattering phase function"
         (fact (first (render-pixel [vertex-test] [(mie-scatter ?g) (mie-probe ?mu)])) => (roughly ?result 1e-6))
         ?g  ?mu ?result
         0   0   (/ 3 (* 16 PI))
         0   1   (/ 6 (* 16 PI))
         0  -1   (/ 6 (* 16 PI))
         0.5 0   (/ (* 3 0.75) (* 8 PI 2.25 (pow 1.25 1.5)))
         0.5 1   (/ (* 6 0.75) (* 8 PI 2.25 (pow 0.25 1.5))))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-noise 640 480 (mie-scatter 0.76) no-shadow (cloud-transfer "remap_noise" 0.01) remap-clamp (remap-noise "octaves" 0.45 0.9 cloud-strength) (noise-octaves (octaves 4 0.5)) noise-shader) 640 480))
```
:::


::: {.clay-image}
![](main_files/image10.png)
:::



# Self-shading of clouds


::: {.sourceClojure}
```clojure
(def shadow
  (template/fn [noise step]
"#version 130
#define STEP <%= step %>
uniform vec3 light;
float <%= noise %>(vec3 idx);
vec2 ray_box(vec3 box_min, vec3 box_max, vec3 origin, vec3 direction);
float shadow(vec3 point)
{
  vec2 interval = ray_box(vec3(-0.5, -0.5, -0.5), vec3(0.5, 0.5, 0.5), point, light);
  float result = 1.0;
  for (float t = interval.x + 0.5 * STEP; t < interval.y; t += STEP) {
    float density = <%= noise %>(point + t * light);
    float transmittance = exp(-density * STEP);
    result *= transmittance;
  };
  return result;
}"))
```
:::



::: {.sourceClojure}
```clojure
(bufimg/tensor->image (rgba-array->bufimg (render-noise 640 480 (mie-scatter 0.76) (shadow "remap_noise" 0.01) (cloud-transfer "remap_noise" 0.01) remap-clamp (remap-noise "octaves" 0.45 0.9 cloud-strength) (noise-octaves (octaves 4 0.5)) noise-shader) 640 480))
```
:::


::: {.clay-image}
![](main_files/image11.png)
:::



::: {.sourceClojure}
```clojure
(GL11/glDeleteTextures noise-texture)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwDestroyWindow window)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(GLFW/glfwTerminate)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/ClojureCivitas/clojurecivitas.github.io/blob/main/src/volumetric_clouds/main.clj">src/volumetric_clouds/main.clj</a></small></small></pre></div>
```