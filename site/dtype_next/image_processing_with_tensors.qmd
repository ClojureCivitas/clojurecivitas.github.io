---
author:
  name: Daniel Slutsky
  image: https://avatars.githubusercontent.com/u/5673102?v=4
  url: https://scicloj.github.io/contributors/daslu/
  affiliation:
  - {name: Scicloj, url: 'https://scicloj.github.io/'}
  - {name: Endor Global, url: 'https://endor.global'}
  links:
  - {icon: github, href: 'https://github.com/daslu'}
type: post
date: '2025-12-10'
category: data
tags: [dtype-next, tensors, image-processing, computer-vision, tutorial]
image: nap_edges.png
format:
  html: {title: Image Processing with dtype-next Tensors}

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.20.0/plotly.min.js" type="text/javascript"></script>

```{=html}
<style>.clay-dataset {
  max-height:400px; 
  overflow-y: auto;
}
.printedClojure {
  max-height:400px; 
  overflow-y: auto;
}
</style>
```



# Introduction: Why dtype-next for Image Processing?

Images are perfect for learning [dtype-next](https://github.com/cnuernber/dtype-next)
because they're **typed numerical arrays with clear visual feedback**. Unlike generic
sequences where numbers are boxed, dtype-next gives us:


- **Efficient storage**: A 1000×1000 [RGB](https://en.wikipedia.org/wiki/RGB_color_model) image is 3MB of [uint8](https://en.wikipedia.org/wiki/Integer_(computer_science)#Value_and_representation) values, not 12MB+ of [boxed](https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing) objects
- **Zero-copy views**: Slice channels, regions, or transforms without copying data
- **Functional operations**: Element-wise transformations that compose naturally
- **Type discipline**: Explicit control over precision and overflow



## What Are Tensors?

A [tensor](https://en.wikipedia.org/wiki/Tensor_(machine_learning)) is a multi-dimensional
array of numbers with a defined shape and type. While the term comes from mathematics and
physics, in programming it simply means: **structured numerical data with multiple axes**.


- A scalar is a 0D tensor (single number)
- A vector is a 1D tensor `[5]` → 5 elements
- A matrix is a 2D tensor `[3 4]` → 3 rows × 4 columns
- An RGB image is a 3D tensor `[height width 3]` → spatial dimensions + color channels
- A video is a 4D tensor `[time height width 3]` → adding a time axis

Tensors provide efficient storage (typed, contiguous memory) and convenient multi-dimensional
indexing. Operations on tensors (slicing, element-wise math, reductions) form the foundation
of numerical computing, from image processing to machine learning.


## About This Tutorial

dtype-next is a comprehensive library for working with typed arrays, including buffers,
functional operations, tensors, and dataset integration. This tutorial focuses on
**the tensor API**—multi-dimensional views over typed buffers—because images provide
clear visual feedback and natural multi-dimensional structure.

The patterns you'll learn (zero-copy views, type discipline, functional composition)
transfer directly to other dtype-next use cases: time series analysis, scientific
computing, ML data preparation, and any domain requiring efficient numerical arrays.


## What We'll Build


- **Working with Tensors** — reshaping, dataset conversion, core operations
- **Tensor Operations Primer** — slicing, element-wise ops, type handling
- **Image Statistics** — channel means, ranges, distributions, histograms
- **Spatial Analysis** — gradients, edge detection, sharpness metrics  
- **Enhancement Pipeline** — white balance, contrast adjustment
- **Accessibility** — color blindness simulation
- **Convolution & Filtering** — blur, sharpen, Sobel edge detection
- **Downsampling & Multi-Scale Processing** — pyramids, multi-resolution analysis

Each section demonstrates core dtype-next concepts with immediate practical value.

---


# Setup: Loading Images as Tensors

Let's load our sample image and understand the tensor structure.


## The bufimg Namespace


::: {.sourceClojure}
```clojure
(require '[tech.v3.libs.buffered-image :as bufimg])
```
:::


The [`tech.v3.libs.buffered-image`](https://cnuernber.github.io/dtype-next/tech.v3.libs.buffered-image.html)
namespace (aliased as `bufimg`) provides interop between Java's BufferedImage and dtype-next tensors:


- `bufimg/load` — load image file → BufferedImage
- `bufimg/as-ubyte-tensor` — BufferedImage → uint8 tensor [H W C]
- `bufimg/tensor->image` — tensor → BufferedImage (for display)


::: {.sourceClojure}
```clojure
(def original-img
  (bufimg/load "src/dtype_next/nap.jpg"))
```
:::



::: {.sourceClojure}
```clojure
original-img
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image0.png)
:::



::: {.sourceClojure}
```clojure
(def original-tensor
  (bufimg/as-ubyte-tensor original-img))
```
:::



## ⚠️ Important: Understanding Channel Order

BufferedImage can use different [pixel](https://en.wikipedia.org/wiki/Pixel) formats (RGB, BGR, ARGB, etc.). The specific
format depends on the image type and how it was loaded. Our image uses **BGR** order:


::: {.sourceClojure}
```clojure
(bufimg/image-type original-img)
```
:::



::: {.printedClojure}
```clojure
:byte-bgr

```
:::


`:byte-bgr` means this image stores colors in BGR (Blue-Green-Red) order, not RGB.
The `bufimg/as-ubyte-tensor` function preserves whatever order BufferedImage uses.

For this tutorial's BGR images, the channels are:

- **Channel 0 = Blue**
- **Channel 1 = Green**
- **Channel 2 = Red**

Always check `bufimg/image-type` to confirm your image's channel order before
processing. We'll be explicit about BGR ordering throughout this tutorial.

**Why the round-trip works:** `bufimg/tensor->image` defaults to creating BGR
BufferedImages. So our workflow maintains BGR throughout: load BGR → process as
BGR tensor → create BGR image. If you had an RGB tensor, you'd need to either
swap channels or use `(bufimg/tensor->image rgb-tensor {:img-type :int-rgb})`.


::: {.sourceClojure}
```clojure
original-tensor
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<uint8>[960 1280 3]
[[[163 173 173]
  [169 179 179]
  [176 186 186]
  ...
  [ 58  74  87]
  [ 53  69  82]
  [ 51  67  80]]
 [[165 175 175]
  [170 180 180]
  [176 186 186]
  ...
  [ 59  75  88]
  [ 59  75  88]
  [ 58  74  87]]
 [[165 175 175]
  [168 178 178]
  [172 182 182]
  ...
  [ 54  70  83]
  [ 53  69  82]
  [ 50  66  79]]
 ...
 [[ 79  87  94]
  [ 73  81  88]
  [ 67  75  82]
  ...
  [ 78  89 109]
  [ 78  89 109]
  [ 78  89 109]]
 [[ 83  91  98]
  [ 78  86  93]
  [ 75  83  90]
  ...
  [ 78  89 109]
  [ 78  89 109]
  [ 78  89 109]]
 [[ 89  97 104]
  [ 84  92  99]
  [ 82  90  97]
  ...
  [ 78  89 109]
  [ 78  89 109]
  [ 78  89 109]]]

```
:::



## Understanding Tensor Shape


::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype :as dtype])
```
:::


The [`tech.v3.datatype`](https://cnuernber.github.io/dtype-next/tech.v3.datatype.html)
namespace provides core functions for inspecting and manipulating typed data.

**Shape** tells us dimensions:


::: {.sourceClojure}
```clojure
(dtype/shape original-tensor)
```
:::



::: {.printedClojure}
```clojure
[960 1280 3]

```
:::


This is `[height width channels]` — our image has 3 color channels.


::: {.sourceClojure}
```clojure
(def height
  (first (dtype/shape original-tensor)))
```
:::



::: {.sourceClojure}
```clojure
(def width
  (second (dtype/shape original-tensor)))
```
:::


**Element type**:


::: {.sourceClojure}
```clojure
(dtype/elemwise-datatype original-tensor)
```
:::



::: {.printedClojure}
```clojure
:uint8

```
:::


`:uint8` means each pixel component is an unsigned byte (0-255).

**Total elements**:


::: {.sourceClojure}
```clojure
(dtype/ecount original-tensor)
```
:::



::: {.printedClojure}
```clojure
3686400

```
:::


That's `height × width × 3`.

---


# Working with Tensors

Before diving into image analysis, let's understand what tensors are in dtype-next.

**Tensors are multi-dimensional views over typed buffers.** The underlying buffer
is a contiguous block of typed data (like our uint8 pixels), and the tensor provides
convenient multi-dimensional indexing with shape information. This architecture enables
zero-copy operations—when we slice or reshape, we create new views without copying data.

Let's explore essential tensor operations for transforming and converting data.


## The tensor Namespace


::: {.sourceClojure}
```clojure
(require '[tech.v3.tensor :as tensor])
```
:::


The [`tech.v3.tensor`](https://cnuernber.github.io/dtype-next/tech.v3.tensor.html)
namespace provides multi-dimensional array operations—the core of working with
tensors in dtype-next.

**Key functions we'll use:**

- `tensor/compute-tensor` — create tensors by applying a function to each position
- `tensor/select` — extract regions (zero-copy slicing)
- `tensor/slice` / `tensor/slice-right` — iterate through dimensions
- `tensor/reshape` — reinterpret shape without copying
- `tensor/transpose` — reorder dimensions
- `tensor/reduce-axis` — collapse dimensions with aggregation


## Reshaping

Sometimes it's convenient to flatten spatial dimensions into a single axis.
For example, reshaping `[H W 3]` → `[H×W 3]` gives us one row per pixel:


::: {.sourceClojure}
```clojure
(-> original-tensor
    (tensor/reshape [(* height width) 3])
    dtype/shape)
```
:::



::: {.printedClojure}
```clojure
[1228800 3]

```
:::


**Key insight**: `tensor/reshape` is a zero-copy view operation—it reinterprets
the buffer without copying data.


## Tensors as Datasets


::: {.sourceClojure}
```clojure
(require '[tech.v3.dataset.tensor :as ds-tensor])
```
:::



::: {.sourceClojure}
```clojure
(require '[tablecloth.api :as tc])
```
:::


The [`tech.v3.dataset.tensor`](https://cnuernber.github.io/dtype-next/tech.v3.dataset.tensor.html)
namespace provides conversions between tensors and datasets. The `tablecloth.api`
namespace of [Tablecloth](https://scicloj.github.io/tablecloth/)
also auto-converts 2D tensors.

Two-dimensional tensors convert naturally to tablecloth datasets, enabling
tabular operations and plotting.

**Converting tensors ↔ datasets:**

- `ds-tensor/tensor->dataset` — explicit conversion
- `tc/dataset` — tablecloth auto-converts 2D tensors
- `ds-tensor/dataset->tensor` — convert back to tensor


::: {.sourceClojure}
```clojure
(-> original-tensor
    (tensor/reshape [(* height width) 3])
    ds-tensor/tensor->dataset
    (tc/rename-columns [:blue :green :red]))
```
:::


::: {.clay-dataset}
:_unnamed [1228800 3]:

| :blue | :green | :red |
|------:|-------:|-----:|
|   163 |    173 |  173 |
|   169 |    179 |  179 |
|   176 |    186 |  186 |
|   182 |    192 |  192 |
|   186 |    196 |  196 |
|   189 |    199 |  199 |
|   193 |    203 |  203 |
|   195 |    205 |  205 |
|   198 |    208 |  208 |
|   198 |    208 |  208 |
|   ... |    ... |  ... |
|    80 |     91 |  111 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |


:::


Or more concisely (tablecloth auto-converts):


::: {.sourceClojure}
```clojure
(-> original-tensor
    (tensor/reshape [(* height width) 3])
    tc/dataset
    (tc/rename-columns [:blue :green :red]))
```
:::


::: {.clay-dataset}
:_unnamed [1228800 3]:

| :blue | :green | :red |
|------:|-------:|-----:|
|   163 |    173 |  173 |
|   169 |    179 |  179 |
|   176 |    186 |  186 |
|   182 |    192 |  192 |
|   186 |    196 |  196 |
|   189 |    199 |  199 |
|   193 |    203 |  203 |
|   195 |    205 |  205 |
|   198 |    208 |  208 |
|   198 |    208 |  208 |
|   ... |    ... |  ... |
|    80 |     91 |  111 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    79 |     90 |  110 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |
|    78 |     89 |  109 |


:::


We can convert back, restoring the original image structure:


::: {.sourceClojure}
```clojure
(-> original-tensor
    (tensor/reshape [(* height width) 3])
    tc/dataset
    ds-tensor/dataset->tensor
    (tensor/reshape [height width 3])
    bufimg/tensor->image)
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image1.png)
:::


Creates BGR BufferedImage by default

This round-trip demonstrates the seamless interop between tensors and datasets,
useful for combining spatial operations (tensors) with statistical analysis (datasets).

---


# Tensor Operations Primer

Before working with real images, let's explore the core operations we'll use
throughout this tutorial. We'll use tiny toy tensors to demonstrate each concept.


## Creating Tensors: tensor/compute-tensor

`tensor/compute-tensor` creates a tensor by calling a function for each position.
The function receives indices and returns the value for that position.


## Buffers, Readers, and Writers

Before working with tensors, let's understand dtype-next's foundational abstractions.
These concepts will help us understand what happens when we slice, transform, and
process data.


### Buffers: Mutable Typed Storage

A **buffer** is a contiguous block of typed data in memory. It's the fundamental
storage layer—mutable and efficient.


::: {.sourceClojure}
```clojure
(def sample-buffer
  (dtype/make-container :int32 [10 20 30 40 50]))
```
:::



::: {.sourceClojure}
```clojure
sample-buffer
```
:::



::: {.printedClojure}
```clojure
#array-buffer<int32>[5]
[10, 20, 30, 40, 50]

```
:::


Buffers have a data type and element count:


::: {.sourceClojure}
```clojure
(dtype/elemwise-datatype sample-buffer)
```
:::



::: {.printedClojure}
```clojure
:int32

```
:::



::: {.sourceClojure}
```clojure
(dtype/ecount sample-buffer)
```
:::



::: {.printedClojure}
```clojure
5

```
:::



### Readers: Read-Only Views

A **reader** provides read-only access to data. Readers can wrap buffers, transform
values on-the-fly, or generate values lazily. They're how dtype-next creates zero-copy
views and efficient data pipelines.


::: {.sourceClojure}
```clojure
(def sample-reader
  (dtype/->reader sample-buffer))
```
:::


**Important**: Readers act as functions of their index. You can call them directly
instead of using `dtype/get-value`. This pattern extends to tensors as well—both
readers and tensors are callable:


::: {.sourceClojure}
```clojure
(sample-reader 0)
```
:::



::: {.printedClojure}
```clojure
10

```
:::


Map over readers like sequences:


::: {.sourceClojure}
```clojure
(mapv #(* 2 %) sample-reader)
```
:::



::: {.printedClojure}
```clojure
[20 40 60 80 100]

```
:::


**Lazy transformation readers** compute values on access without copying:


::: {.sourceClojure}
```clojure
(def doubled-reader
  (dtype/emap (fn [x] (* x 10)) :int32 sample-buffer))
```
:::


The reader transforms values on-the-fly:


::: {.sourceClojure}
```clojure
(vec doubled-reader)
```
:::



::: {.printedClojure}
```clojure
[100 200 300 400 500]

```
:::


But the original buffer is unchanged:


::: {.sourceClojure}
```clojure
(vec sample-buffer)
```
:::



::: {.printedClojure}
```clojure
[10 20 30 40 50]

```
:::



### Writers: Mutable Access

A **writer** allows modification of the underlying data:


::: {.sourceClojure}
```clojure
(def writable-buffer
  (dtype/make-container :float64 [1.0 2.0 3.0 4.0 5.0]))
```
:::



::: {.sourceClojure}
```clojure
(let [writer (dtype/->writer writable-buffer)]
  (dtype/set-value! writer 2 99.0)
  (dtype/set-value! writer 4 77.0))
```
:::



::: {.printedClojure}
```clojure
#buffer<float64>[5]
[1.000, 2.000, 99.00, 4.000, 77.00]

```
:::



::: {.sourceClojure}
```clojure
writable-buffer
```
:::



::: {.printedClojure}
```clojure
#array-buffer<float64>[5]
[1.000, 2.000, 99.00, 4.000, 77.00]

```
:::



### Why This Matters for Tensors

Tensors are **multi-dimensional views** over buffers. When we slice or reshape tensors,
we often get readers that reference the original data without copying. When we use
`tensor/slice`, we get a **reader of sub-tensors**—each sub-tensor is itself a view
(often a reader) over portions of the underlying buffer.

This architecture enables efficient, composable operations: slice an image into channels,
map a transformation over each channel, and the data flows through without intermediate
copies.


## Creating Tensors: tensor/compute-tensor


::: {.sourceClojure}
```clojure
(def toy-tensor
  (tensor/compute-tensor
   [3 4] ; shape: 3 rows, 4 columns
   (fn [row col] ; function receives [row col] indices
     (+ (* row 10) col)) ; compute value: row*10 + col
   :int32 ; element type
   ))
```
:::


Check an element:


::: {.sourceClojure}
```clojure
(toy-tensor 2 1)
```
:::



::: {.printedClojure}
```clojure
21

```
:::


Verify the shape:


::: {.sourceClojure}
```clojure
(dtype/shape toy-tensor)
```
:::



::: {.printedClojure}
```clojure
[3 4]

```
:::



## Selecting Regions with tensor/select

`tensor/select` extracts portions of a tensor without copying data.
It takes one selector per dimension.

**Selector options:**

- `:all` — keep entire dimension
- `n` (integer) — select single index
- `(range start end)` — select slice from start (inclusive) to end (exclusive)
- `(range start end step)` — select with stride

Example: Select row 1 (second row):


::: {.sourceClojure}
```clojure
(tensor/select toy-tensor 1 :all)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[4]
[10 11 12 13]

```
:::


Select column 2 (third column):


::: {.sourceClojure}
```clojure
(tensor/select toy-tensor :all 2)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[3]
[2 12 22]

```
:::


Select first two rows:


::: {.sourceClojure}
```clojure
(tensor/select toy-tensor (range 0 2) :all)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[2 4]
[[ 0  1  2  3]
 [10 11 12 13]]

```
:::


Select every other column:


::: {.sourceClojure}
```clojure
(tensor/select toy-tensor :all (range 0 4 2))
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[3 2]
[[ 0  2]
 [10 12]
 [20 22]]

```
:::


Select a sub-rectangle (rows 1-2, columns 1-3):


::: {.sourceClojure}
```clojure
(tensor/select toy-tensor (range 1 3) (range 1 4))
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[2 3]
[[11 12 13]
 [21 22 23]]

```
:::


**Key insight**: All these are zero-copy views—no data is copied.


## Element Access: Tensors as Functions

Like readers, tensors act as functions of their indices. You can call them directly
with coordinate arguments:


::: {.sourceClojure}
```clojure
(toy-tensor 1 2)
```
:::



::: {.printedClojure}
```clojure
12

```
:::


This is equivalent to `(tensor/mget toy-tensor 1 2)` but more idiomatic. Both readers
and tensors follow this pattern—they're callable values, not just data structures.


## Slicing Dimensions: tensor/slice and tensor/slice-right

While `tensor/select` extracts specific regions, **slicing** operations turn a tensor
into a **reader of sub-tensors** that we can process one by one. This is essential for
efficiently iterating through rows, columns, or channels.


### tensor/slice (leftmost dimensions)

`tensor/slice` slices off N leftmost dimensions, returning a reader that contains
sub-tensors. You access and process each sub-tensor individually (via `nth`, `map`, etc.).

For a `[3 4]` tensor, slicing off 1 dimension gives us a reader of 3 rows:


::: {.sourceClojure}
```clojure
(def toy-rows (tensor/slice toy-tensor 1))
```
:::



::: {.sourceClojure}
```clojure
toy-rows
```
:::



::: {.printedClojure}
```clojure
[#tech.v3.tensor<int32>[4]
[0 1 2 3] #tech.v3.tensor<int32>[4]
[10 11 12 13] #tech.v3.tensor<int32>[4]
[20 21 22 23]]

```
:::


How many rows?


::: {.sourceClojure}
```clojure
(dtype/ecount toy-rows)
```
:::



::: {.printedClojure}
```clojure
3

```
:::


Get the first row (a `[4]` tensor):


::: {.sourceClojure}
```clojure
(nth toy-rows 0)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[4]
[0 1 2 3]

```
:::


**Use case**: Process sub-tensors one by one efficiently (much faster than manual loops with `select`)


### tensor/slice-right (rightmost dimensions)

`tensor/slice-right` slices off N rightmost dimensions, returning a reader of sub-tensors.
Perfect for extracting channels from `[H W C]` image tensors.

For our `[3 4]` toy tensor, slicing 1 rightmost dimension gives us 4 columns:


::: {.sourceClojure}
```clojure
(def toy-cols (tensor/slice-right toy-tensor 1))
```
:::



::: {.sourceClojure}
```clojure
toy-cols
```
:::



::: {.printedClojure}
```clojure
[#tech.v3.tensor<int32>[3]
[0 10 20] #tech.v3.tensor<int32>[3]
[1 11 21] #tech.v3.tensor<int32>[3]
[2 12 22] #tech.v3.tensor<int32>[3]
[3 13 23]]

```
:::



::: {.sourceClojure}
```clojure
(dtype/ecount toy-cols)
```
:::



::: {.printedClojure}
```clojure
4

```
:::


Get the first column:


::: {.sourceClojure}
```clojure
(nth toy-cols 0)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[3]
[0 10 20]

```
:::


**Key insight**: Both return readers of sub-tensors that you process one by one.

- `tensor/slice` slices leftmost dimensions → iterate through slices (e.g., rows)
- `tensor/slice-right` slices rightmost dimensions → iterate through slices (e.g., channels)


### Practical Example: Channel Extraction

For our BGR image `[H W C]`, we can cleanly extract channels using `slice-right`:


::: {.sourceClojure}
```clojure
(def channels-sliced (tensor/slice-right original-tensor 1))
```
:::


Extract individual channels:


::: {.sourceClojure}
```clojure
(def blue-ch (nth channels-sliced 0))
```
:::



::: {.sourceClojure}
```clojure
(def green-ch (nth channels-sliced 1))
```
:::



::: {.sourceClojure}
```clojure
(def red-ch (nth channels-sliced 2))
```
:::


Each channel is now `[H W]`:


::: {.sourceClojure}
```clojure
(dtype/shape blue-ch)
```
:::



::: {.printedClojure}
```clojure
[960 1280]

```
:::


Compare with the manual approach using `tensor/select`:


::: {.sourceClojure}
```clojure
(def blue-manual (tensor/select original-tensor :all :all 0))
```
:::


Both are zero-copy views, but `slice-right` is cleaner when you need all channels.


## The dfn Namespace: Functional Operations with Broadcasting


::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype.functional :as dfn])
```
:::


The [`tech.v3.datatype.functional`](https://cnuernber.github.io/dtype-next/tech.v3.datatype.functional.html)
namespace (aliased as `dfn`) provides mathematical operations that work **element-wise**
across entire tensors and automatically **[broadcast](https://en.wikipedia.org/wiki/Broadcasting_(parallel_pattern))** when combining tensors of different shapes.

**Element-wise operations:**


::: {.sourceClojure}
```clojure
(def small-tensor (tensor/compute-tensor [2 3] (fn [r c] (+ (* r 3) c)) :int32))
```
:::


Add scalar to every element (broadcasting):


::: {.sourceClojure}
```clojure
(dfn/+ small-tensor 10)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int64>[2 3]
[[10 11 12]
 [13 14 15]]

```
:::


Multiply every element:


::: {.sourceClojure}
```clojure
(dfn/* small-tensor 2)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int64>[2 3]
[[0 2  4]
 [6 8 10]]

```
:::


Combine two tensors element-wise:


::: {.sourceClojure}
```clojure
(dfn/+ small-tensor small-tensor)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[2 3]
[[0 2  4]
 [6 8 10]]

```
:::


**Reduction operations** (collapse dimensions):


::: {.sourceClojure}
```clojure
(dfn/mean small-tensor)
```
:::



::: {.printedClojure}
```clojure
2.5

```
:::



::: {.sourceClojure}
```clojure
(dfn/reduce-max small-tensor)
```
:::



::: {.printedClojure}
```clojure
5

```
:::



::: {.sourceClojure}
```clojure
(dfn/reduce-min small-tensor)
```
:::



::: {.printedClojure}
```clojure
0

```
:::



::: {.sourceClojure}
```clojure
(dfn/sum small-tensor)
```
:::



::: {.printedClojure}
```clojure
15.0

```
:::


**Why dfn instead of regular Clojure functions?**

- Work on entire tensors efficiently (no boxing)
- [Broadcast](https://en.wikipedia.org/wiki/Broadcasting_(parallel_pattern)) automatically
- Type-aware (preserve numeric precision)
- [SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)-optimized


## Type Handling: dtype/elemwise-cast

Convert between numeric types. Common pattern: upcast → compute → clamp → downcast.

Create uint8 tensor:


::: {.sourceClojure}
```clojure
(def tiny-uint8 (tensor/compute-tensor [2 2] (fn [_ _] 100) :uint8))
```
:::


Element type:


::: {.sourceClojure}
```clojure
(dtype/elemwise-datatype tiny-uint8)
```
:::



::: {.printedClojure}
```clojure
:uint8

```
:::


Multiply would overflow uint8 (max 255), so upcast first:


::: {.sourceClojure}
```clojure
(-> tiny-uint8
    (dtype/elemwise-cast :float32) ; upcast to float
    (dfn/* 2.5) ; compute
    (dfn/min 255) ; clamp to valid range
    (dfn/max 0)
    (dtype/elemwise-cast :uint8) ; downcast back
    )
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<uint8>[2 2]
[[250 250]
 [250 250]]

```
:::



## Shape Operations: dtype/shape and tensor/reshape

We've seen `dtype/shape` already. `tensor/reshape` reinterprets data
with a different shape (zero-copy):


::: {.sourceClojure}
```clojure
(def flat-tensor (tensor/compute-tensor [12] (fn [i] i) :int32))
```
:::



::: {.sourceClojure}
```clojure
flat-tensor
```
:::



::: {.printedClojure}
```clojure
[0 1 2 3 4 5 6 7 8 9 10 11]

```
:::


Reshape 1D → 2D:


::: {.sourceClojure}
```clojure
(tensor/reshape flat-tensor [3 4])
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[3 4]
[[0 1  2  3]
 [4 5  6  7]
 [8 9 10 11]]

```
:::


Reshape 2D → 1D:


::: {.sourceClojure}
```clojure
(tensor/reshape (tensor/reshape flat-tensor [3 4]) [12])
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<int32>[12]
[0 1 2 3 4 5 6 7 8 9 10 11]

```
:::


**Important**: Total elements must match (3×4 = 12).

---


# Image Statistics

Now that we understand tensor fundamentals, let's analyze image properties
using **reduction operations** and **channel slicing**.


## Extracting Color Channels

Use `tensor/slice-right` to extract all channels cleanly:


::: {.sourceClojure}
```clojure
(def channels
  (let [[blue green red] (tensor/slice-right original-tensor 1)]
    {:blue blue :green green :red red}))
```
:::


Each channel is now `[H W]` instead of `[H W C]`:


::: {.sourceClojure}
```clojure
(dtype/shape (:red channels))
```
:::



::: {.printedClojure}
```clojure
[960 1280]

```
:::


**Key insight**: These are **zero-copy views** into the original tensor—no data is copied.

**Alternative with tensor/select** (when you need one specific channel):


::: {.sourceClojure}
```clojure
(def blue-only (tensor/select original-tensor :all :all 0))
```
:::


Channel 0 = Blue


::: {.sourceClojure}
```clojure
(dtype/shape blue-only)
```
:::



::: {.printedClojure}
```clojure
[960 1280]

```
:::



## Statistical Operations


::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype.statistics :as stats])
```
:::


The [`tech.v3.datatype.statistics`](https://cnuernber.github.io/dtype-next/tech.v3.datatype.statistics.html)
namespace provides statistical functions optimized for typed arrays.

Key function:

- `stats/descriptive-statistics` — returns `:n-elems`, `:min`, `:max`, `:mean`, and `:standard-deviation` ([standard deviation](https://en.wikipedia.org/wiki/Standard_deviation))

This is more efficient than calling individual functions like `dfn/mean`, `dfn/standard-deviation`, etc.,
when you need multiple statistics, as it computes them in a single pass over the data.


## Channel Statistics


::: {.sourceClojure}
```clojure
(defn channel-stats
  "Compute statistics for a single channel tensor.
  Takes: [H W] tensor
  Returns: map with :mean, :standard-deviation, :min, :max, :n-elems"
  [channel]
  (stats/descriptive-statistics channel))
```
:::



::: {.sourceClojure}
```clojure
(defn channel-percentiles
  "Compute percentiles for a single channel tensor.
  Takes: [H W] tensor
  Returns: map with percentiles ([percentile](https://en.wikipedia.org/wiki/Percentile))"
  [channel]
  (zipmap [:q25 :median :q75]
          (dfn/percentiles channel [25 50 75])))
```
:::


Apply to our extracted channels:


::: {.sourceClojure}
```clojure
(-> (tc/dataset {:channel (keys channels)})
    (tc/add-columns (->> channels
                         vals
                         (map channel-stats)
                         tc/dataset))
    (tc/add-columns (->> channels
                         vals
                         (map channel-percentiles)
                         tc/dataset)))
```
:::


::: {.clay-dataset}
_unnamed [3 9]:

| :channel | :n-elems | :min |  :max |        :mean | :standard-deviation | :q25 | :median |  :q75 |
|----------|---------:|-----:|------:|-------------:|--------------------:|-----:|--------:|------:|
|    :blue |  1228800 |  0.0 | 255.0 | 100.43540609 |         71.37838404 | 39.0 |    89.0 | 160.0 |
|   :green |  1228800 |  0.0 | 255.0 | 112.81448568 |         72.58954056 | 50.0 |   106.0 | 177.0 |
|     :red |  1228800 |  0.0 | 255.0 | 126.11261475 |         73.81439317 | 60.0 |   128.0 | 193.0 |


:::



## Brightness Analysis

Convert to grayscale using perceptual luminance formula.

**Why these specific weights?** Human vision is most sensitive to green light,
moderately sensitive to red, and least sensitive to blue. The [coefficients](https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale)
(0.299, 0.587, 0.114) approximate the [relative luminance](https://en.wikipedia.org/wiki/Relative_luminance)
formula from the [ITU-R BT.601](https://en.wikipedia.org/wiki/Rec._601) standard,
ensuring grayscale images preserve perceived brightness rather than simple
equal weighting of color channels.


::: {.sourceClojure}
```clojure
(defn to-grayscale
  "Convert BGR [H W 3] to grayscale [H W].
  Standard formula: 0.299*R + 0.587*G + 0.114*B
  Takes BGR tensor, extracts channels correctly.
  Returns float64 tensor (dfn/* operates on floats for precision).
  Use dtype/elemwise-cast :uint8 when you need integer values for display."
  [img-tensor]
  (let [b (tensor/select img-tensor :all :all 0) ; Blue is channel 0
        g (tensor/select img-tensor :all :all 1) ; Green is channel 1
        r (tensor/select img-tensor :all :all 2)] ; Red is channel 2
    (dfn/+ (dfn/* r 0.299)
           (dfn/* g 0.587)
           (dfn/* b 0.114))))
```
:::



::: {.sourceClojure}
```clojure
(def grayscale (to-grayscale original-tensor))
```
:::


**Grayscale statistics**:


::: {.sourceClojure}
```clojure
(tc/dataset (channel-stats grayscale))
```
:::


::: {.clay-dataset}
_unnamed [1 5]:

| :n-elems | :min |  :max |       :mean | :standard-deviation |
|---------:|-----:|------:|------------:|--------------------:|
|  1228800 |  0.0 | 255.0 | 115.3794112 |         72.46778857 |


:::


Visualize grayscale:


::: {.sourceClojure}
```clojure
(bufimg/tensor->image grayscale)
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image2.png)
:::


**Note**: `bufimg/tensor->image` automatically handles float64→uint8 conversion
and interprets single-channel tensors as grayscale images.


## Histograms

A [histogram](https://en.wikipedia.org/wiki/Image_histogram) shows the distribution
of pixel values. It's essential for understanding image [brightness](https://en.wikipedia.org/wiki/Brightness), [contrast](https://en.wikipedia.org/wiki/Contrast_(vision)), and
[exposure](https://en.wikipedia.org/wiki/Exposure_(photography)). Peaks indicate common values; spread indicates [dynamic range](https://en.wikipedia.org/wiki/Dynamic_range).

**Approach 1**: Overlaid BGR channels using the reshape→dataset pattern we just learned:


::: {.sourceClojure}
```clojure
(-> original-tensor
    (tensor/reshape [(* height width) 3])
    tc/dataset
    (tc/rename-columns [:blue :green :red])
    (plotly/base {:=histogram-nbins 30
                  :=mark-opacity 0.5
                  :=width 800})
    (plotly/layer-histogram {:=x :red
                             :=mark-color "red"})
    (plotly/layer-histogram {:=x :blue
                             :=mark-color "blue"})
    (plotly/layer-histogram {:=x :green
                             :=mark-color "green"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[58327,47449,70084,52753,32898,22274,23200,20342,22212,21050,28608,33689,48533,59511,69485,49960,46791,36625,37070,32371,38287,37222,46899,46149,56878,54164,58532,39458,24847,13132],"r":null,"name":"","marker":{"color":"red"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"opacity":0.5,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null},{"y":[143015,74638,40856,28861,31125,28456,36273,38166,71004,82579,75563,51742,47276,34937,34635,27611,29236,24484,27084,24849,29678,27435,33755,35237,43711,38864,34402,19299,10705,3324],"r":null,"name":"","marker":{"color":"blue"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"opacity":0.5,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null},{"y":[74544,79217,72595,31651,28426,23196,27618,25730,34288,44325,70892,70318,62310,45525,45166,34363,33758,28502,32380,29283,33894,32652,38935,37457,45870,43115,46166,29581,17816,9227],"r":null,"name":"","marker":{"color":"green"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"opacity":0.5,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null}], {"width":800,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"green","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"count","showgrid":true},"title":null}, {});</script></div>
```


**Per-channel histograms** using `slice-right` for clean iteration:


::: {.sourceClojure}
```clojure
(kind/fragment
 (mapv (fn [color channel]
         (-> (tc/dataset {:x (dtype/as-reader channel)})
             (plotly/base {:=title color
                           :=height 200
                           :=width 800})
             (plotly/layer-histogram {:=histogram-nbins 30
                                      :=mark-color color})))
       ["blue" "green" "red"]
       (tensor/slice-right original-tensor 1)))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[143015,74638,40856,28861,31125,28456,36273,38166,71004,82579,75563,51742,47276,34937,34635,27611,29236,24484,27084,24849,29678,27435,33755,35237,43711,38864,34402,19299,10705,3324],"r":null,"name":"","marker":{"color":"blue"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null}], {"width":800,"height":200,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"count","showgrid":true},"title":"blue"}, {});</script></div>
```



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[74544,79217,72595,31651,28426,23196,27618,25730,34288,44325,70892,70318,62310,45525,45166,34363,33758,28502,32380,29283,33894,32652,38935,37457,45870,43115,46166,29581,17816,9227],"r":null,"name":"","marker":{"color":"green"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null}], {"width":800,"height":200,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"count","showgrid":true},"title":"green"}, {});</script></div>
```



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[58327,47449,70084,52753,32898,22274,23200,20342,22212,21050,28608,33689,48533,59511,69485,49960,46791,36625,37070,32371,38287,37222,46899,46149,56878,54164,58532,39458,24847,13132],"r":null,"name":"","marker":{"color":"red"},"fill":null,"mode":null,"width":[8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5,8.5],"type":"bar","theta":null,"z":null,"lon":null,"lat":null,"x":[4.25,12.75,21.25,29.75,38.25,46.75,55.25,63.75,72.25,80.75,89.25,97.75,106.25,114.75,123.25,131.75,140.25,148.75,157.25,165.75,174.25,182.75,191.25,199.75,208.25,216.75,225.25,233.75,242.25,250.75],"text":null}], {"width":800,"height":200,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"x","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"count","showgrid":true},"title":"red"}, {});</script></div>
```


This approach directly iterates over sliced channels without extracting them first,
combining channel names and data in a single pass.


# Spatial Analysis — Edges and Gradients

We've explored *global* properties like channel means and histograms. Now let's
analyze *local* spatial structure by comparing neighboring pixels.

We'll use [gradient](https://en.wikipedia.org/wiki/Image_gradient) operations
to measure how quickly values change across space. Gradients are fundamental to
[edge detection](https://en.wikipedia.org/wiki/Edge_detection), which identifies
boundaries between regions in an image.


## Computing Gradients

[Gradients](https://en.wikipedia.org/wiki/Image_gradient) measure how quickly pixel values change. We compute them by
comparing neighboring pixels using **slice offsets**.


::: {.sourceClojure}
```clojure
(defn gradient-x
  "Compute horizontal gradient (difference between adjacent columns).
  Takes: [H W] tensor
  Returns: [H W-1] tensor"
  [tensor-2d]
  (let [[_ w] (dtype/shape tensor-2d)]
    (dfn/- (tensor/select tensor-2d :all (range 1 w))
           (tensor/select tensor-2d :all (range 0 (dec w))))))
```
:::



::: {.sourceClojure}
```clojure
(defn gradient-y
  "Compute vertical gradient (difference between adjacent rows).
  Takes: [H W] tensor
  Returns: [H-1 W] tensor"
  [tensor-2d]
  (let [[h _] (dtype/shape tensor-2d)]
    (dfn/- (tensor/select tensor-2d (range 1 h) :all)
           (tensor/select tensor-2d (range 0 (dec h)) :all))))
```
:::



::: {.sourceClojure}
```clojure
(def gx (gradient-x grayscale))
```
:::



::: {.sourceClojure}
```clojure
(def gy (gradient-y grayscale))
```
:::



::: {.sourceClojure}
```clojure
gx
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<float64>[960 1279]
[[ 6.000  7.000  6.000 ... -9.000 -5.000 -2.000]
 [ 5.000  6.000  5.000 ...  0.000  0.000 -1.000]
 [ 3.000  4.000  3.000 ...  5.000 -1.000 -3.000]
 ...
 [-6.000 -6.000 -6.000 ...  0.000  0.000  0.000]
 [-5.000 -3.000 -3.000 ...  0.000  0.000  0.000]
 [-5.000 -2.000 -1.000 ...  0.000  0.000  0.000]]

```
:::



::: {.sourceClojure}
```clojure
gy
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<float64>[959 1280]
[[ 2.000  1.000  0.000 ...  1.000  6.000  7.000]
 [ 0.000 -2.000 -4.000 ... -5.000 -6.000 -8.000]
 [-4.000 -5.000 -7.000 ... -8.000 -12.00 -14.00]
 ...
 [ 0.000  0.000  4.000 ... -1.000 -1.000 -1.000]
 [ 4.000  5.000  8.000 ...  0.000  0.000  0.000]
 [ 6.000  6.000  7.000 ...  0.000  0.000  0.000]]

```
:::


Notice: `gx` is one column narrower, `gy` is one row shorter.

Combine gradients to get edge strength: `sqrt(gx² + gy²)`

**Why trim?** gradient-x produces [H W-1] and gradient-y produces [H-1 W].
To combine them element-wise, we need matching shapes, so we trim both to [H-1 W-1].


::: {.sourceClojure}
```clojure
(defn edge-magnitude
  "Compute gradient magnitude from gx and gy.
  Takes: gx [H W-1], gy [H-1 W]
  Returns: [H-1 W-1] (trimmed to common size)"
  [gx gy]
  (let [[_ w-gx] (dtype/shape gx)
        [h-gy _] (dtype/shape gy)
        ;; Trim to common dimensions: gx loses 1 row, gy loses 1 column
        gx-trimmed (tensor/select gx (range 0 h-gy) :all)
        gy-trimmed (tensor/select gy :all (range 0 w-gx))]
    (dfn/sqrt (dfn/+ (dfn/sq gx-trimmed)
                     (dfn/sq gy-trimmed)))))
```
:::



::: {.sourceClojure}
```clojure
(def edges (edge-magnitude gx gy))
```
:::



::: {.sourceClojure}
```clojure
edges
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor<float64>[959 1279]
[[6.325 7.071 6.000 ... 12.04 5.099 6.325]
 [5.000 6.325 6.403 ... 10.00 5.000 6.083]
 [5.000 6.403 7.616 ... 5.831 8.062 12.37]
 ...
 [6.000 10.00 11.70 ... 1.000 1.000 1.000]
 [7.211 7.810 10.00 ... 0.000 0.000 0.000]
 [7.810 6.708 7.616 ... 0.000 0.000 0.000]]

```
:::


Visualize edges (normalize to 0-255 range):


::: {.sourceClojure}
```clojure
(bufimg/tensor->image
 (-> edges
     (dfn/* (/ 255.0 (max 1.0 (dfn/reduce-max edges))))
     (dtype/elemwise-cast :uint8)))
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image3.png)
:::


**Note**: Grayscale (single-channel) tensors are rendered as grayscale images.


## Sharpness Metric

Measure image [sharpness](https://en.wikipedia.org/wiki/Acutance) by averaging edge magnitude—higher = sharper:


::: {.sourceClojure}
```clojure
(defn sharpness-score
  "Compute sharpness as mean edge magnitude.
  Takes: [H W 3] BGR or [H W] grayscale tensor
  Returns: scalar (higher = sharper)"
  [img-tensor]
  (let [gray (to-grayscale img-tensor)
        gx (gradient-x gray)
        gy (gradient-y gray)
        edges (edge-magnitude gx gy)]
    (dfn/mean edges)))
```
:::



::: {.sourceClojure}
```clojure
(sharpness-score original-tensor)
```
:::



::: {.printedClojure}
```clojure
10.654085750289296

```
:::


**Use case**: Compare sharpness before/after blur, or rank photos by clarity.

---


# Spatial Profiling — Row and Column Analysis

We've seen how to extract channels and compute global statistics. Now let's
explore **row-wise and column-wise analysis** using `tensor/slice`, `tensor/transpose`,
and `tensor/reduce-axis` for spatial profiling and region detection.


## Row Brightness Profile with tensor/slice

`tensor/slice` enables efficient iteration through rows. Let's compute mean
brightness per row to create a vertical brightness profile:


::: {.sourceClojure}
```clojure
(def img-rows (tensor/slice original-tensor 1))
```
:::


How many rows?


::: {.sourceClojure}
```clojure
(dtype/ecount img-rows)
```
:::



::: {.printedClojure}
```clojure
960

```
:::


Compute brightness for each row:


::: {.sourceClojure}
```clojure
(def row-brightness
  (mapv dfn/mean img-rows))
```
:::


First 10 row brightness values:


::: {.sourceClojure}
```clojure
(take 10 row-brightness)
```
:::



::: {.printedClojure}
```clojure
(104.93854166666667
 105.8078125
 106.55364583333333
 106.90026041666667
 107.18020833333334
 107.37135416666666
 107.35963541666666
 107.35494791666666
 107.80833333333334
 107.74296875)

```
:::


**Performance note**: Using `tensor/slice` is more efficient than manually selecting
each row with `(tensor/select img row-idx :all :all)` in a loop, as it creates the
reader once rather than performing individual selections.

Find brightest and darkest rows:


::: {.sourceClojure}
```clojure
(let [brightest-idx (apply max-key #(nth row-brightness %) (range (count row-brightness)))
      darkest-idx (apply min-key #(nth row-brightness %) (range (count row-brightness)))]
  (tc/dataset
   [{:type "Brightest"
     :row-index brightest-idx
     :brightness (nth row-brightness brightest-idx)}
    {:type "Darkest"
     :row-index darkest-idx
     :brightness (nth row-brightness darkest-idx)}]))
```
:::


::: {.clay-dataset}
_unnamed [2 3]:

|     :type | :row-index |  :brightness |
|-----------|-----------:|-------------:|
| Brightest |        577 | 142.36354167 |
|   Darkest |        956 |  69.03880208 |


:::


**Use case**: Identify horizon lines, sky regions, or exposure gradients.


## Column Operations with transpose

`tensor/slice` only works on leftmost dimensions. For columns, we use
`tensor/transpose` to swap dimensions:


::: {.sourceClojure}
```clojure
(def img-transposed (tensor/transpose original-tensor [1 0 2]))
```
:::


Shape changed from [H W C] to [W H C]:


::: {.sourceClojure}
```clojure
(dtype/shape img-transposed)
```
:::



::: {.printedClojure}
```clojure
[1280 960 3]

```
:::


Now we can slice columns:


::: {.sourceClojure}
```clojure
(def img-columns (tensor/slice img-transposed 1))
```
:::



::: {.sourceClojure}
```clojure
(dtype/ecount img-columns)
```
:::



::: {.printedClojure}
```clojure
1280

```
:::


Compute column brightness (horizontal profile):


::: {.sourceClojure}
```clojure
(def col-brightness
  (mapv dfn/mean (take 1280 img-columns)))
```
:::


Visualize row vs column brightness profiles:


::: {.sourceClojure}
```clojure
(-> (tc/dataset {:vertical-position (range (min 500 (count row-brightness)))
                 :row-brightness (take 500 row-brightness)})
    (plotly/base {:=title "Vertical Brightness Profile (Top 500 rows)"
                  :=x-title "Row Index"
                  :=y-title "Mean Brightness"
                  :=width 800})
    (plotly/layer-line {:=x :vertical-position
                        :=y :row-brightness
                        :=mark-color "steelblue"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[104.93854166666667,105.8078125,106.55364583333333,106.90026041666667,107.18020833333334,107.37135416666666,107.35963541666666,107.35494791666666,107.80833333333334,107.74296875,107.45651041666666,107.1875,106.9484375,106.82109375,106.78854166666666,106.62760416666667,106.36953125,106.33489583333333,105.83411458333333,105.13177083333333,104.4671875,103.77942708333333,103.76015625,103.44479166666666,103.18932291666667,102.10234375,100.25572916666667,98.91953125,98.91822916666666,98.54635416666666,97.07109375,96.20338541666666,95.96875,95.29244791666666,94.04609375,93.18125,92.40651041666666,91.46484375,91.06510416666667,90.97604166666666,90.80390625,91.02135416666667,91.22083333333333,91.57838541666666,91.42916666666666,91.334375,91.63489583333333,91.44348958333333,91.39895833333334,91.69765625,92.40703125,92.73177083333333,92.74505208333333,92.76171875,92.428125,91.8859375,91.75104166666667,91.87630208333333,91.42447916666667,91.02473958333333,91.03098958333334,91.0125,91.05182291666667,91.45651041666666,92.16354166666666,92.17734375,91.87682291666667,91.76848958333333,91.83203125,91.52213541666667,91.21953125,91.46302083333333,91.53854166666666,91.80520833333334,91.99088541666667,91.95520833333333,91.70130208333333,91.65442708333333,92.13020833333333,92.53619791666667,92.50963541666667,92.51328125,92.659375,92.43203125,92.18828125,92.28515625,92.19322916666667,91.90364583333333,91.73776041666666,91.36302083333334,91.52213541666667,91.85625,91.99973958333334,92.64947916666667,93.75416666666666,94.42708333333333,94.31432291666667,94.21145833333334,94.48880208333334,94.65494791666667,94.16744791666666,93.17734375,92.93645833333333,93.5640625,93.67630208333334,93.68255208333333,93.82161458333333,94.52708333333334,94.57057291666666,94.70598958333333,95.94166666666666,96.56744791666667,97.93385416666666,98.85130208333334,99.01744791666667,99.575,100.96041666666666,102.14166666666667,102.12864583333334,102.1015625,101.9484375,101.84947916666667,101.36744791666666,101.42447916666667,101.42838541666667,100.81979166666666,100.32916666666667,99.94661458333333,99.0578125,95.50807291666666,91.77369791666666,90.91484375,89.428125,85.45260416666666,80.53046875,78.65651041666666,78.3453125,78.3375,78.165625,77.9171875,77.17083333333333,76.60260416666667,77.29166666666667,78.1484375,79.32213541666667,81.02265625,82.74427083333333,84.61927083333333,87.359375,89.64322916666667,92.2953125,94.57421875,95.58177083333334,96.89036458333334,98.30390625,99.27109375,100.46692708333333,101.27708333333334,101.60963541666666,102.271875,102.91510416666667,103.34869791666667,104.24791666666667,105.17369791666667,105.9,106.68645833333333,107.45755208333334,107.86614583333333,107.86666666666666,108.23177083333333,108.859375,109.45807291666667,110.5359375,111.37552083333334,111.81354166666667,112.61796875,112.8390625,113.24192708333334,113.8046875,114.40885416666667,114.42838541666667,113.98177083333333,114.46614583333333,115.4796875,116.6828125,117.19166666666666,117.75625,118.15286458333334,117.97604166666666,118.77395833333334,119.7078125,120.334375,120.57890625,121.21354166666667,121.53385416666667,122.21927083333334,122.37291666666667,122.578125,123.39114583333334,123.94114583333334,123.25989583333333,123.41171875,123.56380208333333,123.6015625,123.22682291666666,122.63567708333333,122.3109375,122.0265625,122.22057291666667,122.5421875,122.17526041666666,122.22005208333333,121.690625,120.21171875,120.26901041666666,120.51927083333334,120.28125,120.34869791666667,120.18880208333333,120.44739583333333,120.30755208333333,119.37526041666666,118.98020833333334,118.43619791666667,117.49427083333333,117.75234375,118.29505208333333,118.31119791666667,117.17916666666666,116.39713541666667,116.24192708333334,115.44088541666666,114.16302083333333,113.81041666666667,112.84270833333333,111.78541666666666,110.75130208333333,110.62760416666667,111.10598958333334,110.59453125,110.33229166666666,110.2140625,110.06510416666667,111.0578125,111.00052083333334,110.0859375,110.32890625,110.16223958333333,110.06770833333333,109.92317708333333,109.08020833333333,110.103125,110.66666666666667,110.45364583333334,110.38619791666666,110.0640625,109.70520833333333,109.92578125,109.97421875,110.41067708333334,110.90052083333333,111.22682291666666,112.0375,113.09609375,113.03411458333333,112.94453125,113.08359375,114.2671875,114.66744791666666,114.83984375,115.30130208333334,115.47447916666667,115.71302083333333,115.8875,115.32291666666667,115.4703125,115.0890625,114.71822916666666,115.07708333333333,115.19973958333334,115.20260416666666,114.85494791666666,114.38020833333333,114.45234375,114.9859375,115.29401041666667,115.65078125,115.30260416666667,114.0453125,113.25494791666667,112.66770833333334,113.51536458333334,112.80442708333334,113.49114583333333,113.021875,112.53385416666667,112.36927083333333,111.50416666666666,111.50625,111.7234375,112.77057291666667,113.3609375,113.70078125,114.96666666666667,116.01067708333333,116.25520833333333,116.55286458333333,116.25286458333333,116.4609375,117.76979166666666,118.09661458333333,117.24947916666666,117.88307291666666,118.11640625,118.58463541666667,119.2453125,118.61276041666666,118.01901041666666,116.07239583333333,114.11875,113.75677083333333,115.32369791666666,115.69635416666667,115.57213541666667,117.57057291666666,116.76901041666666,116.56875,117.28880208333334,117.65807291666667,117.81796875,119.2578125,118.99166666666666,118.58072916666667,118.65052083333333,119.79817708333333,119.32916666666667,119.90807291666667,121.19401041666667,122.78541666666666,122.65729166666667,122.9765625,123.578125,124.1890625,123.99375,124.24244791666666,124.28177083333334,123.4234375,123.41822916666666,123.46276041666667,123.68385416666666,124.85182291666666,125.07057291666666,125.546875,127.29348958333334,127.72473958333333,128.4578125,129.60677083333334,130.6890625,132.19479166666667,133.44322916666667,133.83880208333332,136.0453125,135.88515625,135.53411458333332,136.775,136.94166666666666,137.45546875,137.88255208333334,137.203125,137.60052083333332,137.60052083333332,137.434375,137.7859375,138.20182291666666,138.64635416666667,138.51171875,138.2296875,138.24244791666666,138.15,138.06875,137.94322916666667,138.27135416666667,138.35078125,138.09322916666667,137.73932291666668,138.14791666666667,138.2546875,138.78125,139.71197916666668,139.88932291666666,139.06822916666667,137.85885416666667,137.63359375,137.62760416666666,137.1921875,136.42005208333333,136.05494791666666,135.49505208333332,135.30364583333332,136.40677083333333,137.23567708333334,136.31536458333332,135.24192708333334,134.621875,135.121875,135.15885416666666,134.55598958333334,134.2203125,134.98463541666666,135.14869791666666,135.27239583333332,135.22135416666666,134.79635416666667,134.20104166666667,134.91666666666666,136.14505208333333,137.58411458333333,139.21223958333334,139.92213541666666,139.209375,140.72526041666666,141.215625,140.6265625,140.1828125,139.45911458333333,139.10390625,139.27708333333334,139.4265625,138.82083333333333,138.98333333333332,138.55520833333333,138.08932291666667,137.2578125,136.09453125,135.56848958333333,134.11588541666666,133.61302083333334,133.82578125,132.99817708333333,131.32708333333332,130.50703125,130.40338541666668,129.48802083333334,128.43020833333333,127.92526041666666,128.00963541666667,127.41848958333334,126.27447916666667,125.58463541666667,125.04869791666667,124.35651041666667,123.35546875,123.67526041666666,123.3953125,121.453125,120.0640625,120.16276041666667,119.59505208333333,118.95286458333334,118.246875,118.11614583333333,118.42916666666666,117.01927083333334,117.05703125,115.66197916666667,114.79973958333333,113.93802083333334,112.70078125,111.38151041666667,110.284375,109.74270833333334,109.35494791666666,108.24791666666667,107.37395833333333,106.66640625,106.5953125,106.21484375,104.9046875,104.62239583333333,104.13411458333333,103.61015625,103.52578125,104.07916666666667,104.30703125,104.36458333333333,104.84739583333334,104.58203125,104.66614583333333,104.08255208333334,103.46484375,103.06302083333334,103.02864583333333,102.47473958333333,101.96640625,102.06119791666667,101.92109375,100.95234375,100.96666666666667,100.22890625,99.74791666666667],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"steelblue"},"lon":null,"lat":null,"x":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],"text":null}], {"width":800,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Row Index","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Mean Brightness","showgrid":true},"title":"Vertical Brightness Profile (Top 500 rows)"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(-> (tc/dataset {:horizontal-position (range (min 500 (count col-brightness)))
                 :col-brightness (take 500 col-brightness)})
    (plotly/base {:=title "Horizontal Brightness Profile (Left 500 columns)"
                  :=x-title "Column Index"
                  :=y-title "Mean Brightness"
                  :=width 800})
    (plotly/layer-line {:=x :horizontal-position
                        :=y :col-brightness
                        :=mark-color "coral"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[105.22222222222223,104.99583333333334,104.74652777777777,105.396875,107.23993055555556,107.66180555555556,107.76493055555555,108.26215277777777,108.59027777777777,108.51493055555555,108.12673611111111,107.6125,107.42847222222223,106.86041666666667,105.77048611111111,104.88229166666666,103.73645833333333,102.07743055555555,100.27291666666666,98.74375,97.3625,95.95868055555556,94.82847222222222,93.66979166666667,92.0201388888889,90.78090277777778,89.33645833333334,88.40104166666667,88.23923611111111,87.68263888888889,86.86006944444445,86.27986111111112,85.56770833333333,84.77569444444444,84.30069444444445,84.11180555555555,84.03298611111111,85.46840277777778,87.76597222222222,85.12465277777778,81.17256944444445,79.21215277777777,78.36111111111111,77.89131944444445,76.85208333333334,75.9642361111111,75.43472222222222,74.72534722222223,74.48506944444445,74.24965277777778,74.10555555555555,74.35208333333334,74.90763888888888,74.89166666666667,74.64131944444445,74.52395833333334,74.22743055555556,73.93090277777777,73.35208333333334,72.39479166666666,71.67291666666667,71.46770833333333,71.39583333333333,71.06319444444445,70.946875,71.05659722222222,71.3170138888889,71.28020833333333,71.35972222222222,71.21319444444444,70.72638888888889,70.40138888888889,70.25,69.59375,69.60520833333334,69.69236111111111,69.76701388888888,69.86805555555556,69.66875,69.19618055555556,69.66458333333334,69.61944444444444,69.68576388888889,69.7875,69.96875,69.325,68.45868055555556,68.33611111111111,68.440625,68.290625,68.18541666666667,67.48298611111112,66.75833333333334,66.20902777777778,65.35381944444444,64.49930555555555,64.0111111111111,63.27326388888889,61.66076388888889,60.21805555555556,59.547916666666666,58.76006944444445,57.713541666666664,56.930902777777774,56.665277777777774,56.10520833333333,55.296875,54.70625,54.6,54.22465277777778,53.459375,52.91736111111111,52.23645833333333,51.57048611111111,50.82395833333333,49.718402777777776,48.642361111111114,48.16319444444444,47.659375,46.72291666666667,45.343402777777776,44.77118055555555,43.98159722222222,43.203472222222224,42.72152777777778,42.32881944444444,41.89201388888889,41.513194444444444,41.305902777777774,41.26493055555556,41.22222222222222,41.2625,40.98576388888889,40.27534722222222,39.750347222222224,39.36493055555555,39.13298611111111,39.02534722222222,39.194097222222226,38.94236111111111,38.56875,38.12986111111111,37.544444444444444,37.25277777777778,37.075694444444444,37.031597222222224,36.043055555555554,34.731944444444444,34.48506944444444,34.37222222222222,34.015972222222224,33.776041666666664,34.01111111111111,34.74409722222222,34.580555555555556,33.41423611111111,32.77708333333333,32.248263888888886,32.089930555555554,31.800694444444446,32.265625,32.5625,33.278125,34.069097222222226,34.696527777777774,36.592708333333334,38.674305555555556,39.48715277777778,41.386805555555554,43.28819444444444,45.20520833333333,46.82465277777778,48.63368055555556,50.17395833333333,51.48020833333333,52.227777777777774,53.563541666666666,54.60486111111111,55.79826388888889,56.42604166666667,58.43472222222222,60.447916666666664,62.32222222222222,65.43159722222222,68.17361111111111,68.90034722222222,69.45486111111111,69.06006944444445,68.66631944444444,68.14270833333333,68.13298611111111,68.75625,69.98159722222222,71.57638888888889,73.1920138888889,74.6920138888889,75.49618055555555,75.25659722222223,75.04826388888888,75.65416666666667,76.9875,77.91944444444445,78.43611111111112,78.18506944444445,78.72361111111111,79.3079861111111,79.60243055555556,79.85694444444445,82.10555555555555,84.00416666666666,85.21006944444444,86.25347222222223,87.48194444444445,88.25173611111111,89.2388888888889,89.28993055555556,88.84444444444445,88.26284722222222,88.25208333333333,88.13888888888889,87.9329861111111,87.29131944444444,87.07534722222222,87.81041666666667,88.63958333333333,88.78055555555555,88.77465277777777,88.27777777777777,88.99930555555555,89.89930555555556,90.046875,90.29826388888888,89.38541666666667,87.48645833333333,86.1375,84.81006944444445,83.35902777777778,83.1625,83.31631944444445,83.41215277777778,82.87777777777778,81.46631944444445,79.61493055555556,78.48090277777777,78.5125,77.74791666666667,77.17604166666666,78.05729166666667,78.43923611111111,77.8236111111111,77.67291666666667,78.33715277777777,78.45208333333333,78.02326388888889,77.12465277777778,76.14201388888888,75.9017361111111,77.06944444444444,76.89236111111111,75.440625,74.32013888888889,73.66388888888889,73.63576388888889,73.82777777777778,74.54548611111112,74.83159722222223,75.17708333333333,73.90868055555555,72.36805555555556,72.43923611111111,73.31284722222222,73.55520833333334,75.16909722222222,77.24375,76.55034722222223,73.92604166666666,72.77083333333333,72.62916666666666,73.01979166666666,73.25763888888889,74.31597222222223,74.31527777777778,76.08020833333333,78.31111111111112,78.13125,76.2,75.60069444444444,76.00590277777778,76.115625,75.72777777777777,75.47465277777778,75.5357638888889,75.33194444444445,74.93159722222222,74.55104166666666,74.48923611111111,74.56770833333333,74.75763888888889,75.11944444444444,76.09375,77.47951388888889,77.71319444444444,77.628125,78.06770833333333,79.45416666666667,79.82604166666667,80.15243055555555,80.9,81.81736111111111,81.82986111111111,81.57604166666667,81.328125,81.66319444444444,80.90381944444445,81.22465277777778,82.15763888888888,82.51006944444444,81.73576388888888,81.38923611111112,82.00555555555556,82.16354166666666,82.59375,83.24131944444444,83.08090277777778,82.43784722222222,82.55694444444444,83.603125,82.24444444444444,79.55208333333333,79.97569444444444,80.68333333333334,81.66111111111111,82.18576388888889,82.15486111111112,82.04861111111111,81.35416666666667,82.07881944444445,81.41284722222223,79.96979166666667,78.41319444444444,77.41666666666667,78.35729166666667,80.24895833333333,82.225,83.4017361111111,81.45104166666667,80.33715277777777,80.01388888888889,80.20347222222222,80.15763888888888,79.57673611111112,79.40416666666667,79.63055555555556,81.24513888888889,83.32986111111111,84.57430555555555,85.55104166666666,86.98854166666666,87.4107638888889,86.96597222222222,86.70104166666667,86.27777777777777,85.52916666666667,86.13784722222222,87.19270833333333,87.76944444444445,88.23159722222222,87.70381944444445,88.25555555555556,89.72847222222222,89.51388888888889,89.36111111111111,91.03402777777778,91.79861111111111,90.66041666666666,90.29791666666667,90.37881944444445,90.63020833333333,90.26180555555555,90.22604166666666,89.23993055555556,88.91493055555556,89.04791666666667,89.46701388888889,91.17986111111111,93.47152777777778,93.89409722222223,92.90590277777778,92.52847222222222,92.01319444444445,91.29340277777777,90.60208333333334,90.61597222222223,91.48194444444445,91.3875,91.02847222222222,91.72916666666667,91.87291666666667,91.62118055555555,93.01944444444445,95.02777777777777,95.81215277777778,97.00625,97.68854166666667,97.20243055555555,96.63993055555555,96.66006944444445,96.16770833333334,95.76840277777778,96.77118055555556,97.64722222222223,97.69444444444444,97.90694444444445,97.82152777777777,97.41423611111111,97.17395833333333,97.84652777777778,97.38784722222222,98.86875,99.35416666666667,99.20694444444445,99.10694444444445,99.02083333333333,98.30069444444445,99.0357638888889,100.215625,101.24027777777778,101.81423611111111,102.14930555555556,101.8625,102.01770833333333,102.8548611111111,103.67743055555556,105.45868055555556,106.52777777777777,106.17916666666666,105.73263888888889,106.41805555555555,107.88645833333334,108.40381944444445,109.33993055555555,110.38368055555556,111.82604166666667,111.48472222222222,111.04270833333334,111.49479166666667,112.04444444444445,112.84270833333333,113.79861111111111,113.29131944444444,113.18194444444444,113.896875,114.96111111111111,116.2611111111111,118.19791666666667,120.44375,121.42569444444445,121.62708333333333,123.15972222222223,124.64444444444445,126.29305555555555,127.07534722222222,127.36597222222223,127.89027777777778,127.98055555555555,128.0559027777778,128.21145833333333,129.51770833333333,130.83923611111112,131.51388888888889,132.03194444444443,132.45069444444445,132.4625,132.38958333333332,133.30833333333334,133.94131944444445,134.1611111111111,135.21041666666667,136.93402777777777,138.03194444444443,138.26979166666666,138.05833333333334,137.4423611111111,138.08402777777778,138.83645833333333,139.27916666666667,139.66076388888888,140.27777777777777,140.92638888888888,141.34097222222223,142.678125,142.68680555555557,142.86944444444444,143.77708333333334,144.65902777777777,145.2607638888889,145.67013888888889,146.6201388888889,148.06631944444445,147.87743055555555],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"coral"},"lon":null,"lat":null,"x":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],"text":null}], {"width":800,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Column Index","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Mean Brightness","showgrid":true},"title":"Horizontal Brightness Profile (Left 500 columns)"}, {});</script></div>
```


**Use case**: Detect [vignetting](https://en.wikipedia.org/wiki/Vignetting), find composition center, identify vertical features.


## Efficient Aggregation with reduce-axis

For statistics without explicit iteration, use `tensor/reduce-axis`.

Compute row brightness using reduce-axis:


::: {.sourceClojure}
```clojure
(def row-means-fast
  (-> original-tensor
      (tensor/reduce-axis dfn/mean 1 :float64) ; [H W C] → [H C]
      (tensor/reduce-axis dfn/mean 1 :float64)) ; [H C] → [H]
  )
```
:::


First 10 values (compare with earlier slice-based approach):


::: {.sourceClojure}
```clojure
(take 10 (dtype/as-reader row-means-fast))
```
:::



::: {.printedClojure}
```clojure
(104.93854166666667
 105.8078125
 106.55364583333333
 106.90026041666665
 107.18020833333333
 107.37135416666666
 107.35963541666666
 107.35494791666667
 107.80833333333334
 107.74296875)

```
:::


**Why specify `:float64`?** Without it, dtype-next might infer the output type from
the input (`:uint8`), which would truncate decimal values from the mean operation.
For example, a mean of 127.8 would become 127. Always specify the output datatype
when reducing to ensure you get the precision you need.


## Block-Based Region Analysis

For coarse spatial analysis, downsample into blocks and find regions of interest:


::: {.sourceClojure}
```clojure
(defn downsample-blocks
  "Downsample image by averaging NxN blocks.
  Returns: [H/N W/N] tensor of block mean brightness"
  [img-tensor block-size]
  (let [[h w _] (dtype/shape img-tensor)
        new-h (quot h block-size)
        new-w (quot w block-size)]
    (tensor/compute-tensor
     [new-h new-w]
     (fn [by bx]
       (let [block (tensor/select img-tensor
                                  (range (* by block-size) (min h (* (inc by) block-size)))
                                  (range (* bx block-size) (min w (* (inc bx) block-size)))
                                  :all)]
         (dfn/mean block)))
     :float32)))
```
:::



::: {.sourceClojure}
```clojure
(def brightness-map (downsample-blocks original-tensor 20))
```
:::


Brightness map shape:


::: {.sourceClojure}
```clojure
(dtype/shape brightness-map)
```
:::



::: {.printedClojure}
```clojure
[48 64]

```
:::


[48 64] for 960/20 × 1280/20

Find brightest and darkest blocks:


::: {.sourceClojure}
```clojure
(defn find-block-extremes
  "Find coordinates of brightest and darkest blocks in a 2D tensor."
  [tensor-2d]
  (let [flat (dtype/as-reader (tensor/reshape tensor-2d [(dtype/ecount tensor-2d)]))
        [h w] (dtype/shape tensor-2d)
        max-idx (apply max-key #(flat %) (range (dtype/ecount flat)))
        min-idx (apply min-key #(flat %) (range (dtype/ecount flat)))]
    {:brightest {:block-y (quot max-idx w)
                 :block-x (rem max-idx w)
                 :value (flat max-idx)}
     :darkest {:block-y (quot min-idx w)
               :block-x (rem min-idx w)
               :value (flat min-idx)}}))
```
:::



::: {.sourceClojure}
```clojure
(find-block-extremes brightness-map)
```
:::



::: {.printedClojure}
```clojure
{:brightest {:block-y 20, :block-x 63, :value 247.27},
 :darkest {:block-y 12, :block-x 13, :value 2.08}}

```
:::


**Use case**: Quick region-of-interest detection, composition analysis, exposure mapping.

---


# Enhancement Pipeline

We've explored analyzing image properties—now let's actively *transform* them.
With analysis tools in place, we'll build functions that improve images through
white balance and contrast adjustment. Each transformation is composable and
verifiable through numeric properties we can check in the REPL.


## Auto White Balance

[White balance](https://en.wikipedia.org/wiki/Color_balance) adjusts colors to
appear neutral under different lighting conditions. We scale BGR channels to have
equal means, removing color casts.


::: {.sourceClojure}
```clojure
(defn auto-white-balance
  "Scale BGR channels to have equal means.
  Takes: [H W 3] uint8 BGR tensor
  Returns: [H W 3] uint8 BGR tensor"
  [img-tensor]
  (let [;; Compute channel means using reduce-axis
        ;; First reduce: [H W 3] → [W 3] (collapse height, axis 0)
        ;; Second reduce: [W 3] → [3] (collapse width, now axis 0 after shape change)
        channel-means (-> img-tensor
                          (tensor/reduce-axis dfn/mean 0) ; [H W 3] → [W 3]
                          (tensor/reduce-axis dfn/mean 0)) ; [W 3] → [3]

        ;; Target: maximum of the three means
        target-mean (dfn/reduce-max channel-means)

        ;; Compute scale factors for each channel [3]
        scale-factors (dfn// target-mean (dfn/max 1.0 channel-means))

        [h w c] (dtype/shape img-tensor)

        ;; Scale each channel (vectorized operations per channel)
        scaled-channels (mapv (fn [ch]
                                (let [channel (tensor/select img-tensor :all :all ch)
                                      scale (scale-factors ch)]
                                  (dtype/elemwise-cast
                                   (dfn/min 255 (dfn/* channel scale))
                                   :uint8)))
                              (range c))]

    ;; Reassemble channels
    (tensor/compute-tensor
     [h w c]
     (fn [y x ch]
       ((nth scaled-channels ch) y x))
     :uint8)))
```
:::



::: {.sourceClojure}
```clojure
(kind/table
 [[:original
   :white-balanced]
  [original-img
   (-> original-tensor
       auto-white-balance
       bufimg/tensor->image)]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>white-balanced</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image0.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image4.png" /></p></div></td></tr></tbody></table>
```

:::


BGR tensor → BGR image

**Note**: Our BGR tensor flows seamlessly to BGR BufferedImage.


## Contrast Enhancement

[Contrast](https://en.wikipedia.org/wiki/Contrast_(vision)) enhancement amplifies
the difference between light and dark regions. We amplify each pixel's deviation
from the mean, making bright pixels brighter and dark pixels darker.


::: {.sourceClojure}
```clojure
(defn enhance-contrast
  "Increase image contrast by amplifying deviation from mean.
  Takes: [H W 3] uint8 BGR tensor, factor (> 1 increases, < 1 decreases)
  Returns: [H W 3] uint8 BGR tensor"
  [img-tensor factor]
  (let [[h w c] (dtype/shape img-tensor)

        ;; Process each channel independently
        enhanced-channels (mapv (fn [ch]
                                  (let [channel (tensor/select img-tensor :all :all ch)
                                        ch-mean (dfn/mean channel)]
                                    ;; Apply contrast: mean + factor * (value - mean)
                                    (dtype/elemwise-cast
                                     (dfn/min 255
                                              (dfn/max 0
                                                       (dfn/+ ch-mean
                                                              (dfn/* (dfn/- channel ch-mean) factor))))
                                     :uint8)))
                                (range c))]

    ;; Reassemble channels
    (tensor/compute-tensor
     [h w c]
     (fn [y x ch]
       ((nth enhanced-channels ch) y x))
     :uint8)))
```
:::



::: {.sourceClojure}
```clojure
(def contrasted (enhance-contrast original-tensor 1.5))
```
:::



::: {.sourceClojure}
```clojure
(kind/table
 [[:original
   :contrast-1.5
   :contrast-3]
  [original-img
   (-> original-tensor
       (enhance-contrast 1.5)
       bufimg/tensor->image) ; BGR → BGR
   (-> original-tensor
       (enhance-contrast 3)
       bufimg/tensor->image)]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>contrast-1.5</td><td>contrast-3</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image0.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image5.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image6.png" /></p></div></td></tr></tbody></table>
```

:::


---


# Accessibility — Color Blindness Simulation

Beyond enhancement, images need to be *accessible*. Let's simulate how images
appear to people with different types of color vision deficiency.

This demonstrates dtype-next's [linear algebra](https://en.wikipedia.org/wiki/Linear_algebra) capabilities (applying 3×3 matrices
to BGR channels) with practical real-world applications.

Apply 3×3 transformation matrices to simulate different types of color vision deficiency.


## Color Blindness Matrices

These matrices simulate [color blindness](https://en.wikipedia.org/wiki/Color_blindness)
(color vision deficiency). Different types affect perception of red, green, or blue:


::: {.sourceClojure}
```clojure
(def color-blindness-matrices
  "Color blindness simulation matrices.
  Each matrix is 3×3 with columns in BGR order: [B G R]
  Matrices adapted from standard RGB formulas, reordered for BGR."
  {:protanopia [[0.000 0.433 0.567] ; Red-blind (BGR columns)
                [0.000 0.442 0.558]
                [0.758 0.242 0.000]]

   :deuteranopia [[0.000 0.375 0.625] ; Green-blind (BGR columns)
                  [0.000 0.300 0.700]
                  [0.700 0.300 0.000]]

   :tritanopia [[0.000 0.050 0.950] ; Blue-blind (BGR columns)
                [0.567 0.433 0.000]
                [0.525 0.475 0.000]]})
```
:::



## Applying Matrix Transformations

Extract BGR channels, apply linear combinations, reassemble:


::: {.sourceClojure}
```clojure
(defn apply-color-matrix
  "Apply 3×3 transformation matrix to BGR channels.
  Takes: [H W 3] BGR tensor, 3×3 matrix [[b0 g0 r0] [b1 g1 r1] [b2 g2 r2]]
  Returns: [H W 3] uint8 BGR tensor
  Formula: new_b = b0*B + g0*G + r0*R, etc.
  
  Note: Matrix coefficients correspond to BGR order (channel 0=B, 1=G, 2=R)"
  [img-tensor matrix]
  (let [b (tensor/select img-tensor :all :all 0) ; Blue channel
        g (tensor/select img-tensor :all :all 1) ; Green channel
        r (tensor/select img-tensor :all :all 2) ; Red channel

        [[b0 g0 r0]
         [b1 g1 r1]
         [b2 g2 r2]] matrix

        ;; Apply transformation (BGR order)
        new-b (dfn/+ (dfn/+ (dfn/* b b0) (dfn/* g g0)) (dfn/* r r0))
        new-g (dfn/+ (dfn/+ (dfn/* b b1) (dfn/* g g1)) (dfn/* r r1))
        new-r (dfn/+ (dfn/+ (dfn/* b b2) (dfn/* g g2)) (dfn/* r r2))

        ;; Clamp and cast
        clamp-cast (fn [ch]
                     (dtype/elemwise-cast
                      (dfn/min 255 (dfn/max 0 ch))
                      :uint8))

        new-b-clamped (clamp-cast new-b)
        new-g-clamped (clamp-cast new-g)
        new-r-clamped (clamp-cast new-r)

        [h w _] (dtype/shape img-tensor)]
    (tensor/compute-tensor
     [h w 3]
     (fn [y x c]
       (case c
         0 (new-b-clamped y x) ; Blue channel 0
         1 (new-g-clamped y x) ; Green channel 1
         2 (new-r-clamped y x))) ; Red channel 2
     :uint8)))
```
:::



::: {.sourceClojure}
```clojure
(defn simulate-color-blindness
  "Simulate color vision deficiency.
  Takes: [H W 3] tensor, blindness-type (:protanopia | :deuteranopia | :tritanopia)
  Returns: [H W 3] uint8 tensor"
  [img-tensor blindness-type]
  (apply-color-matrix img-tensor
                      (get color-blindness-matrices blindness-type)))
```
:::



## Simulations


::: {.sourceClojure}
```clojure
(kind/table
 [[:normal :protanopia :deuteranopia :tritanopia]
  [(bufimg/tensor->image original-tensor)
   (bufimg/tensor->image (simulate-color-blindness original-tensor :protanopia))
   (bufimg/tensor->image (simulate-color-blindness original-tensor :deuteranopia))
   (bufimg/tensor->image (simulate-color-blindness original-tensor :tritanopia))]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>normal</td><td>protanopia</td><td>deuteranopia</td><td>tritanopia</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image7.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image8.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image9.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image10.png" /></p></div></td></tr></tbody></table>
```

:::


All color blindness transformations maintain BGR order throughout.

---


# Convolution & Filtering

So far we've used simple element-wise operations and direct pixel comparisons.
Now let's explore **convolution**, the fundamental operation behind blur, sharpen,
and edge detection.

**What we'll learn:**

- How convolution works (sliding kernels over images)
- Building a 2D convolution function for learning and non-separable filters
- Separable filters—the standard approach for Gaussian blur
- Practical applications: box blur, Gaussian blur, sharpening, edge detection


## Understanding Convolution

[Convolution](https://en.wikipedia.org/wiki/Kernel_(image_processing)) is a
fundamental operation in image processing. A **kernel** (or filter) is a small
matrix that slides over the image. At each position, we multiply kernel values
by corresponding pixel values and sum the result.

Let's see this with a simple example: box blur.


### Box Blur Example

[Box blur](https://en.wikipedia.org/wiki/Box_blur) averages all pixels in a neighborhood. A 3×3 box blur kernel weights
all 9 pixels equally:


::: {.sourceClojure}
```clojure
(defn box-blur-kernel
  "Create NxN box blur kernel (uniform averaging).
  Takes: n (kernel size)
  Returns: [n n] float32 tensor"
  [n]
  (let [weight (/ 1.0 (* n n))]
    (tensor/compute-tensor
     [n n]
     (fn [_ _] weight)
     :float32)))
```
:::



::: {.sourceClojure}
```clojure
(def kernel-3x3 (box-blur-kernel 3))
```
:::



::: {.sourceClojure}
```clojure
kernel-3x3
```
:::



::: {.printedClojure}
```clojure
[#tech.v3.tensor<float32>[3]
[0.1111 0.1111 0.1111] #tech.v3.tensor<float32>[3]
[0.1111 0.1111 0.1111] #tech.v3.tensor<float32>[3]
[0.1111 0.1111 0.1111]]

```
:::


This kernel says: "Replace each pixel with the average of itself and its 8 neighbors."
To apply this kernel across the entire image, we need a convolution function.


## Building a 2D Convolution Function

We'll implement `convolve-2d` to understand the mechanics. This function is useful for:

- **Learning**: See exactly how convolution works
- **Non-separable filters**: Some kernels (like Sobel) can't be separated into 1D operations

For separable filters like Gaussian blur, we'll use a more efficient approach (shown next).


::: {.sourceClojure}
```clojure
(defn convolve-2d
  "Apply 2D convolution to grayscale image [H W].
  kernel: [kh kw] float tensor
  edge-mode: :zero (default) or :reflect
  Returns [H W] float32 tensor.
  
  This implementation prioritizes clarity over performance to demonstrate
  tensor operations and convolution mechanics. It explicitly shows:

  - Sliding window iteration with loop/recur
  - Bounds checking and edge handling
  - Element-wise kernel multiplication
  
  This function is useful for learning and for non-separable kernels.
  For separable filters like Gaussian blur, see gaussian-blur-separable below."
  ([img-2d kernel] (convolve-2d img-2d kernel :zero))
  ([img-2d kernel edge-mode]
   (let [[h w] (dtype/shape img-2d)
         [kh kw] (dtype/shape kernel)
         pad-h (quot kh 2)
         pad-w (quot kw 2)

         ;; Helper to get pixel value with edge handling
         get-pixel (case edge-mode
                     :zero (fn [y x]
                             (if (and (>= y 0) (< y h)
                                      (>= x 0) (< x w))
                               (img-2d y x)
                               0.0))
                     :reflect (fn [y x]
                                (let [ry (cond
                                           (< y 0) (- y)
                                           (>= y h) (- h (- y h) 2)
                                           :else y)
                                      rx (cond
                                           (< x 0) (- x)
                                           (>= x w) (- w (- x w) 2)
                                           :else x)]
                                  (img-2d (max 0 (min (dec h) ry))
                                          (max 0 (min (dec w) rx))))))]
     (tensor/compute-tensor
      [h w]
      (fn [y x]
        ;; Sum weighted pixel values in kernel neighborhood
        (loop [ky 0
               kx 0
               sum 0.0]
          (if (>= ky kh)
            sum
            (let [img-y (+ y ky (- pad-h))
                  img-x (+ x kx (- pad-w))
                  pixel-val (get-pixel img-y img-x)
                  new-sum (+ sum (* (kernel ky kx) pixel-val))
                  [next-ky next-kx] (if (>= (inc kx) kw)
                                      [(inc ky) 0]
                                      [ky (inc kx)])]
              (recur next-ky next-kx new-sum)))))
      :float32))))
```
:::



## Separable Filters: The Recommended Approach

Many important filters are [separable](https://en.wikipedia.org/wiki/Separable_filter)—they
can be decomposed into two 1D operations instead of one 2D operation. This is the
**standard approach** for filters like Gaussian blur, not an optimization.

**How it works**: Instead of applying a k×k kernel to each pixel, we:
1. Apply a 1D kernel horizontally (blur each row)
2. Apply a 1D kernel vertically (blur each column)

**Computational advantage**:

- 2D convolution with k×k kernel: O(k²) operations per pixel
- Separable approach: O(k) operations per pixel (k/2 horizontal + k/2 vertical)
- For a 7×7 kernel: 49 vs 7 operations per pixel (~7× reduction)

Where:

- k = kernel size (e.g., 7 for a 7×7 kernel)
- N×M = image dimensions (height × width)
- Total work for image: O(N×M×k²) vs O(N×M×k)

**Additional optimizations**: Library functions like `convolve/gaussian1d` may use [FFT](https://en.wikipedia.org/wiki/Fast_Fourier_transform)
(Fast Fourier Transform) for very large kernels or data, which can be even faster:
O(N×M×log(N×M)) regardless of kernel size. This happens automatically based on data size.


### The convolve Namespace


::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype.convolve :as convolve])
```
:::


The [`tech.v3.datatype.convolve`](https://cnuernber.github.io/dtype-next/tech.v3.datatype.convolve.html)
namespace provides optimized 1D convolution operations:


- `convolve/gaussian1d` — 1D Gaussian filter with automatic kernel generation
- `convolve/convolve1d` — General 1D convolution
- `convolve/gauss-kernel-1d` — Create 1D Gaussian kernels

These functions support edge-handling strategies (`:zero`, `:clamp`, `:reflect`, `:wrap`)
and may use FFT optimization automatically for large data.


::: {.sourceClojure}
```clojure
(defn gaussian-blur-separable
  "Apply Gaussian blur using separable 1D convolutions.
  Takes: [H W] grayscale tensor, sigma (standard deviation)
  Returns: [H W] float64 tensor
  
  This is the recommended approach for Gaussian blur.
  Applies horizontal blur to each row, then vertical blur to each column."
  [img-2d sigma]
  (let [[h w] (dtype/shape img-2d)

        ;; Step 1: Blur each row horizontally
        ;; tensor/slice gives us a reader of rows (zero-copy)
        rows (tensor/slice img-2d 1)

        ;; dtype/emap applies gaussian1d to each row (lazy)
        rows-blurred (dtype/emap
                      (fn [row]
                        (convolve/gaussian1d row sigma {:mode :same :edge-mode :reflect}))
                      :object
                      rows)

        ;; Concatenate blurred rows into single buffer, then reshape to [h w]
        horizontal-blurred (tensor/reshape
                            (dtype/concat-buffers :float64 rows-blurred)
                            [h w])

        ;; Step 2: Blur each column vertically
        ;; tensor/slice-right gives us a reader of columns (zero-copy)
        cols (tensor/slice-right horizontal-blurred 1)

        cols-blurred (dtype/emap
                      (fn [col]
                        (convolve/gaussian1d col sigma {:mode :same :edge-mode :reflect}))
                      :object
                      cols)]

    ;; Reassemble columns (requires transposition, so use compute-tensor)
    (tensor/compute-tensor
     [h w]
     (fn [y x]
       ((nth cols-blurred x) y))
     :float64)))
```
:::


**Key dtype-next patterns in this implementation:**


- `tensor/slice` and `tensor/slice-right` — Zero-copy readers of rows/columns
- `dtype/emap` — Lazy transformation over readers (more efficient than `mapv`)
- `dtype/concat-buffers` — Efficiently concatenate buffers for reassembly
- `tensor/reshape` — Zero-copy view with different shape
- `tensor/compute-tensor` — Used when data needs reordering (columns → rows)

The horizontal pass uses `concat-buffers` + `reshape` (fast, sequential data).
The vertical pass uses `compute-tensor` (necessary for transposition).

The `convolve/gaussian1d` function handles kernel generation, edge modes (`:reflect`,
`:wrap`, `:zero`), and may use FFT optimization automatically for large data.

---

With separable filters understood, let's apply convolution to practical filtering tasks.


## Applying Box Blur

Now we can apply our 3×3 box blur kernel using `convolve-2d`:


::: {.sourceClojure}
```clojure
(def blurred-gray (convolve-2d grayscale kernel-3x3))
```
:::


Compare original vs blurred:


::: {.sourceClojure}
```clojure
(kind/table
 [[:original :box-blur-3x3]
  [(bufimg/tensor->image grayscale)
   (bufimg/tensor->image (dtype/elemwise-cast blurred-gray :uint8))]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>box-blur-3x3</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image11.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image12.png" /></p></div></td></tr></tbody></table>
```

:::


Box blur creates a simple averaging effect. Grayscale tensors (2D) are automatically
rendered as grayscale images.


## Gaussian Blur (Separable)

[Gaussian blur](https://en.wikipedia.org/wiki/Gaussian_blur) weights center pixels
more heavily than edge pixels based on the Gaussian (normal) distribution, producing
smooth, natural-looking blur without artifacts.

We use `gaussian-blur-separable` (the recommended approach):


::: {.sourceClojure}
```clojure
(def gaussian-blurred-1 (gaussian-blur-separable grayscale 1.0))
```
:::



::: {.sourceClojure}
```clojure
(def gaussian-blurred-1-5 (gaussian-blur-separable grayscale 1.5))
```
:::


Compare blur strengths—notice how Gaussian blur is smoother than box blur:


::: {.sourceClojure}
```clojure
(kind/table
 [[:original :box-blur-3x3 :gaussian-sigma-1.0 :gaussian-sigma-1.5]
  [(bufimg/tensor->image grayscale)
   (bufimg/tensor->image (dtype/elemwise-cast blurred-gray :uint8))
   (bufimg/tensor->image gaussian-blurred-1)
   (bufimg/tensor->image gaussian-blurred-1-5)]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>box-blur-3x3</td><td>gaussian-sigma-1.0</td><td>gaussian-sigma-1.5</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image13.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image14.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image15.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image16.png" /></p></div></td></tr></tbody></table>
```

:::



## Sharpening (Unsharp Masking)

[Unsharp masking](https://en.wikipedia.org/wiki/Unsharp_masking) sharpens images
by enhancing edges. We subtract a blurred version from the original to extract
high-frequency details, then add them back amplified:

**Formula**: `sharpened = original + strength × (original - blur)`


::: {.sourceClojure}
```clojure
(defn sharpen
  "Sharpen image using unsharp mask.
  Takes: [H W] grayscale tensor, strength (0.5-2.0 typical)
  Returns: [H W] float32 tensor"
  [img-2d strength]
  (let [blurred (convolve-2d img-2d (box-blur-kernel 3))
        detail (dfn/- img-2d blurred)]
    (-> (dfn/+ img-2d (dfn/* detail strength))
        (dfn/max 0)
        (dfn/min 255))))
```
:::



::: {.sourceClojure}
```clojure
(def sharpened-gray (sharpen grayscale 1.5))
```
:::


Compare original vs sharpened:


::: {.sourceClojure}
```clojure
(kind/table
 [[:original :sharpened]
  [(bufimg/tensor->image grayscale)
   (bufimg/tensor->image (dtype/elemwise-cast sharpened-gray :uint8))]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>sharpened</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image17.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image18.png" /></p></div></td></tr></tbody></table>
```

:::



### Quantifying Sharpness

We can measure the effect of each filter by computing mean edge magnitude.
Higher values = sharper images, lower values = blurrier:


::: {.sourceClojure}
```clojure
(-> {:original grayscale
     :box-blur-3x3 blurred-gray
     :gaussian-sigma-1.0 gaussian-blurred-1
     :gaussian-sigma-1.5 gaussian-blurred-1-5
     :sharpened sharpened-gray}
    (update-vals
     (fn [t]
       (dfn/mean (edge-magnitude
                  (gradient-x t)
                  (gradient-y t)))))
    tc/dataset)
```
:::


::: {.clay-dataset}
_unnamed [1 5]:

|   :original | :box-blur-3x3 | :gaussian-sigma-1.0 | :gaussian-sigma-1.5 |  :sharpened |
|------------:|--------------:|--------------------:|--------------------:|------------:|
| 10.65408575 |    5.89871815 |          5.25806474 |          3.95598023 | 20.40900352 |


:::


As expected: sharpening increases edge magnitude, blurring decreases it.


## Sobel Edge Detection

The [Sobel operator](https://en.wikipedia.org/wiki/Sobel_operator) is a classic
edge detection method that uses specialized kernels to compute gradients in X and Y
directions. It's more robust to noise than simple [finite differences](https://en.wikipedia.org/wiki/Finite_difference).

Sobel kernels detect edges in X and Y directions:


::: {.sourceClojure}
```clojure
(def sobel-x-kernel
  (tensor/compute-tensor
   [3 3]
   (fn [y x]
     (case [y x]
       [0 0] -1.0, [0 1] 0.0, [0 2] 1.0
       [1 0] -2.0, [1 1] 0.0, [1 2] 2.0
       [2 0] -1.0, [2 1] 0.0, [2 2] 1.0))
   :float32))
```
:::



::: {.sourceClojure}
```clojure
(def sobel-y-kernel
  (tensor/compute-tensor
   [3 3]
   (fn [y x]
     (case [y x]
       [0 0] -1.0, [0 1] -2.0, [0 2] -1.0
       [1 0] 0.0, [1 1] 0.0, [1 2] 0.0
       [2 0] 1.0, [2 1] 2.0, [2 2] 1.0))
   :float32))
```
:::


Apply Sobel filters:


::: {.sourceClojure}
```clojure
(def sobel-x (convolve-2d grayscale sobel-x-kernel))
```
:::



::: {.sourceClojure}
```clojure
(def sobel-y (convolve-2d grayscale sobel-y-kernel))
```
:::


Compute edge magnitude:


::: {.sourceClojure}
```clojure
(def sobel-edges (dfn/sqrt (dfn/+ (dfn/sq sobel-x) (dfn/sq sobel-y))))
```
:::


Visualize Sobel edges:


::: {.sourceClojure}
```clojure
(bufimg/tensor->image
 (-> sobel-edges
     (dfn/* (/ 255.0 (max 1.0 (dfn/reduce-max sobel-edges))))
     (dtype/elemwise-cast :uint8)))
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image19.png)
:::


Single-channel tensors display as grayscale images.

**Comparison**: Simple gradient (from Spatial Analysis section) vs Sobel


::: {.sourceClojure}
```clojure
{:simple-mean (dfn/mean edges) ; reuse edges computed earlier
 :sobel-mean (dfn/mean sobel-edges)
 :sobel-smoother? true}
```
:::



::: {.printedClojure}
```clojure
{:simple-mean 10.654085750289296,
 :sobel-mean 59.98076450272415,
 :sobel-smoother? true}

```
:::


Sobel produces smoother, more robust edge detection.

---


# Downsampling & Multi-Scale Processing

Finally, let's explore working with images at multiple scales. [Downsampling](https://en.wikipedia.org/wiki/Downsampling_(signal_processing))
reduces resolution for faster processing or multi-scale analysis (like detecting
features at different sizes).

We'll compare downsampling strategies and build image pyramids, demonstrating
`tensor/select` with stride patterns and aggregation techniques.


## Downsampling by 2×

[Downsampling](https://en.wikipedia.org/wiki/Downsampling_(signal_processing))
([decimation](https://en.wikipedia.org/wiki/Decimation_(signal_processing))) reduces image resolution by discarding pixels. We select every other
pixel in each dimension, creating a half-size image.


::: {.sourceClojure}
```clojure
(defn downsample-2x
  "Downsample by selecting every other pixel.
  Takes: [H W] tensor
  Returns: [H/2 W/2] tensor"
  [img-2d]
  (let [[h w] (dtype/shape img-2d)]
    (tensor/select img-2d (range 0 h 2) (range 0 w 2))))
```
:::



::: {.sourceClojure}
```clojure
(def downsampled-gray (downsample-2x grayscale))
```
:::



::: {.sourceClojure}
```clojure
(tc/dataset {:metric ["Original height" "Original width"
                      "Downsampled height" "Downsampled width"]
             :value (let [[oh ow] (dtype/shape grayscale)
                          [dh dw] (dtype/shape downsampled-gray)]
                      [oh ow dh dw])})
```
:::


::: {.clay-dataset}
_unnamed [4 2]:

|            :metric | :value |
|--------------------|-------:|
|    Original height |    960 |
|     Original width |   1280 |
| Downsampled height |    480 |
|  Downsampled width |    640 |


:::


Visualize original vs downsampled:


::: {.sourceClojure}
```clojure
(kind/table
 [[:original :downsampled-2x]
  [(bufimg/tensor->image grayscale)
   (bufimg/tensor->image downsampled-gray)]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>original</td><td>downsampled-2x</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image20.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image21.png" /></p></div></td></tr></tbody></table>
```

:::


Both grayscale tensors render as grayscale images.


## Image Pyramid

An [image pyramid](https://en.wikipedia.org/wiki/Pyramid_(image_processing)) contains
the same image at multiple scales. This is essential for multi-scale analysis, feature
detection at different sizes, and efficient image processing algorithms.


::: {.sourceClojure}
```clojure
(defn build-pyramid
  "Build image pyramid with multiple scales.
  Takes: [H W] tensor, levels (number of scales)
  Returns: vector of tensors [[H W] [H/2 W/2] [H/4 W/4] ...]"
  [img-2d levels]
  (loop [pyramid [img-2d]
         current img-2d
         level 1]
    (if (>= level levels)
      pyramid
      (let [next-level (downsample-2x current)]
        (recur (conj pyramid next-level)
               next-level
               (inc level))))))
```
:::



::: {.sourceClojure}
```clojure
(def gray-pyramid (build-pyramid grayscale 4))
```
:::


Inspect pyramid shapes:


::: {.sourceClojure}
```clojure
(tc/dataset {:level (range (count gray-pyramid))
             :height (mapv #(first (dtype/shape %)) gray-pyramid)
             :width (mapv #(second (dtype/shape %)) gray-pyramid)})
```
:::


::: {.clay-dataset}
_unnamed [4 3]:

| :level | :height | :width |
|-------:|--------:|-------:|
|      0 |     960 |   1280 |
|      1 |     480 |    640 |
|      2 |     240 |    320 |
|      3 |     120 |    160 |


:::


Visualize each level:


::: {.sourceClojure}
```clojure
(kind/fragment
 (mapv bufimg/tensor->image gray-pyramid))
```
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image22.png)
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image23.png)
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image24.png)
:::


::: {.clay-image}
![](image_processing_with_tensors_files/image25.png)
:::


Each grayscale tensor at different scales renders as a grayscale image.

**Use case**: Multi-scale edge detection for finding features at different sizes.


## Block Average Downsampling

Instead of selecting pixels, we can average blocks for smoother downsampling:


::: {.sourceClojure}
```clojure
(defn downsample-avg
  "Downsample by averaging blocks.
  Takes: [H W] tensor, factor (downsampling factor)
  Returns: [H/factor W/factor] float32 tensor"
  [img-2d factor]
  (let [[h w] (dtype/shape img-2d)
        new-h (quot h factor)
        new-w (quot w factor)]
    (tensor/compute-tensor
     [new-h new-w]
     (fn [y x]
       (let [block (tensor/select img-2d
                                  (range (* y factor) (* (inc y) factor))
                                  (range (* x factor) (* (inc x) factor)))]
         (dfn/mean block)))
     :float32)))
```
:::



::: {.sourceClojure}
```clojure
(def avg-downsampled (downsample-avg grayscale 2))
```
:::


Compare simple vs average downsampling:


::: {.sourceClojure}
```clojure
(kind/table
 [[:select-every-2nd :average-blocks]
  [(bufimg/tensor->image downsampled-gray)
   (bufimg/tensor->image avg-downsampled)]])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><tbody><tr><td>select-every-2nd</td><td>average-blocks</td></tr><tr><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image26.png" /></p></div></td><td><div class="clay-image"><p><img alt="" src="image_processing_with_tensors_files/image27.png" /></p></div></td></tr></tbody></table>
```

:::


Both are grayscale. `tensor->image` handles float32 → uint8 conversion automatically.

Average downsampling produces smoother results with less [aliasing](https://en.wikipedia.org/wiki/Aliasing).

**Verification**: Both produce same shape, but averaging reduces noise


::: {.sourceClojure}
```clojure
(tc/dataset {:method ["Select every 2nd" "Average blocks"]
             :height (mapv #(first (dtype/shape %)) [downsampled-gray avg-downsampled])
             :width (mapv #(second (dtype/shape %)) [downsampled-gray avg-downsampled])
             :mean (mapv dfn/mean [downsampled-gray avg-downsampled])})
```
:::


::: {.clay-dataset}
_unnamed [2 4]:

|          :method | :height | :width |        :mean |
|------------------|--------:|-------:|-------------:|
| Select every 2nd |     480 |    640 | 115.39179457 |
|   Average blocks |     480 |    640 | 115.37941120 |


:::


---


# Conclusion: The dtype-next Pattern

We started with a simple question: **Why use dtype-next for image processing?**

Through building a complete analysis toolkit—from channel statistics to edge detection
to convolution—we've seen the answer in action:


- **Efficient typed arrays** replace boxed sequences, saving memory and enabling SIMD
- **Zero-copy views** let us slice and transform without allocation overhead
- **Functional composition** keeps operations pure and composable
- **Immediate visual feedback** makes abstract tensor operations concrete and verifiable

Images provided the perfect learning vehicle: every transformation has visible results
we can inspect in the REPL. The patterns we've practiced transfer directly to any
domain requiring efficient numerical computing.


## Key Patterns

1. **Zero-copy views** — `tensor/select` creates views without copying data
2. **Reduction operations** — `dfn/mean`, `dfn/standard-deviation`, etc.
3. **Element-wise ops** — `dfn/+`, `dfn/*`, `dfn/sqrt` work across entire tensors
4. **Type discipline** — upcast → compute → clamp → downcast for precision control
5. **Functional composition** — pure functions composed with `->` and function composition
6. **Objective verification** — numeric properties that can be checked in REPL


## API Coverage

Here are the key dtype-next functions we used throughout this tutorial:

**dtype namespace (tech.v3.datatype):**

- `dtype/shape` — Inspect tensor dimensions
- `dtype/elemwise-datatype` — Check element type
- `dtype/elemwise-cast` — Convert between types
- `dtype/ecount` — Total element count
- `dtype/as-reader` — Convert to readable sequence
- Readers act as functions: `(reader idx)` instead of `(dtype/get-value reader idx)`

**tensor namespace (tech.v3.tensor):**

- `tensor/compute-tensor` — Functionally construct tensors
- `tensor/select` — Extract slices, channels (zero-copy)
- Tensors act as functions: `(tensor y x)` instead of `(tensor/mget tensor y x)`
- `tensor/reshape` — Reinterpret tensor shape (zero-copy)
- `tensor/reduce-axis` — Reduce along specific dimension

**dfn namespace (tech.v3.datatype.functional):**

- `dfn/+`, `dfn/-`, `dfn/*`, `dfn//` — Element-wise arithmetic
- `dfn/mean`, `dfn/standard-deviation` — Statistics
- `dfn/reduce-min`, `dfn/reduce-max` — Range finding
- `dfn/sqrt`, `dfn/sq` — Mathematical operations
- `dfn/min`, `dfn/max` — Clamping
- `dfn/sum` — Summation

**bufimg namespace (tech.v3.libs.buffered-image):**

- `bufimg/load` — Load image file
- `bufimg/as-ubyte-tensor` — BufferedImage → tensor
- `bufimg/tensor->image` — tensor → BufferedImage
- `bufimg/image-type` — Check image format


## What Makes This Functional?


- **Pure functions** — all transformations return new values
- **Immutable views** — original data never changes
- **Composition** — operations chain naturally
- **Lazy evaluation** — computations deferred until needed
- **No mutation** — even `tensor/compute-tensor` builds new structures


## Beyond Images: dtype-next in Other Domains

The tensor patterns we've explored transfer directly to other use cases:

**Time series analysis**: 1D or 2D tensors for signals, windowing operations
for feature extraction, functional ops for filtering and aggregation.

**Scientific computing**: Multi-dimensional numerical arrays, zero-copy slicing
for memory efficiency, type discipline for numerical precision.

**Machine learning prep**: Batch processing, normalization pipelines, data
augmentation—all using the same functional patterns.

**Signal processing**: Audio (1D), video (4D: time×height×width×channels),
sensor arrays—dtype-next handles arbitrary dimensionality.

dtype-next also provides:

- **Native interop**: Zero-copy integration with native libraries (OpenCV, Numpy, etc.)
- **Dataset tools**: Rich `tech.ml.dataset` integration for tabular workflows
- **Performance**: SIMD-optimized operations, parallel processing support
- **Flexibility**: Custom buffer implementations, extensible type system


## Resources


- [dtype-next docs](https://cnuernber.github.io/dtype-next/)
- [tech.ml.dataset guide](https://techascent.github.io/tech.ml.dataset/)
- [Scicloj tutorials](https://scicloj.github.io/)

---

*Questions, corrections, or ideas? Open an issue on the Clojure Civitas repository.*


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/ClojureCivitas/clojurecivitas.github.io/blob/main/src/dtype_next/image_processing_with_tensors.clj">src/dtype_next/image_processing_with_tensors.clj</a></small></small></pre></div>
```