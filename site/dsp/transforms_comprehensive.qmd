---
author:
  name: Daniel Slutsky
  image: https://avatars.githubusercontent.com/u/5673102?v=4
  url: https://scicloj.github.io/contributors/daslu/
  affiliation:
  - {name: Scicloj, url: 'https://scicloj.github.io/'}
  - {name: Endor Global, url: 'https://endor.global'}
  links:
  - {icon: github, href: 'https://github.com/daslu'}
draft: true
type: post
date: '2025-12-14'
category: data
tags: [dsp, fft, dct, wavelets, transforms, dtype-next, signal-processing, compression, filtering, denoising, jtransforms, fastmath]
format:
  html: {title: 'Signal Transforms: A Comprehensive Guide to FFT, DCT, and Wavelets'}

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.20.0/plotly.min.js" type="text/javascript"></script>

```{=html}
<style>.clay-dataset {
  max-height:400px;
  overflow-y: auto;
}
.printedClojure {
  max-height:400px;
  overflow-y: auto;
}
</style>
```



# Introduction: Why Learn Signal Transforms?

Imagine you're listening to a musical note. You can hear it's an [A](https://en.wikipedia.org/wiki/A_(musical_note)) ([440 Hz](https://en.wikipedia.org/wiki/Hertz)), but how would
you write code to discover that frequency? Or suppose you have 10 seconds of audio—how do
you automatically remove a 60 Hz electrical hum without affecting the music?

These questions lead us to **signal transforms**—mathematical tools that reveal hidden structure
in data. Classic [JPEG](https://en.wikipedia.org/wiki/JPEG) images use the [Discrete Cosine Transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform) for [compression](https://en.wikipedia.org/wiki/Data_compression). [MP3](https://en.wikipedia.org/wiki/MP3) audio uses
a variant called the [Modified DCT](https://en.wikipedia.org/wiki/Modified_discrete_cosine_transform). Speech recognition, radar systems, medical imaging—all depend
on transforming signals between different representations.

At their core, transforms answer a simple question: **can we express this signal as a weighted
sum of simpler [basis functions](https://en.wikipedia.org/wiki/Basis_function)?** The [Fourier transform](https://en.wikipedia.org/wiki/Fourier_transform) uses sines and cosines. [Wavelets](https://en.wikipedia.org/wiki/Wavelet) use
localized, scaled functions. Each transform gives us a different lens for understanding and
manipulating data.


## What Tools We'll Use

We'll use [JTransforms](https://github.com/wendykierp/JTransforms)—a fast, battle-tested, pure Java library—for
computing the actual transforms (FFT, DCT, wavelets, etc.). It's wrapped in [fastmath](https://generateme.github.io/fastmath/),
which provides a clean, idiomatic Clojure API for signal processing.

For array operations on signals, we'll use [dtype-next](https://github.com/cnuernber/dtype-next), which provides
efficient typed arrays and functional operations like `dfn/+`, `dfn/*`, and `dfn/sq`. This gives us the speed
of Java libraries with the expressiveness of Clojure's functional style.


## What You'll Learn

This tutorial combines theory with practice, building from foundations to real applications.
We'll start with **signal generation**, creating test signals with different characteristics.
Then we'll explore the **core transforms**—DFT (via FFT), DCT, and wavelets—along with
specialized variants. You'll see **practical applications** like filtering, compression, and
denoising, with efficient **dtype-next** array operations throughout. Each section demonstrates
transforms through runnable code with visual feedback, and we'll use **test-driven validation**
to ensure correctness, making abstract mathematics concrete and verifiable.


## Prerequisites

You should be comfortable with basic Clojure (functions, maps, sequences) and high school
mathematics (sine, cosine, basic algebra). Understanding that higher pitch means higher
**frequency** is helpful. No digital signal processing background required—we'll build
intuition through visualization and concrete examples.


## Tutorial Structure

We'll progress from simple signal generation to advanced multi-dimensional transforms. We start
with **signal generation**, creating test signals with known properties. Then we explore the
**DFT/FFT** for discovering frequencies, the **DCT** for compression (used in JPEG and MP3),
and **wavelets** for time-frequency localization and denoising. We'll also cover **specialized
transforms** like DST, DHT, and 2D variants.

The later sections focus on **practical applications**—filtering, compression, and analysis
tools—followed by a **testing framework** for validation and **best practices** for choosing
the right transform. Throughout, we'll introduce dtype-next operations as needed, learning
efficient array manipulation in the context of solving real problems. Each section includes
visualizations and round-trip tests to verify correctness.

Let's begin by learning to generate the signals we'll be transforming!


# Signal Generation and Visualization

Before we can analyze frequencies, we need signals to analyze. This section introduces
signal generation and visualization—the foundation for everything that follows.

We'll also meet **dtype-next**, Clojure's efficient array programming library. Rather than
learning it abstractly, we'll discover dtype-next operations as we need them for generating
and manipulating signals.


## Introduction to fastmath.signal and dtype-next


::: {.sourceClojure}
```clojure
(require '[fastmath.signal :as sig])
```
:::



::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype :as dtype])
```
:::



::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype.functional :as dfn])
```
:::



::: {.sourceClojure}
```clojure
(require '[tech.v3.datatype.argops :as argops])
```
:::


The fastmath.signal library provides signal generation through [oscillators](https://en.wikipedia.org/wiki/Signal_generator).
An oscillator is simply a function mapping time to [amplitude](https://en.wikipedia.org/wiki/Amplitude): time → amplitude.
This functional approach makes it easy to compose complex signals from simple components.

Create a 440 Hz sine wave oscillator


::: {.sourceClojure}
```clojure
(def osc-440 (sig/oscillator :sin 440.0 1.0 0.0))
```
:::


Parameters: type, [frequency](https://en.wikipedia.org/wiki/Frequency), amplitude, [phase](https://en.wikipedia.org/wiki/Phase_(waves))

Oscillators are functions - evaluate at specific times (t=0 and t=0.1s):


::: {.sourceClojure}
```clojure
[(osc-440 0.0) (osc-440 0.1)]
```
:::



::: {.printedClojure}
```clojure
[0.0 -3.9198601261660535E-14]

```
:::


Generate discrete samples:
44.1kHz [sample rate](https://en.wikipedia.org/wiki/Sampling_(signal_processing)), 10ms duration


::: {.sourceClojure}
```clojure
(sig/oscillator->signal osc-440 44100.0 0.01)
```
:::



::: {.printedClojure}
```clojure
[0.0, 0.06264832417874365, 0.12505052369452813, 0.18696144082725336,
 0.24813784794373792, 0.30833940305910035, 0.36732959406137883,
 0.4248766678898383, 0.4807545410165316, 0.5347436876541294,
 0.5866320022005456, 0.6362156325320929, 0.6832997808714387,
 0.7276994690840094, 0.7692402653962486, 0.8077589696806925,
 0.8431042546155975, 0.8751372602002244, 0.9037321392901133,
 0.9287765520091285, 0.9501721070958867, 0.9678347484506665,
 0.9816950853641806, 0.9916986651308531, 0.9978061869755916,
 0.9999936564536084, 0.9982524797167027, 0.9925894972756649,
 0.9830269571261583, 0.969602427343661, 0.9523686484908521,
 0.9313933264172862, 0.9067588662653749, 0.8785620487276838,
 0.8469136498274177, 0.8119380057158566, 0.7737725241965071,
 0.7325671448950286, 0.6884837501957588, 0.6416955292590556,
 0.5923862976180476, 0.5407497750278533, 0.486988824404367,
 0.43131465484258247, 0.37394599184551275, 0.3151082180236203,
 0.2550324876406644, 0.19395481848461169, 0.13211516463136738,
 0.06975647374412507, 0.007123732611891674, -0.05553699532303968,
 -0.11797953666743062, -0.17995857521140243, -0.24123061569515214,
 -0.30155494042174963, -0.36069455495780295, -0.4184171192066551,
 -0.47449586019620704, -0.5287104629953577, -0.5808479362589035,
 -0.6307034490004968, -0.6780811353062296, -0.722794863827391,
 -0.7646689690293306, -0.8035389413235673, -0.839252073371868,
 -0.8716680600231562, -0.9006595495263089, -0.9261126438533076,
 -0.9479273461671316, -0.9660179536764468, -0.980313394333687,
 -0.990757506053757, -0.997309257356394, -0.999942908565361,
 -0.9986481129311697, -0.9934299572800557, -0.9843089420295121,
 -0.9713209006488901, -0.954516858881484, -0.933962834281163,
 -0.9097395768511173, -0.8819422518036459, -0.8506800656873393,
 -0.8160758373504611, -0.7782655154260821, -0.7373976442346147,
 -0.6936327802020241, -0.6471428610864333, -0.5981105304912157,
 -0.5467284203183442, -0.493198393980991, -0.43773075334857275,
 -0.38054341253986085, -0.3218610418100651, -0.2619141848953075,
 -0.20093835328207732, -0.13917310096006505, -0.076861083293317,
 -0.014247103707103909, 0.04842284806422461, 0.1109025623900097,
 0.1729465770199549, 0.2343111414245828, 0.2947551744109035,
 0.3540412112511461, 0.41193633660356815, 0.46821309956024515,
 0.5226504072268894, 0.5750343933241133, 0.6251592583977146,
 0.672828078337052, 0.7178535780251143, 0.7600588670808603,
 0.7992781348033673, 0.8353573015875321, 0.8681546242521786,
 0.8975412529023928, 0.9234017371383941, 0.9456344796221872,
 0.9641521352200855, 0.9788819541530247, 0.9897660678065152,
 0.9967617160773985, 0.9998414153642309, 0.9989930665413147,
 0.994220002492184, 0.9855409750158024, 0.9729900811569101,
 0.9566166292499495, 0.936484945202834, 0.9126741197816123,
 0.8852776978888555, 0.8544033110564996, 0.8201722545969549,
 0.7827190110737126, 0.7421907219635712, 0.6987466095861785,
 0.6525573515718863, 0.6038044103254782, 0.5526793201200532,
 0.49938293462186145, 0.44412463780229566, 0.3871215213371295,
 0.3285975317247166, 0.2687825904738485, 0.20791169081776067,
 0.14622397450298433, 0.08396179228009795, 0.0213697517873014,
 -0.04130624343253929, -0.10381996000604393, -0.16592580209926813,
 -0.2273797762829596, -0.28794045010251973, -0.3473699005866891,
 -0.4054346489686925, -0.4619065779475033, -0.5165638278857105,
 -0.569191668423076, -0.6195833420814977, -0.6675408765471482,
 -0.7128758624385862, -0.7554101935052618, -0.7949767663483981,
 -0.831420136915289, -0.8645971311878683, -0.8943774076663372,
 -0.9206439694380529, -0.9432936238199248, -0.9622373877685285,
 -0.9774008374652203, -0.9887244007028445, -0.9961635909253453,
 -0.9996891820008162, -0.9992873230413596, -0.9949595928186701,
 -0.9867229935615607, -0.9746098841597972, -0.9586678530366604,
 -0.9389595311896838, -0.9155623461340598, -0.8885682177153923,
 -0.8580831969868598, -0.8242270495694983, -0.7871327851324629,
 -0.7469461348417843, -0.7038249788305342, -0.6579387259397131,
 -0.6094676481666195, -0.5586021724354684, -0.5055421324726097,
 -0.4504959837255544, -0.3936799844100698, -0.3353173459027642,
 -0.27563735581699855, -0.21487447720725855, -0.15326742744091648,
 -0.09105824035620122, -0.028491315390845918, 0.0341875425829326,
 0.09673208894492837, 0.158896606741102, 0.22043687202466516,
 0.2811111133316544, 0.3406809615215133, 0.3989123862510416,
 0.455576615402663, 0.5104510338548267, 0.5633200580636206,
 0.6139759830196183, 0.6622197982525427, 0.7078619696779649,
 0.750723184214399, 0.7906350542454076, 0.8274407791591957,
 0.8609957613666314, 0.8911681743776243, 0.9178394807040574,
 0.9409048975545885, 0.9602738084917828, 0.9758701194342947,
 0.9876325576054856, 0.9955149122540149, 0.9994862162006879,
 0.9995308674983134, 0.995648690726628, 0.9878549376814615,
 0.9761802274554481, 0.960670426145682, 0.9413864666609029,
 0.9184041093361411, 0.8918136442952654, 0.8617195367307948,
 0.8282400164945015, 0.7915066136112013, 0.7516636415405575,
 0.7088676302169401, 0.6632867110947972, 0.615099956615462,
 0.5644966766904359, 0.5116756749649672, 0.45684446778395543,
 0.4002184689284223, 0.34202014332566893, 0.2824781330576857,
 0.22182635910162835, 0.16030310233122602, 0.09815006738958451,
 0.035611433111129936, -0.027067106776728054, -0.08963930890343103,
 -0.151859347664545, -0.21348278098965978, -0.2742675106749298,
 -0.33397473350729945, -0.39236987944377644, -0.44922353315999364,
 -0.5043123353475932, -0.5574198602194665, -0.6083374657755144,
 -0.6568651134884359, -0.702812154189337, -0.7459980770656012,
 -0.7862532188285168, -0.8234194302645385, -0.8573506975515395,
 -0.8879137158991022, -0.9149884132591922, -0.9384684220497617,
 -0.9582614970379841, -0.9742898777414488, -0.9864905939235211,
 -0.9948157129826897, -0.9992325282639968, -0.9997236875527314,
 -0.9962872612455728, -0.988936749931366, -0.9777010313517511,
 -0.9626242469500127, -0.9437656284538599, -0.921199265173458,
 -0.8950138129288846, -0.8653121457505724, -0.8322109517210728,
 -0.7958402745459633, -0.756343002654873, -0.7138743078398655,
 -0.6686010356364607, -0.6207010498424329, -0.570362533749413,
 -0.5177832508326333, -0.4631697678032811, -0.4067366430758031,
 -0.34870558383846073, -0.28930457503870327, -0.22876698370530607,
 -0.16733064212600626, -0.10523691348271454, -0.04272974361491648,
 0.019945297363298146, 0.08254197982744962, 0.1448143819978928,
 0.20651785608561196, 0.26740998943292893, 0.3272515568731176,
 0.3858074605673982, 0.4428476536270481, 0.4981480438919785,
 0.5514913743150955, 0.6026680764938378, 0.6514770939954935,
 0.6977266722417961, 0.7412351118496027, 0.7818314824680316,
 0.8193562943075774, 0.853662124723059, 0.8846141973887109,
 0.912090911790027, 0.9359843209522112, 0.9562005555283323,
 0.9726601925811199, 0.9852985676095651, 0.9940660285944805,
 0.9989281310649515, 0.9998657734193406, 0.9968752719691923,
 0.9899683754112395, 0.9791722186706318, 0.964529216296742,
 0.9460968958303518, 0.9239476717968579, 0.8981685612134207,
 0.8688608417277132, 0.8361396537313613, 0.8001335480112053,
 0.7609839807155286, 0.7188447576193768, 0.6738814298722485,
 0.62627064360207, 0.5761994459306503, 0.5238645501270671,
 0.4694715627858897, 0.4132341760665302, 0.35537332816698547,
 0.2961163353303466, 0.23569599879401382, 0.17434969019019303,
 0.1123184189908455, 0.04984588566069994, -0.012822475761727311,
 -0.07544046189372612, -0.13776206726054913, -0.19954245077000266,
 -0.26053889761258414, -0.3205117728081487, -0.37922546265292867,
 -0.43644930036830915, -0.49195847231472983, -0.5455349012105506,
 -0.5969681028859549, -0.6460560132060685, -0.6926057819144502,
 -0.7364345302783594, -0.7773700695591514, -0.8152515774851836,
 -0.8499302300696602, -0.8812697862911105, -0.9091471233395767,
 -0.9334527203256257, -0.954091088551925, -0.9709811466569138,
 -0.9840565391568189, -0.9932658971345277, -0.9985730400511654,
 -0.9999571178875374, -0.9974126930569968, -0.9909497617679348,
 -0.9805937147519644, -0.9663852375120869, -0.9483801504827333,
 -0.9266491897296226, -0.9012777290510405, -0.8723654445722485,
 -0.8400259231507723, -0.8043862161309906, -0.7655863402011965,
 -0.7237787273140511, -0.6791276258316024, -0.631808455247462,
 -0.5820071170213084, -0.5299192642332037, -0.4757495329269612,
 -0.4197107381624439, -0.36202303793517704, -0.30291306824797226,
 -0.24261305273263473, -0.1813598903196625, -0.11939422454024687,
 -0.05695949811699878, 0.005699003442465559, 0.06833511549159066,
 0.13070276134486217, 0.19255691903216382, 0.2536545839095089,
 0.313755723344368, 0.3726242197249783, 0.43002879808874256,
 0.485743934725536, 0.5395507431861802, 0.5912378342153216,
 0.6406021462303005, 0.6874497430833184, 0.7315965759728014,
 0.7728692065106026, 0.8111054881043979, 0.8461552029783131,
 0.8778806523291781, 0.9061571972998319, 0.930873748644203,
 0.9519332031604308, 0.9692528251774035, 0.9827645715960043,
 0.9924153592080726, 0.9981672732428718, 0.9999977163217538,
 0.9978994972358264, 0.9918808591978509, 0.9819654474573699,
 0.9681922164062949, 0.9506152765399138, 0.9293036818745531,
 0.9043411586570455, 0.8758257764318569, 0.8438695627580838,
 0.808598063090023, 0.770149847550363, 0.7286759665337543,
 0.6843393572794684, 0.6373142037445788]

```
:::



### Available Oscillator Types

Fastmath supports: :sin, :square, :saw, :triangle, :noise, :constant


::: {.sourceClojure}
```clojure
(def sample-rate 100.0)
```
:::



::: {.sourceClojure}
```clojure
(def duration 1.0)
```
:::



::: {.sourceClojure}
```clojure
(def oscillator-examples
  {:sine (sig/oscillator :sin 3.0 1.0 0.0)
   :square (sig/oscillator :square 3.0 1.0 0.0)
   :saw (sig/oscillator :saw 3.0 1.0 0.0)
   :triangle (sig/oscillator :triangle 3.0 1.0 0.0)})
```
:::


Visualize different types


::: {.sourceClojure}
```clojure
(def osc-viz-data
  (for [[osc-type osc] oscillator-examples
        [i value] (map-indexed vector
                               (take 50 (sig/oscillator->signal osc sample-rate duration)))]
    {:time (/ i sample-rate)
     :amplitude value
     :type (name osc-type)}))
```
:::



::: {.sourceClojure}
```clojure
(-> (tc/dataset osc-viz-data)
    (plotly/base {:=x :time
                  :=y :amplitude
                  :=mark-color :type
                  :=x-title "Time (s)"
                  :=y-title "Amplitude"
                  :=title "Oscillator Types (3 Hz)"
                  :=width 700
                  :=height 250})
    (plotly/layer-line))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,0.1873813145857246,0.368124552684678,0.5358267949789964,0.6845471059286887,0.8090169943749473,0.9048270524660195,0.9685831611286311,0.9980267284282716,0.9921147013144779,0.9510565162951535,0.8763066800438637,0.7705132427757895,0.6374239897486894,0.4817536741017153,0.3090169943749477,0.12533323356430412,-0.06279051952931383,-0.24868988716485513,-0.4257792915650721,-0.5877852522924728,-0.7289686274214113,-0.8443279255020149,-0.9297764858882516,-0.9822872507286885,-1.0,-0.9822872507286886,-0.9297764858882511,-0.8443279255020152,-0.728968627421412,-0.5877852522924731,-0.4257792915650724,-0.24868988716485455,-0.06279051952931279,0.1253332335643051,0.3090169943749471,0.4817536741017157,0.6374239897486899,0.7705132427757888,0.8763066800438631,0.9510565162951534,0.9921147013144777,0.9980267284282716,0.9685831611286311,0.90482705246602,0.8090169943749477,0.6845471059286884,0.5358267949789971,0.3681245526846794,0.18738131458572546,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-0.94,-0.8799999999999999,-0.8199999999999998,-0.7599999999999998,-0.6999999999999997,-0.6399999999999997,-0.5799999999999996,-0.5199999999999996,-0.4599999999999995,-0.39999999999999947,-0.3399999999999994,-0.27999999999999936,-0.22000000000000064,-0.15999999999999925,-0.10000000000000053,-0.04000000000000048,0.019999999999999574,0.07999999999999963,0.13999999999999968,0.19999999999999973,0.2599999999999998,0.31999999999999984,0.3799999999999999,0.43999999999999995,0.5,0.56,0.6200000000000001,0.6800000000000002,0.7400000000000002,0.8000000000000003,0.8600000000000003,0.9200000000000004,0.9800000000000004,-0.9599999999999995,-0.8999999999999995,-0.8400000000000007,-0.7799999999999994,-0.7200000000000006,-0.6599999999999993,-0.6000000000000005,-0.5400000000000005,-0.4800000000000004,-0.4200000000000004,-0.3600000000000003,-0.30000000000000027,-0.2400000000000002,-0.18000000000000016,-0.1200000000000001,-0.06000000000000005,1.0,0.8799999999999999,0.7599999999999998,0.6399999999999997,0.5199999999999996,0.39999999999999947,0.27999999999999936,0.15999999999999925,0.03999999999999915,-0.08000000000000096,-0.20000000000000107,-0.3200000000000012,-0.4400000000000013,-0.5599999999999987,-0.6800000000000015,-0.7999999999999989,-0.919999999999999,-0.9600000000000009,-0.8400000000000007,-0.7200000000000006,-0.6000000000000005,-0.4800000000000004,-0.3600000000000003,-0.2400000000000002,-0.1200000000000001,0.0,0.1200000000000001,0.2400000000000002,0.3600000000000003,0.4800000000000004,0.6000000000000005,0.7200000000000006,0.8400000000000007,0.9600000000000009,0.919999999999999,0.7999999999999989,0.6800000000000015,0.5599999999999987,0.4400000000000013,0.3199999999999985,0.20000000000000107,0.08000000000000096,-0.03999999999999915,-0.15999999999999925,-0.27999999999999936,-0.39999999999999947,-0.5199999999999996,-0.6399999999999997,-0.7599999999999998,-0.8799999999999999],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"type"},"lon":null,"lat":null,"x":[0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49,0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49,0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49,0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49],"text":null}], {"width":700,"height":250,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Time (s)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Amplitude","showgrid":true},"title":"Oscillator Types (3 Hz)"}, {});</script></div>
```



### Combining Multiple Frequencies

Use `oscillators-sum` for composite signals:
Three sine waves: 3 Hz, 7 Hz, and 15 Hz


::: {.sourceClojure}
```clojure
(def composite-osc
  (sig/oscillators-sum
   (sig/oscillator :sin 3.0 1.0 0.0)
   (sig/oscillator :sin 7.0 0.5 0.0)
   (sig/oscillator :sin 15.0 0.3 0.0)))
```
:::



::: {.sourceClojure}
```clojure
(def composite-signal
  (sig/oscillator->signal composite-osc sample-rate duration))
```
:::



### Teaching Signals: Designed for Transform Comparison

Now let's create a suite of test signals, each designed to highlight different transform strengths.
These aren't arbitrary—each signal has specific characteristics that make certain transforms
more effective than others.

**Why multiple test signals?** Different transforms excel at different tasks. The FFT
easily finds exact frequencies in **pure tones**. The DCT concentrates energy efficiently
for **smooth signals** (good for compression). **Wavelets** capture time-localized features
like transient events. By testing each transform on all signals, we'll build intuition for
when to use which tool.


::: {.sourceClojure}
```clojure
(defn teaching-signals
  "Standard test signals with known properties.
  
  Each signal is designed to test different transform characteristics:

  - :pure-sine - Single frequency (FFT baseline)
  - :two-tones - Multiple frequencies (tests superposition)
  - :smooth - Low frequency content (DCT compression test)
  - :chirp - Time-varying frequency (wavelet localization test)
  - :impulse - Sharp transient (wavelet vs FFT comparison)"
  []
  {:pure-sine
   {:signal (sig/oscillator->signal
             (sig/oscillator :sin 10.0 1.0 0.0)
             sample-rate duration)
    :description "Single frequency - FFT baseline"
    :best-transform :fft}

   :two-tones
   {:signal (sig/oscillator->signal
             (sig/oscillators-sum
              (sig/oscillator :sin 10.0 1.0 0.0)
              (sig/oscillator :sin 25.0 0.5 0.0))
             sample-rate duration)
    :description "Two frequencies - superposition principle"
    :best-transform :fft}

   :smooth
   {:signal (sig/oscillator->signal
             (sig/oscillators-sum
              (sig/oscillator :sin 5.0 1.0 0.0)
              (sig/oscillator :sin 10.0 0.3 0.0)
              (sig/oscillator :sin 15.0 0.1 0.0))
             sample-rate duration)
    :description "Smooth signal - DCT compresses well"
    :best-transform :dct}

   :chirp
   {:signal (let [n (int (* sample-rate duration))]
              (double-array
               (for [i (range n)]
                 (let [t (/ i sample-rate)
                       freq (+ 5.0 (* 45.0 t))] ;; 5→50 Hz sweep
                   (Math/sin (* 2 Math/PI freq t))))))
    :description "Frequency sweep - wavelets capture time-varying content"
    :best-transform :wavelet}

   :impulse
   {:signal (double-array
             (concat [5.0] (repeat 99 0.0)))
    :description "Localized event - wavelets excel here"
    :best-transform :wavelet}})
```
:::



::: {.sourceClojure}
```clojure
(def signals (teaching-signals))
```
:::



### Signal Visualization with dtype-next

Now we'll visualize signals using dtype-next for data preparation and Tableplot for rendering.
This is where dtype-next shines: we can efficiently extract slices and perform element-wise
division to compute time values.


::: {.sourceClojure}
```clojure
(defn visualize-signal
  "Plot signal using dtype-next for data preparation.
  
  dtype-next operations used:

  - dtype/ecount: Get array length
  - dtype/sub-buffer: Zero-copy slice extraction
  - dfn//: Element-wise division for time computation"
  [signal title]
  (let [display-n (min 200 (dtype/ecount signal))
        time-vals (dfn// (range display-n) sample-rate) ; Element-wise division
        amp-vals (dtype/sub-buffer signal 0 display-n) ; Zero-copy slice

        dataset (tc/dataset {:time time-vals
                             :amplitude amp-vals})]

    (-> dataset
        (plotly/base {:=x :time
                      :=y :amplitude
                      :=x-title "Time (s)"
                      :=y-title "Amplitude"
                      :=title title
                      :=width 700
                      :=height 200})
        (plotly/layer-line))))
```
:::



::: {.sourceClojure}
```clojure
(visualize-signal (:signal (:two-tones signals)) "Two Tones: 10 Hz + 25 Hz")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,1.0,0.9510565162951534,0.45105651629515353,0.5877852522924736,0.5000000000000001,-0.5877852522924726,-1.0,-0.9510565162951531,-0.08778525229247314,6.12323399409214E-17,0.0877852522924728,0.9510565162951531,1.0,0.5877852522924707,-0.4999999999999996,-0.5877852522924712,-0.451056516295154,-0.9510565162951532,-1.0,-1.1021821191433804E-15,1.0,0.9510565162951559,0.45105651629515375,0.5877852522924728,0.5000000000000007,-0.5877852522924735,-1.0,-0.9510565162951501,-0.08778525229247347,1.9600538592230147E-15,0.08778525229247247,0.9510565162951559,1.0,0.5877852522924666,-0.49999999999999917,-0.5877852522924734,-0.4510565162951544,-0.9510565162951511,-1.0,-2.2043642382867608E-15,1.0,0.9510565162951587,0.451056516295155,0.5877852522924691,0.5000000000000011,-0.5877852522924688,-1.0,-0.9510565162951554,-0.08778525229247391,-1.4701951394888483E-15,0.08778525229247491,0.9510565162951552,1.0,0.5877852522924648,-0.5000000000000022,-0.5877852522924721,-0.451056516295152,-0.951056516295147,-1.0,-6.859260036437437E-15,1.0,0.9510565162951496,0.4510565162951551,0.5877852522924796,0.49999999999999806,-0.5877852522924842,-1.0,-0.9510565162951434,-0.08778525229247713,2.2049832191934954E-15,0.08778525229246881,0.9510565162951508,1.0,0.5877852522924694,-0.4999999999999946,-0.5877852522924774,-0.4510565162951541,-0.95105651629515,-1.0,-4.4087284765735216E-15,1.0,0.9510565162951586,0.4510565162951553,0.5877852522924674,0.49999999999999856,-0.587785252292461,-1.0,-0.9510565162951641,-0.0877852522924718,-1.2252657797251627E-15,0.08778525229247414,0.9510565162951465,1.0,0.5877852522924926,-0.4999999999999941,-0.5877852522924739,-0.45105651629515386,-0.9510565162951461,-1.0],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49,0.5,0.51,0.52,0.53,0.54,0.55,0.56,0.57,0.58,0.59,0.6,0.61,0.62,0.63,0.64,0.65,0.66,0.67,0.68,0.69,0.7,0.71,0.72,0.73,0.74,0.75,0.76,0.77,0.78,0.79,0.8,0.81,0.82,0.83,0.84,0.85,0.86,0.87,0.88,0.89,0.9,0.91,0.92,0.93,0.94,0.95,0.96,0.97,0.98,0.99],"text":null}], {"width":700,"height":200,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Time (s)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Amplitude","showgrid":true},"title":"Two Tones: 10 Hz + 25 Hz"}, {});</script></div>
```


**What we just learned**: Signal generation with fastmath oscillators and basic dtype-next
operations (element-wise math, slicing, counting). We now have test signals that will help
us compare different transforms.

Next, we'll explore the FFT—but first, we need to understand why its output is complex-valued
even though our input signals are real numbers.


## Understanding Complex Transform Outputs

Before we dive into the FFT, we need to address a puzzling fact: when we transform a
real-valued signal (just regular numbers like 1.5, -0.3, 2.7), the FFT returns
**complex numbers** (numbers with "real" and "imaginary" parts).

Why would a transform of real data produce complex output? This seems unnecessarily
complicated. Let's build intuition for why complex numbers are not just mathematical
elegance—they're computational necessity.

**Note on dtype-next operations**: In the examples below, you'll see operations like `dfn/*`
and `dfn//`. These are element-wise operations from dtype-next:

- `dfn/*` multiplies arrays element-by-element: `[1 2 3] * 2 → [2 4 6]`
- `dfn//` divides arrays element-by-element: `[2 4 6] / 2 → [1 2 3]`  
- `dfn/+`, `dfn/-` work similarly for addition and subtraction
- `dfn/cos`, `dfn/sin` apply trigonometric functions to each element

We'll explore these operations more deeply as we use them throughout the tutorial.


### The Problem: Sines and Cosines Are Both Needed

Here's the core issue. Suppose we want to decompose a signal into pure frequency components.
Should we use sines or cosines as our basis functions?


- If we use only **cosines**: We can represent cosine-like signals perfectly, but sine-like
  signals require infinite cosine terms

- If we use only **sines**: We can represent sine-like signals perfectly, but cosine-like
  signals require infinite sine terms

**Solution**: Use BOTH sines and cosines. For each frequency, we need two numbers:
1. How much of the cosine wave at that frequency
2. How much of the sine wave at that frequency

A [complex number](https://en.wikipedia.org/wiki/Complex_number) packages these two values together:
the **real part** stores the cosine amplitude, and the **imaginary part** stores the sine amplitude.
This isn't arbitrary—it's the most compact way to store both components.


### Euler's Formula: The Mathematical Foundation

The mathematical underpinning is [Euler's formula](https://en.wikipedia.org/wiki/Euler%27s_formula),
which connects complex exponentials to sine and cosine:

**e^(iθ) = cos(θ) + i·sin(θ)**

Where i = √(-1) is the imaginary unit. This beautiful equation tells us that a rotating
complex number naturally encodes both sine and cosine components.

Let's visualize this to make it concrete.


### Visualizing Sine and Cosine Together


::: {.sourceClojure}
```clojure
(def theta-points (dfn// (dfn/* 2.0 Math/PI (range 100)) 100.0))
```
:::


Real part: cos(θ)


::: {.sourceClojure}
```clojure
(def cosine-vals (dfn/cos theta-points))
```
:::


Imaginary part: sin(θ)  


::: {.sourceClojure}
```clojure
(def sine-vals (dfn/sin theta-points))
```
:::


Create dataset for visualization


::: {.sourceClojure}
```clojure
(def euler-dataset
  (tc/dataset {:angle (dfn// theta-points (* 2 Math/PI))
               :cosine cosine-vals
               :sine sine-vals}))
```
:::


Using Tableplot (ggplot2-style layered grammar)


::: {.sourceClojure}
```clojure
(-> euler-dataset
    (plotly/base {:=x :angle
                  :=y :cosine
                  :=x-title "Angle (cycles)"
                  :=y-title "Value"
                  :=title "Euler's Formula: e^(iθ) = cos(θ) + i·sin(θ)"
                  :=width 700
                  :=height 300})
    (plotly/layer-line {:=mark-color "steelblue"
                        :=name "cos(θ) - Real Part"})
    (plotly/layer-line {:=y :sine
                        :=mark-color "orange"
                        :=name "sin(θ) - Imaginary Part"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[1.0,0.9980267284282716,0.9921147013144779,0.9822872507286887,0.9685831611286311,0.9510565162951535,0.9297764858882515,0.9048270524660196,0.8763066800438636,0.8443279255020151,0.8090169943749475,0.7705132427757893,0.7289686274214116,0.6845471059286886,0.6374239897486897,0.5877852522924732,0.5358267949789965,0.48175367410171516,0.42577929156507266,0.3681245526846781,0.30901699437494745,0.24868988716485474,0.18738131458572474,0.12533323356430448,0.06279051952931353,6.123233995736766E-17,-0.0627905195293134,-0.12533323356430415,-0.1873813145857246,-0.24868988716485485,-0.3090169943749471,-0.36812455268467775,-0.4257792915650727,-0.48175367410171543,-0.5358267949789969,-0.587785252292473,-0.6374239897486897,-0.6845471059286887,-0.7289686274214113,-0.7705132427757891,-0.8090169943749473,-0.8443279255020149,-0.8763066800438636,-0.9048270524660194,-0.9297764858882513,-0.9510565162951535,-0.968583161128631,-0.9822872507286887,-0.9921147013144778,-0.9980267284282716,-1.0,-0.9980267284282716,-0.9921147013144779,-0.9822872507286886,-0.9685831611286312,-0.9510565162951536,-0.9297764858882515,-0.9048270524660197,-0.8763066800438635,-0.8443279255020152,-0.8090169943749478,-0.7705132427757893,-0.7289686274214118,-0.6845471059286886,-0.6374239897486895,-0.5877852522924732,-0.5358267949789963,-0.48175367410171527,-0.42577929156507216,-0.3681245526846778,-0.30901699437494756,-0.24868988716485443,-0.18738131458572463,-0.1253332335643046,-0.06279051952931321,-1.8369701987210297E-16,0.06279051952931283,0.12533323356430423,0.18738131458572427,0.24868988716485493,0.30901699437494723,0.3681245526846774,0.4257792915650718,0.4817536741017157,0.5358267949789968,0.5877852522924729,0.6374239897486893,0.684547105928688,0.7289686274214112,0.7705132427757894,0.8090169943749473,0.8443279255020147,0.8763066800438631,0.9048270524660194,0.9297764858882515,0.9510565162951535,0.968583161128631,0.9822872507286887,0.9921147013144778,0.9980267284282716],"r":null,"name":"cos(\u03b8) - Real Part","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"steelblue"},"lon":null,"lat":null,"x":[0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17000000000000004,0.18,0.18999999999999997,0.2,0.21000000000000002,0.22,0.22999999999999998,0.24,0.25,0.26,0.27,0.28,0.29000000000000004,0.3,0.31,0.32,0.33,0.3400000000000001,0.35,0.36,0.37000000000000005,0.37999999999999995,0.39,0.4,0.4099999999999999,0.42000000000000004,0.43,0.44,0.45,0.45999999999999996,0.47000000000000003,0.48,0.49,0.5,0.51,0.52,0.53,0.54,0.55,0.56,0.57,0.5800000000000001,0.59,0.6,0.61,0.62,0.63,0.64,0.65,0.66,0.67,0.6800000000000002,0.6900000000000001,0.7,0.7100000000000001,0.72,0.73,0.7400000000000001,0.75,0.7599999999999999,0.77,0.78,0.79,0.8,0.8099999999999999,0.8199999999999998,0.8300000000000001,0.8400000000000001,0.85,0.86,0.8699999999999999,0.88,0.89,0.9,0.9099999999999999,0.9199999999999999,0.9299999999999999,0.9400000000000001,0.95,0.96,0.97,0.98,0.9900000000000001],"text":null},{"y":[0.0,0.06279051952931337,0.12533323356430426,0.1873813145857246,0.2486898871648548,0.3090169943749474,0.3681245526846779,0.42577929156507266,0.4817536741017153,0.5358267949789967,0.5877852522924731,0.6374239897486896,0.6845471059286886,0.7289686274214116,0.7705132427757893,0.8090169943749473,0.8443279255020151,0.8763066800438637,0.9048270524660196,0.9297764858882513,0.9510565162951535,0.9685831611286311,0.9822872507286886,0.9921147013144778,0.9980267284282716,1.0,0.9980267284282716,0.9921147013144779,0.9822872507286887,0.9685831611286311,0.9510565162951536,0.9297764858882515,0.9048270524660195,0.8763066800438635,0.844327925502015,0.8090169943749475,0.7705132427757893,0.7289686274214114,0.6845471059286888,0.6374239897486899,0.5877852522924732,0.535826794978997,0.4817536741017152,0.4257792915650729,0.36812455268467814,0.3090169943749475,0.24868988716485524,0.18738131458572457,0.12533323356430454,0.06279051952931358,1.2246467991473532E-16,-0.06279051952931335,-0.12533323356430429,-0.18738131458572477,-0.24868988716485457,-0.3090169943749473,-0.3681245526846779,-0.42577929156507227,-0.4817536741017154,-0.5358267949789964,-0.5877852522924727,-0.6374239897486896,-0.6845471059286884,-0.7289686274214116,-0.7705132427757894,-0.8090169943749473,-0.8443279255020153,-0.8763066800438636,-0.9048270524660198,-0.9297764858882515,-0.9510565162951535,-0.9685831611286312,-0.9822872507286887,-0.9921147013144778,-0.9980267284282716,-1.0,-0.9980267284282716,-0.9921147013144779,-0.9822872507286887,-0.9685831611286311,-0.9510565162951536,-0.9297764858882516,-0.9048270524660199,-0.8763066800438634,-0.844327925502015,-0.8090169943749476,-0.7705132427757896,-0.7289686274214121,-0.684547105928689,-0.6374239897486896,-0.5877852522924734,-0.5358267949789971,-0.4817536741017161,-0.425779291565073,-0.36812455268467786,-0.3090169943749476,-0.24868988716485535,-0.18738131458572468,-0.12533323356430465,-0.06279051952931326],"r":null,"name":"sin(\u03b8) - Imaginary Part","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"orange"},"lon":null,"lat":null,"x":[0.0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17000000000000004,0.18,0.18999999999999997,0.2,0.21000000000000002,0.22,0.22999999999999998,0.24,0.25,0.26,0.27,0.28,0.29000000000000004,0.3,0.31,0.32,0.33,0.3400000000000001,0.35,0.36,0.37000000000000005,0.37999999999999995,0.39,0.4,0.4099999999999999,0.42000000000000004,0.43,0.44,0.45,0.45999999999999996,0.47000000000000003,0.48,0.49,0.5,0.51,0.52,0.53,0.54,0.55,0.56,0.57,0.5800000000000001,0.59,0.6,0.61,0.62,0.63,0.64,0.65,0.66,0.67,0.6800000000000002,0.6900000000000001,0.7,0.7100000000000001,0.72,0.73,0.7400000000000001,0.75,0.7599999999999999,0.77,0.78,0.79,0.8,0.8099999999999999,0.8199999999999998,0.8300000000000001,0.8400000000000001,0.85,0.86,0.8699999999999999,0.88,0.89,0.9,0.9099999999999999,0.9199999999999999,0.9299999999999999,0.9400000000000001,0.95,0.96,0.97,0.98,0.9900000000000001],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Angle (cycles)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Value","showgrid":true},"title":"Euler's Formula: e^(i\u03b8) = cos(\u03b8) + i\u00b7sin(\u03b8)"}, {});</script></div>
```


As the angle θ increases from 0 to 2π (one full rotation), cosine and sine trace out
their familiar wave shapes. The key insight: **we need both functions to completely
describe a sinusoid at any phase**.


### Concrete Example: Pure Cosine vs Pure Sine Signals

Let's demonstrate why we need complex output by transforming pure cosine and pure sine signals.

Create a simple 5 Hz cosine wave


::: {.sourceClojure}
```clojure
(def pure-cosine-time (dfn// (range 100) 100.0))
```
:::



::: {.sourceClojure}
```clojure
(def pure-cosine-signal
  (dfn/cos (dfn/* 2.0 Math/PI 5.0 pure-cosine-time)))
```
:::


FFT gives complex output (stored as alternating real, imaginary pairs)


::: {.sourceClojure}
```clojure
(def fft-basic (t/transformer :real :fft))
```
:::



::: {.sourceClojure}
```clojure
(def cosine-spectrum (t/forward-1d fft-basic pure-cosine-signal))
```
:::


The spectrum has 100 values: 50 complex numbers stored as [real₀, imag₀, real₁, imag₁, ...]


::: {.sourceClojure}
```clojure
(dtype/ecount cosine-spectrum)
```
:::



::: {.printedClojure}
```clojure
100

```
:::


Look at frequency bin 5 (the 5 Hz component we put in)
Large value in real part, ≈0 in imaginary part


::: {.sourceClojure}
```clojure
(def freq-bin-5-real (dtype/get-value cosine-spectrum (* 2 5)))
```
:::



::: {.sourceClojure}
```clojure
(def freq-bin-5-imag (dtype/get-value cosine-spectrum (+ 1 (* 2 5))))
```
:::


Pure cosine = nearly all energy in REAL part (cosine basis function)
Imaginary part ≈ 0 (no sine component needed, apart from numerical noise)

Now try a pure sine wave


::: {.sourceClojure}
```clojure
(def pure-sine-signal
  (dfn/sin (dfn/* 2.0 Math/PI 5.0 pure-cosine-time)))
```
:::



::: {.sourceClojure}
```clojure
(def sine-spectrum (t/forward-1d fft-basic pure-sine-signal))
```
:::


≈0 in real part, large value in imaginary part


::: {.sourceClojure}
```clojure
(def sine-freq-bin-5-real (dtype/get-value sine-spectrum (* 2 5)))
```
:::



::: {.sourceClojure}
```clojure
(def sine-freq-bin-5-imag (dtype/get-value sine-spectrum (+ 1 (* 2 5))))
```
:::


Pure sine = nearly all energy in IMAGINARY part (sine basis function)
Real part ≈ 0 (no cosine component needed, apart from numerical noise)

**Key Takeaway**: 

- Pure **cosine** signal → FFT has large **real part**, near-zero imaginary part
- Pure **sine** signal → FFT has near-zero real part, large **imaginary part**
- General signal → FFT has **both parts**, encoding the phase relationship

This is why FFT output is complex even though input is real!


### Phase: Encoding the Sine/Cosine Balance

Any sinusoid can be written two ways: as **amplitude + phase** (A·cos(2πft + φ)) or as
**cosine + sine** (a·cos(2πft) + b·sin(2πft)). The complex number (a + ib) from the FFT
encodes both representations. The **magnitude** √(a² + b²) gives us the amplitude A, and
the **[phase](https://en.wikipedia.org/wiki/Phase_(waves))** arctan(b/a) gives us φ.

This is why we compute magnitude as √(real² + imag²)—we're combining the cosine and sine
contributions to find the total amplitude at each frequency.


### Visualization: Complex Plane Representation


::: {.sourceClojure}
```clojure
(defn complex-plane-viz
  "Visualize how cosine and sine components form complex numbers."
  [signal-type]
  (let [freq 5.0
        t-vals (dfn// (range 100) 100.0)
        signal (case signal-type
                 :cosine (dfn/cos (dfn/* 2.0 Math/PI freq t-vals))
                 :sine (dfn/sin (dfn/* 2.0 Math/PI freq t-vals))
                 :mixed (dfn/+ (dfn/cos (dfn/* 2.0 Math/PI freq t-vals))
                               (dfn/sin (dfn/* 2.0 Math/PI freq t-vals))))
        spectrum (t/forward-1d fft-basic signal)

        ;; Extract complex numbers for positive frequencies
        freq-bins (range 0 50)
        complex-data (map (fn [k]
                            (let [real-part (dtype/get-value spectrum (* 2 k))
                                  imag-part (dtype/get-value spectrum (+ 1 (* 2 k)))]
                              {:frequency k
                               :real real-part
                               :imag imag-part
                               :magnitude (Math/sqrt (+ (* real-part real-part)
                                                        (* imag-part imag-part)))}))
                          freq-bins)
        dataset (tc/dataset complex-data)]

    (-> dataset
        (plotly/base {:=x :real
                      :=y :imag
                      :=x-title "Real Part (Cosine)"
                      :=y-title "Imaginary Part (Sine)"
                      :=title (str "Complex Spectrum: " (name signal-type) " signal")
                      :=width 400
                      :=height 400})
        (plotly/layer-point {:=mark-size :magnitude
                             :=mark-color :frequency}))))
```
:::



::: {.sourceClojure}
```clojure
(complex-plane-viz :cosine)
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[1.7763568394002505E-15,-1.3931766217511135E-15,8.811182001138603E-15,2.9820588610770503E-15,-7.811767546990944E-15,-3.2447829636595664E-14,-7.741500124013445E-15,-1.6201736953326482E-16,-5.337888858192692E-15,-1.9390448124432655E-15,-4.0824691981836024E-15,1.7083871343908434E-15,-1.2434874724669555E-14,-2.6300788270117225E-15,6.786847461137789E-15,2.634813419103575E-15,4.424201206389803E-15,-2.1083622016714446E-15,3.916521584143077E-15,2.0032201423419543E-15,-4.147718923089713E-16,-1.57786334858488E-15,-4.92506410312136E-15,1.2378224528790913E-15,-3.1031470721403077E-16,-8.881784197001252E-16,-6.245205224225149E-16,1.7424693365600352E-15,-5.204189996459913E-15,-1.637318013685629E-15,4.147718923089713E-16,2.0789745142674854E-15,5.001146785998754E-15,-1.8640698725106677E-15,4.424812107098336E-15,4.590919283674435E-15,7.353517267867861E-15,-1.7776275516295213E-15,-1.1520589897496312E-14,1.643804065910669E-15,-2.0681767235209404E-15,-1.6111472977824292E-15,-3.981307425572451E-15,1.8317979718548107E-15,-6.782947554761237E-15,-1.302950312009095E-15,-8.410213509812212E-15,1.7512986883414187E-15,8.505460017558493E-15,-2.1706324428442426E-15],"r":null,"name":"","marker":{"color":"frequency","size":"magnitude"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[-7.105427357601002E-15,-3.2764582657881268E-15,-3.368464076967896E-15,-1.926346044398866E-14,-1.1501497578333358E-14,50.0,1.1915440800174013E-14,5.6045452837239236E-15,5.194889826135432E-16,1.7107809956839582E-15,5.119749285968939E-15,-7.536212158977186E-16,-9.001979200666932E-16,1.490405769221221E-14,2.4222245644194454E-15,9.120210263203118E-16,-4.522345739064484E-16,1.2587292934462305E-15,2.3585911492915095E-15,-4.000391754302784E-15,-2.6645352591003757E-15,-4.851500949296608E-15,2.674416754864104E-15,1.3364757021794747E-15,-1.6165942990473082E-15,-8.881784197001252E-16,2.4649922349218596E-15,-4.601022808535425E-16,-1.1865805626704044E-15,5.221974745097433E-15,2.6645352591003757E-15,4.408409315052292E-15,-1.1007260623011344E-15,2.4967000749947755E-16,1.7019616883556694E-15,-2.5366450311705284E-15,-1.6533987415404129E-15,-1.3843226448304674E-14,2.414040601543919E-15,2.525074820193046E-15,-1.718768441718472E-15,1.4314131731978626E-16,1.785978280305089E-15,-5.792722486079339E-16,-1.5572474112513782E-15,3.552713678800501E-15,2.2931779543944446E-15,1.3699185056254863E-14,-1.6622566616727834E-15,-7.033415477471791E-16],"text":null}], {"width":400,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Real Part (Cosine)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Imaginary Part (Sine)","showgrid":true},"title":"Complex Spectrum: cosine signal"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(complex-plane-viz :sine)
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[5.100222969156358E-15,4.353600865338995E-15,2.800757376957018E-15,-1.1393640640606549E-14,7.213819564850515E-15,-50.0,-1.1995132695945014E-14,-4.410033699882044E-15,-3.328775643507587E-15,-4.620022853347119E-15,-7.37294092576272E-15,-6.027224282606797E-16,-1.9307542868692628E-15,-1.5183028886228046E-14,-2.0028128108027928E-15,-3.1444568589661706E-15,-1.7105678068580288E-15,1.3922975500929395E-15,-7.4693046000841025E-16,-5.675678638022248E-15,-3.552713678800501E-15,-5.3725375862282446E-15,-1.4330312147079407E-15,8.136220371198271E-16,-8.908624582427417E-16,-1.7763568394002505E-15,-8.2012485958947325E-16,7.534489346709521E-16,-6.322146699784616E-16,-4.475150625706864E-15,-3.552713678800501E-15,-5.246591436849665E-15,-2.1216114645973412E-16,1.9449891947210196E-15,7.262236858992037E-16,-4.419200916359353E-15,7.83286279664985E-17,-1.4409970178209993E-14,-7.340020229323044E-16,1.5013685877895857E-15,2.0104560532456E-15,-1.6054821521019367E-15,-2.2095157029385255E-16,1.2211887463303605E-15,-2.4096561676473988E-16,0.0,4.0752263641457303E-16,-1.4350520721881784E-14,-3.0079517779627107E-18,2.806191461327319E-15],"r":null,"name":"","marker":{"color":"frequency","size":"magnitude"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[-5.5579180672451444E-15,8.210153482114621E-16,-1.2852250857754798E-14,2.7972681535565574E-15,5.534902769164788E-15,-3.181924669700673E-14,1.7357994513962996E-15,-1.3810675888058159E-15,-4.018590914665651E-15,3.9841263226572317E-16,-4.785438342763957E-15,1.5981389351877882E-16,-1.0936418891455117E-14,3.5803842113826987E-16,5.5385047818853E-15,3.204567113997729E-15,4.238906110839409E-15,8.08674567969482E-16,-3.2997518232376055E-15,4.1318013619757745E-16,1.9315332515980273E-15,5.091506277795895E-16,4.517618442642927E-15,6.01135728697218E-18,-3.907934777055952E-16,1.5475092903558574E-15,9.048005892470527E-16,1.1441427351499652E-15,-4.138993037469838E-15,5.914011742612344E-16,-1.6211804272024736E-15,7.55939863499805E-16,5.1247036402630275E-15,6.921766512186015E-16,-2.8781934071570898E-15,2.0834961939812042E-16,-3.725022802363349E-15,7.685170063488405E-16,1.2305497394003191E-14,5.648911778424479E-16,3.361927666722482E-15,1.156691829317765E-15,3.631770918838315E-15,3.8960347544741235E-16,-1.3551085254432372E-15,3.7078900909982786E-15,-3.4805614941268174E-15,5.398692164264776E-16,1.5789649124572315E-14,7.527373128423814E-16],"text":null}], {"width":400,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Real Part (Cosine)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Imaginary Part (Sine)","showgrid":true},"title":"Complex Spectrum: sine signal"}, {});</script></div>
```



::: {.sourceClojure}
```clojure
(complex-plane-viz :mixed)
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[1.0658141036401503E-14,2.7171983313554373E-15,1.0925873224604457E-14,-8.889825881273484E-15,-8.405231551947381E-16,-50.00000000000004,-1.8961159225299273E-14,-5.134725870523651E-15,-9.688201785498131E-15,-5.1054308999738166E-15,-7.316936735777237E-15,3.753739081165657E-16,-1.4136413234734979E-14,-1.808298131923579E-14,5.2883937298500116E-15,-6.587402728964064E-16,2.230917665260246E-15,-8.737163883260872E-16,3.758259861289955E-15,-3.761326225972669E-15,0.0,-6.864358106979133E-15,-5.644190193168096E-15,2.6996820979333147E-15,-1.320938268632873E-15,-3.552713678800501E-15,-1.6391571840098467E-15,2.0503506138469715E-15,-5.350242451973388E-15,-7.153130682582172E-15,0.0,-3.5117654180960928E-15,4.884949882480189E-15,-5.745424616681436E-16,5.677763831908285E-15,-2.9550527394217366E-15,6.868674384584022E-15,-1.5805859665849945E-14,-1.277145834721041E-14,2.2932209310263132E-15,-2.5078218447015655E-15,-2.04949753616206E-15,-4.483814893699368E-15,2.4082245684782044E-15,-6.303860036382737E-15,-3.552713678800501E-15,-8.908565113658372E-15,-1.2226059802318738E-14,8.848188427627552E-15,1.8131659439652434E-16],"r":null,"name":"","marker":{"color":"frequency","size":"magnitude"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[-1.0658141036401503E-14,-1.739380182293459E-15,-1.6221139528428634E-14,-1.696478993907823E-14,-7.035012517209394E-15,49.999999999999964,1.3520093072452442E-14,5.291646457489338E-15,-3.3400374867283392E-15,2.773166513886474E-15,-3.9565065370912114E-17,3.0258952954709734E-16,-1.1435302501653664E-14,1.5760150641836224E-14,8.426931582018856E-15,5.1563662064154915E-15,5.100917596187582E-15,1.5005244216650226E-15,-1.731751812415461E-15,-3.3527408758201404E-15,-1.7763568394002505E-15,-3.568851911027302E-15,6.9413577410395294E-15,1.6696108051832167E-15,-2.8876146681905534E-15,0.0,3.807145553654111E-15,2.301167857271117E-16,-4.996883487442308E-15,5.489915143036497E-15,-1.7763568394002505E-15,4.166438402346975E-15,4.166369273748323E-15,5.478041012572279E-16,-8.165151703762016E-16,-2.3874097822068608E-15,-5.118854293444786E-15,-1.307734616502264E-14,1.5126361102990606E-14,1.9788123448835612E-15,8.233223199627821E-16,1.5965160584231535E-16,6.827680086785167E-15,3.021716754088347E-16,-1.7477131802256493E-15,7.105427357601002E-15,-4.972808438364364E-16,1.3687417438534384E-14,1.3479608783106792E-14,-1.1981293074294842E-15],"text":null}], {"width":400,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Real Part (Cosine)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Imaginary Part (Sine)","showgrid":true},"title":"Complex Spectrum: mixed signal"}, {});</script></div>
```


**What we just learned**: Complex FFT outputs aren't mysterious—they're the natural way to
encode both sine and cosine components at each frequency. The real part tells us "how much
cosine," the imaginary part tells us "how much sine."

Now that we understand the complex output format, let's put the FFT to work!


## DFT and FFT - Discovering Frequencies in Signals

We're finally ready to answer our opening question: how do we write code to discover the
frequencies in a signal? The answer is the **[Discrete Fourier Transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform) (DFT)**, computed
efficiently via the **[Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) (FFT)** algorithm.

**Terminology Note**:

- **DFT (Discrete Fourier Transform)** = the mathematical transform
- **FFT (Fast Fourier Transform)** = the [Cooley-Tukey algorithm](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm) for computing DFT efficiently (O(n log n) instead of O(n²))

In practice, "FFT" is often used colloquially to mean both the transform and the algorithm.
We'll be technically precise here, but don't be surprised if you see papers and codebases
using "FFT" for both!


### Introduction to fastmath.transform


::: {.sourceClojure}
```clojure
(require '[fastmath.transform :as t])
```
:::


The fastmath.transform library provides a unified API for all signal transforms.
The pattern is consistent across transforms, making it easy to experiment:

**Step 1**: Create a transformer (specifies input type and transform algorithm)


::: {.sourceClojure}
```clojure
(def fft (t/transformer :real :fft))
```
:::


:real means input is real-valued (not complex)
:fft specifies the algorithm

**Step 2**: Forward transform (signal → spectrum)


::: {.sourceClojure}
```clojure
(t/forward-1d fft (range 16))
```
:::



::: {.printedClojure}
```clojure
[120.0, -8.0, -7.999999999999995, 40.218715937006785, -8.0,
 19.31370849898476, -8.0, 11.972846101323913, -8.0, 8.0, -8.0,
 5.345429103354391, -8.0, 3.313708498984761, -8.000000000000004,
 1.591298939037264]

```
:::


**Step 3**: Reverse transform (spectrum → signal) 
(t/reverse-1d fft spectrum)

This same pattern works for DCT, DST, DHT, and wavelets—just change the transform type!


### Performance: JTransforms and Parallelism

Under the hood, fastmath uses [JTransforms](https://github.com/wendykierp/JTransforms),
a high-performance Java library that automatically parallelizes large transforms.

For large arrays (typically >8-16K elements), JTransforms automatically **splits work across
available CPU cores** using Java's `ForkJoinPool`. It uses **SIMD optimizations** via Java's
auto-vectorization and can operate **in-place** directly on input arrays (fastmath wraps this
safely). It also **selects the optimal FFT algorithm** (split-radix, mixed-radix, or Bluestein)
based on array size.

You don't need to think about parallelism—just pass large arrays and JTransforms automatically
uses available CPU cores. For smaller signals, the overhead of parallelization exceeds the
benefit, so it runs single-threaded.

**Performance tip**: Reuse transformer objects! The constructor pre-computes lookup tables
(twiddle factors), so creating a transformer once and reusing it is much faster than
creating a new one for each transform.


### Understanding the DFT: Signal Decomposition

The [Discrete Fourier Transform (DFT)](https://en.wikipedia.org/wiki/Discrete_Fourier_transform)
answers the question: "What frequencies are in this signal, and how strong is each one?"

Mathematically, it expresses any signal as a weighted sum of sine and cosine waves:

**Signal = a₁·cos(2π·f₁·t) + b₁·sin(2π·f₁·t) + a₂·cos(2π·f₂·t) + b₂·sin(2π·f₂·t) + ...**

The DFT finds the weights (amplitudes) a₁, b₁, a₂, b₂, etc. We compute it using the
[Fast Fourier Transform (FFT)](https://en.wikipedia.org/wiki/Fast_Fourier_transform)
algorithm, which reduces complexity from O(n²) to O(n log n).

Let's see this in action by building a signal from known frequencies, then recovering them.


### Concrete Example: Build and Decompose

**Step 1: Manual construction** - we choose the frequencies and amplitudes


::: {.sourceClojure}
```clojure
(def freq-1 10.0)
```
:::



::: {.sourceClojure}
```clojure
(def amp-1 1.0)
```
:::



::: {.sourceClojure}
```clojure
(def freq-2 25.0)
```
:::



::: {.sourceClojure}
```clojure
(def amp-2 0.5)
```
:::


Generate time samples using dtype-next


::: {.sourceClojure}
```clojure
(def n-samples 1000)
```
:::



::: {.sourceClojure}
```clojure
(def time-points (dfn// (range n-samples) sample-rate))
```
:::


Build each frequency component


::: {.sourceClojure}
```clojure
(def component-1
  (dfn/* amp-1 (dfn/sin (dfn/* 2.0 Math/PI freq-1 time-points))))
```
:::



::: {.sourceClojure}
```clojure
(def component-2
  (dfn/* amp-2 (dfn/sin (dfn/* 2.0 Math/PI freq-2 time-points))))
```
:::


The signal is just the sum (linear superposition!)


::: {.sourceClojure}
```clojure
(def constructed-signal
  (dfn/+ component-1 component-2))
```
:::


**Step 2: FFT recovers the decomposition**


::: {.sourceClojure}
```clojure
(def fft-transformer (t/transformer :real :fft))
```
:::



::: {.sourceClojure}
```clojure
(def spectrum (t/forward-1d fft-transformer constructed-signal))
```
:::


**Step 3: Extract frequency peaks with dtype-next**


::: {.sourceClojure}
```clojure
(defn fft-magnitude
  "Compute magnitudes from FFT spectrum using dtype-next.
  
  FFT returns interleaved [r0, i0, r1, i1, ...] format.
  Magnitude = sqrt(real² + imag²)"
  [spectrum]
  (let [n-bins (quot (dtype/ecount spectrum) 2)]
    ;; Functional approach: map over bin indices
    (dtype/emap
     (fn [i]
       (let [real (dtype/get-value spectrum (* 2 i))
             imag (dtype/get-value spectrum (inc (* 2 i)))]
         (Math/sqrt (+ (* real real) (* imag imag)))))
     :float64
     (range n-bins))))
```
:::



::: {.sourceClojure}
```clojure
(def magnitudes (fft-magnitude spectrum))
```
:::



::: {.sourceClojure}
```clojure
(def freq-bins (dfn/* (range (dtype/ecount magnitudes)) (/ sample-rate n-samples)))
```
:::


Find peaks


::: {.sourceClojure}
```clojure
(def peak-1-idx (argops/argmax magnitudes))
```
:::



::: {.sourceClojure}
```clojure
(def peak-1-freq (dtype/get-value freq-bins peak-1-idx))
```
:::



::: {.sourceClojure}
```clojure
(def peak-1-mag (dtype/get-value magnitudes peak-1-idx))
```
:::


Remove first peak, find second (functional approach)


::: {.sourceClojure}
```clojure
(def mags-without-peak-1
  (dtype/emap (fn [i val] (if (= i peak-1-idx) 0.0 val))
              :float64
              (range (dtype/ecount magnitudes))
              magnitudes))
```
:::



::: {.sourceClojure}
```clojure
(def peak-2-idx (argops/argmax mags-without-peak-1))
```
:::



::: {.sourceClojure}
```clojure
(def peak-2-freq (dtype/get-value freq-bins peak-2-idx))
```
:::



::: {.sourceClojure}
```clojure
(def peak-2-mag (dtype/get-value mags-without-peak-1 peak-2-idx))
```
:::


**Verification**: FFT recovered our exact construction!


::: {.sourceClojure}
```clojure
{:constructed {:freq-1 freq-1 :amp-1 amp-1
               :freq-2 freq-2 :amp-2 amp-2}
 :recovered {:freq-1 peak-1-freq :magnitude-1 (/ peak-1-mag (/ n-samples 2))
             :freq-2 peak-2-freq :magnitude-2 (/ peak-2-mag (/ n-samples 2))}}
```
:::



::: {.printedClojure}
```clojure
{:constructed {:freq-1 10.0, :amp-1 1.0, :freq-2 25.0, :amp-2 0.5},
 :recovered
 {:freq-1 10.0,
  :magnitude-1 0.9999999999999997,
  :freq-2 25.0,
  :magnitude-2 0.49999999999999994}}

```
:::


**Key Insight**: This is linear decomposition in action!
We built: signal = 1.0×sin(2π·10·t) + 0.5×sin(2π·25·t)
FFT found: peaks at 10 Hz (mag ≈ 1.0) and 25 Hz (mag ≈ 0.5)

The FFT perfectly recovered the frequencies we put in. This is the power of the
Fourier Transform—it reveals the hidden frequency structure of any signal.


### Practical Function: Finding Dominant Frequency

Now let's package this into a reusable function. This is the kind of utility you'd use
in real applications: "What's the main frequency in this signal?"


::: {.sourceClojure}
```clojure
(defn find-dominant-frequency
  "Extract strongest frequency using FFT and dtype-next."
  [signal sample-rate]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        n (dtype/ecount signal)
        mags (fft-magnitude spectrum)

        ;; Skip DC component
        max-idx (inc (argops/argmax (dtype/sub-buffer mags 1 (dec (dtype/ecount mags)))))
        freq (* max-idx (/ sample-rate n))]

    {:frequency freq
     :magnitude (dtype/get-value mags max-idx)}))
```
:::



::: {.sourceClojure}
```clojure
(find-dominant-frequency (:signal (:pure-sine signals)) sample-rate)
```
:::



::: {.printedClojure}
```clojure
{:frequency 10.0, :magnitude 50.0}

```
:::



### FFT Visualization


::: {.sourceClojure}
```clojure
(defn visualize-fft
  "Show frequency spectrum."
  [signal sample-rate title]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        mags (fft-magnitude spectrum)
        n (dtype/ecount signal)
        freqs (dfn/* (range (dtype/ecount mags)) (/ sample-rate n))

        display-n (min 100 (dtype/ecount mags))
        dataset (tc/dataset {:frequency (dtype/sub-buffer freqs 0 display-n)
                             :magnitude (dtype/sub-buffer mags 0 display-n)})]

    (-> dataset
        (plotly/base {:=x :frequency
                      :=y :magnitude
                      :=x-title "Frequency (Hz)"
                      :=y-title "Magnitude"
                      :=title title
                      :=width 700
                      :=height 250})
        (plotly/layer-line))))
```
:::



::: {.sourceClojure}
```clojure
(visualize-fft (:signal (:two-tones signals)) sample-rate
               "FFT Spectrum: Clear Peaks at 10 Hz and 25 Hz")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[1.7176549129387863E-14,3.0716181557363255E-14,3.152396782149602E-14,2.023116571973581E-14,2.6479846395288645E-14,3.3778525229247234,3.6260518824895424E-14,2.8116884206511198E-14,3.422121707483879E-14,2.8166491172719573E-14,45.19420884293811,4.576493689143575E-14,2.1560127595614108E-14,1.5639296803361447E-14,3.357605163480098E-14,0.6836436799866012,4.867818915369436E-14,5.86626358025288E-14,3.41817782156943E-14,6.789633796828003E-14,1.8163563200133992,2.105718090561966E-14,4.833395490903625E-14,8.463852651031355E-14,5.623699543746444E-14,19.611582314123716,7.101401409880214E-14,9.366830231759066E-14,4.897707187396859E-14,1.4331485746840252E-14,1.8163563200134045,4.397972711507299E-14,2.8291441923904427E-14,4.9351249466694644E-14,2.295389239536349E-14,0.6836436799866226,4.3760151268691766E-14,4.744840964967002E-14,2.9559125751393757E-14,3.4950886248579004E-14,4.805791157061837,2.2256357139964007E-14,4.71121450550803E-14,4.8662138936876225E-14,2.1165629117605013E-14,3.3778525229247216,2.1862920326820087E-14,2.5919158050960164E-14,2.738672391142879E-15,1.6514952837327524E-14],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0],"text":null}], {"width":700,"height":250,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Magnitude","showgrid":true},"title":"FFT Spectrum: Clear Peaks at 10 Hz and 25 Hz"}, {});</script></div>
```



### Round-Trip Testing - Validation


::: {.sourceClojure}
```clojure
(defn test-fft-roundtrip
  "Verify FFT → IFFT recovers original signal.
  
  The 'tolerance' parameter sets how much error we accept due to
  floating-point rounding - typically very small (1e-10 or less).
  
  Returns test results with pass/fail boolean."
  [signal tolerance]
  (let [fft (t/transformer :real :fft)
        original (vec signal)
        spectrum (t/forward-1d fft signal)
        recovered (t/reverse-1d fft spectrum)

        ;; Use dtype-next for error calculation
        error (Math/sqrt (dfn/mean (dfn/sq (dfn/- signal recovered))))]

    {:rmse error
     :tolerance tolerance
     :passed? (< error tolerance)
     :interpretation (if (< error tolerance)
                       "✓ Perfect reconstruction"
                       "✗ Error exceeds tolerance")}))
```
:::


Test with our teaching signals


::: {.sourceClojure}
```clojure
(def fft-tests
  {:pure-sine (test-fft-roundtrip (:signal (:pure-sine signals)) 1e-10)
   :two-tones (test-fft-roundtrip (:signal (:two-tones signals)) 1e-10)
   :smooth (test-fft-roundtrip (:signal (:smooth signals)) 1e-10)})
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>signal</th><th>rmse</th><th>passed?</th><th>status</th></tr></thead><tbody><tr><td>pure-sine</td><td>1.69e-16</td><td>true</td><td>✓ PASS</td></tr><tr><td>two-tones</td><td>1.97e-16</td><td>true</td><td>✓ PASS</td></tr><tr><td>smooth</td><td>1.80e-16</td><td>true</td><td>✓ PASS</td></tr></tbody></table>
```

:::


**Result**: All signals pass - FFT perfectly recovers the original!

This round-trip property is crucial. It means we can:
1. Transform signal → frequency domain
2. Manipulate frequencies (filter, compress, analyze)
3. Transform back → time domain
4. Get our original signal back (within the limits of floating-point arithmetic)

Next, let's use this round-trip capability to build practical tools.


### Practical Application: Notch Filter


::: {.sourceClojure}
```clojure
(defn notch-filter
  "Remove specific frequency using FFT."
  [signal sample-rate target-freq bandwidth]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        n (dtype/ecount signal)

        ;; Functional approach: map over spectrum indices
        filtered (dtype/emap
                  (fn [idx val]
                    (let [freq (* (quot idx 2) (/ sample-rate n))]
                      (if (< (Math/abs (- freq target-freq)) bandwidth)
                        0.0
                        val)))
                  :float64
                  (range (dtype/ecount spectrum))
                  spectrum)]

    (t/reverse-1d fft filtered)))
```
:::



::: {.sourceClojure}
```clojure
(def signal-with-25hz (:signal (:two-tones signals)))
```
:::



::: {.sourceClojure}
```clojure
(def signal-25hz-removed (notch-filter signal-with-25hz sample-rate 25.0 2.0))
```
:::


Verify 25 Hz is gone, 10 Hz remains


::: {.sourceClojure}
```clojure
(find-dominant-frequency signal-25hz-removed sample-rate)
```
:::



::: {.printedClojure}
```clojure
{:frequency 10.0, :magnitude 45.1942088429381}

```
:::



### Time-Frequency Analysis: Spectrograms

**Limitation of FFT**: It tells us WHAT frequencies are present, but not WHEN.
For time-varying signals (like [chirps](https://en.wikipedia.org/wiki/Chirp)), we need to see how frequency content changes over time.

**Solution**: [Short-Time Fourier Transform](https://en.wikipedia.org/wiki/Short-time_Fourier_transform) (STFT) - apply FFT to overlapping windows.


::: {.sourceClojure}
```clojure
(defn spectrogram
  "Compute spectrogram using sliding-window FFT.

  Returns sequence of {:time t :frequency f :magnitude m} maps."
  [signal sample-rate window-size hop-size]
  (let [fft (t/transformer :real :fft)
        n-windows (quot (- (dtype/ecount signal) window-size) hop-size)]
    (for [win-idx (range n-windows)
          :let [start-idx (* win-idx hop-size)
                window (dtype/sub-buffer signal start-idx window-size)
                spectrum (t/forward-1d fft window)
                mags (fft-magnitude spectrum)
                time-center (/ (+ start-idx (/ window-size 2)) sample-rate)]
          freq-idx (range (min 50 (dtype/ecount mags)))]
      {:time time-center
       :frequency (* freq-idx (/ sample-rate window-size))
       :magnitude (dtype/get-value mags freq-idx)})))
```
:::


Visualize chirp signal (frequency increases over time)


::: {.sourceClojure}
```clojure
(def chirp-spectrogram
  (spectrogram (:signal (:chirp signals)) sample-rate 32 8))
```
:::



::: {.sourceClojure}
```clojure
(-> (tc/dataset chirp-spectrogram)
    (plotly/base {:=x :time
                  :=y :frequency
                  :=mark-color :magnitude
                  :=x-title "Time (s)"
                  :=y-title "Frequency (Hz)"
                  :=title "Spectrogram: Chirp Signal (5→50 Hz sweep)"
                  :=width 700
                  :=height 350})
    (plotly/layer-point {:=mark-symbol "square"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875,0.0,3.125,6.25,9.375,12.5,15.625,18.75,21.875,25.0,28.125,31.25,34.375,37.5,40.625,43.75,46.875],"r":null,"name":"","marker":{"color":"magnitude","symbol":"square"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.16,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.24,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.32,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.56,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72,0.72],"text":null}], {"width":700,"height":350,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Time (s)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"title":"Spectrogram: Chirp Signal (5\u219250 Hz sweep)"}, {});</script></div>
```


**Key Observation**: The spectrogram reveals the frequency sweep!
Brighter colors = higher magnitude. We can see frequency increasing linearly over time.

**Limitation of FFT**: It tells us WHAT frequencies exist, but loses information about WHEN
they occur. For signals with time-varying content, we need different tools—wavelets provide
this naturally, as we'll see later.

**What we just learned**: The FFT decomposes signals into frequency components, enabling
frequency analysis, filtering, and spectral visualization. Its invertibility makes it perfect
for round-trip transformations.

But the FFT has a weakness: it's not optimal for compression. Let's explore why the Discrete
Cosine Transform (DCT) outperforms FFT for smooth signals.


## DCT - The Compression Transform

The FFT is excellent for finding frequencies, but it's not the best choice for compression.
Here's why: the FFT uses both sines AND cosines (complex output), which means we're storing
twice as much information as we might need.

For smooth signals—like natural images, audio, or our "smooth" teaching signal—most energy
concentrates in low frequencies. The **Discrete Cosine Transform (DCT)** uses only cosines,
which for smooth signals concentrates energy even more efficiently than FFT.

This is why classic JPEG (baseline) compresses images with DCT, not FFT. Let's see why.


### Understanding DCT as Cosine Decomposition

**Core Concept**: The [Discrete Cosine Transform (DCT)](https://en.wikipedia.org/wiki/Discrete_cosine_transform)
expresses a signal as a weighted sum of cosine waves.

Signal = a₀ + a₁·cos(π·1·t) + a₂·cos(π·2·t) + ...

Unlike DFT (sines + cosines), DCT uses only cosines.
This makes it perfect for smooth signals → energy concentrates in first few coefficients.


### Why DCT for Compression?

Smooth signals have most energy in low frequencies.
DCT with cosine-only basis captures this more efficiently than DFT.
Result: [JPEG](https://en.wikipedia.org/wiki/JPEG) (baseline), [MP3](https://en.wikipedia.org/wiki/MP3)
(using Modified DCT), and many modern codecs use DCT or DCT variants!


### Energy Concentration Example


::: {.sourceClojure}
```clojure
(def dct-n-samples 64)
```
:::



::: {.sourceClojure}
```clojure
(def dct-time (dfn// (range dct-n-samples) dct-n-samples))
```
:::


Create smooth signal (mostly low frequency)


::: {.sourceClojure}
```clojure
(def smooth-signal
  (dfn/+ 10.0
         (dfn/* 5.0 (dfn/cos (dfn/* 2.0 Math/PI 2.0 dct-time)))
         (dfn/* 2.0 (dfn/cos (dfn/* 2.0 Math/PI 3.0 dct-time)))))
```
:::


Apply DCT


::: {.sourceClojure}
```clojure
(def dct (t/transformer :real :dct))
```
:::



::: {.sourceClojure}
```clojure
(def dct-coeffs (t/forward-1d dct smooth-signal))
```
:::


Measure energy concentration with dtype-next


::: {.sourceClojure}
```clojure
(def energy-by-coeff (dfn/sq dct-coeffs))
```
:::



::: {.sourceClojure}
```clojure
(def total-energy (dfn/sum energy-by-coeff))
```
:::



::: {.sourceClojure}
```clojure
(def energy-first-10 (dfn/sum (dtype/sub-buffer energy-by-coeff 0 10)))
```
:::



::: {.sourceClojure}
```clojure
{:total-coeffs dct-n-samples
 :energy-in-first-10 (format "%.1f%%" (* 100.0 (/ energy-first-10 total-energy)))
 :interpretation "Smooth signal → energy concentrated in few DCT coefficients!"}
```
:::



::: {.printedClojure}
```clojure
{:total-coeffs 64,
 :energy-in-first-10 "100.0%",
 :interpretation
 "Smooth signal → energy concentrated in few DCT coefficients!"}

```
:::



### DCT vs FFT Energy Concentration


::: {.sourceClojure}
```clojure
(defn measure-energy-concentration
  "Compare energy concentration across transforms."
  [signal transform-type keep-ratios]
  (let [transformer (t/transformer :real transform-type)
        coeffs (t/forward-1d transformer signal)
        total-energy (dfn/sum (dfn/sq coeffs))]

    (for [ratio keep-ratios]
      (let [keep-n (int (* ratio (dtype/ecount coeffs)))
            kept-energy (dfn/sum (dfn/sq (dtype/sub-buffer coeffs 0 keep-n)))]

        {:keep-ratio (* 100 ratio)
         :energy-retained (* 100 (/ kept-energy total-energy))
         :transform transform-type}))))
```
:::



::: {.sourceClojure}
```clojure
(def energy-comparison
  (concat
   (measure-energy-concentration (:signal (:smooth signals)) :fft [0.1 0.2 0.3 0.5])
   (measure-energy-concentration (:signal (:smooth signals)) :dct [0.1 0.2 0.3 0.5])))
```
:::



::: {.sourceClojure}
```clojure
(-> (tc/dataset energy-comparison)
    (plotly/base {:=x :keep-ratio
                  :=y :energy-retained
                  :=mark-color :transform
                  :=x-title "% Coefficients Kept"
                  :=y-title "% Energy Retained"
                  :=title "Energy Concentration: DCT vs FFT on Smooth Signal"
                  :=width 600
                  :=height 300})
    (plotly/layer-line)
    (plotly/layer-point))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[3.370527878784732E-29,91.7613082124696,98.82000060677937,99.88410749245004,58.1972554902848,93.9224275132055,98.62014061741736,99.80305755656337],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"transform"},"lon":null,"lat":null,"x":[10.0,20.0,30.0,50.0,10.0,20.0,30.0,50.0],"text":null},{"y":[3.370527878784732E-29,91.7613082124696,98.82000060677937,99.88410749245004,58.1972554902848,93.9224275132055,98.62014061741736,99.80305755656337],"r":null,"name":"","marker":{"color":"transform"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[10.0,20.0,30.0,50.0,10.0,20.0,30.0,50.0],"text":null}], {"width":600,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"% Coefficients Kept","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"% Energy Retained","showgrid":true},"title":"Energy Concentration: DCT vs FFT on Smooth Signal"}, {});</script></div>
```


**Observation**: DCT retains ~95% energy with 10% of coefficients!
FFT needs ~30% of coefficients for same energy.


### Lossy Compression with Quality Metrics


::: {.sourceClojure}
```clojure
(defn compress-with-dct
  "Compress signal by keeping only top N% of DCT coefficients."
  [signal keep-ratio]
  (let [dct (t/transformer :real :dct)
        coeffs (t/forward-1d dct signal)
        n (dtype/ecount coeffs)
        keep-n (int (* keep-ratio n))

        ;; Functional approach: zero out high-frequency coefficients
        compressed (dtype/emap
                    (fn [i val] (if (< i keep-n) val 0.0))
                    :float64
                    (range n)
                    coeffs)]

    (t/reverse-1d dct compressed)))
```
:::



::: {.sourceClojure}
```clojure
(def original-smooth (:signal (:smooth signals)))
```
:::



::: {.sourceClojure}
```clojure
(def compressed-50pct (compress-with-dct original-smooth 0.5))
```
:::



::: {.sourceClojure}
```clojure
(def compressed-25pct (compress-with-dct original-smooth 0.25))
```
:::



::: {.sourceClojure}
```clojure
(def compressed-10pct (compress-with-dct original-smooth 0.1))
```
:::


Calculate quality metrics with dtype-next


::: {.sourceClojure}
```clojure
(defn compression-quality [original compressed keep-ratio]
  (let [error (Math/sqrt (dfn/mean (dfn/sq (dfn/- original compressed))))
        signal-power (Math/sqrt (dfn/mean (dfn/sq original)))
        ;; Quality measure: ratio of signal power to error (higher = better quality)
        ;; Measured in [decibels](https://en.wikipedia.org/wiki/Decibel) (dB) - a logarithmic scale where 20 dB ≈ 10x better
        snr-db (* 20 (Math/log10 (/ signal-power error)))]

    {:compression-ratio (format "%.0f:1" (/ 1.0 keep-ratio))
     :quality-db (format "%.1f dB" snr-db)
     :keep-ratio (format "%.0f%%" (* 100 keep-ratio))}))
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>compression-ratio</th><th>quality-db</th><th>keep-ratio</th></tr></thead><tbody><tr><td>2:1</td><td>27.1 dB</td><td>50%</td></tr><tr><td>4:1</td><td>17.9 dB</td><td>25%</td></tr><tr><td>10:1</td><td>3.8 dB</td><td>10%</td></tr></tbody></table>
```

:::



### Test DCT Energy Concentration Property


::: {.sourceClojure}
```clojure
(defn test-dct-energy-concentration
  "Verify DCT concentrates energy better than FFT for smooth signals."
  [signal keep-ratio min-energy-threshold]
  (let [dct (t/transformer :real :dct)
        fft (t/transformer :real :fft)

        ;; DCT energy
        dct-coeffs (t/forward-1d dct signal)
        dct-total (dfn/sum (dfn/sq dct-coeffs))
        dct-keep-n (int (* keep-ratio (dtype/ecount dct-coeffs)))
        dct-kept (dfn/sum (dfn/sq (dtype/sub-buffer dct-coeffs 0 dct-keep-n)))
        dct-ratio (/ dct-kept dct-total)

        ;; FFT energy
        fft-spec (t/forward-1d fft signal)
        fft-mags (fft-magnitude fft-spec)
        fft-total (dfn/sum (dfn/sq fft-mags))
        fft-keep-n (int (* keep-ratio (dtype/ecount fft-mags)))
        fft-kept (dfn/sum (dfn/sq (dtype/sub-buffer fft-mags 0 fft-keep-n)))
        fft-ratio (/ fft-kept fft-total)]

    {:dct-energy-retained dct-ratio
     :fft-energy-retained fft-ratio
     :dct-advantage (format "%.1fx better" (/ dct-ratio fft-ratio))
     :passed? (and (> dct-ratio fft-ratio)
                   (> dct-ratio min-energy-threshold))}))
```
:::


Test that DCT concentrates energy better than FFT
For smooth signals, keeping 10% of DCT coefficients should retain significantly more energy than FFT


::: {.sourceClojure}
```clojure
(test-dct-energy-concentration original-smooth 0.1 0.5)
```
:::



::: {.printedClojure}
```clojure
{:dct-energy-retained 0.581972554902848,
 :fft-energy-retained 3.370527878784732E-31,
 :dct-advantage "1726651064262024200000000000000.0x better",
 :passed? true}

```
:::


**What we just learned**: The DCT uses only cosines (instead of FFT's sines + cosines),
which concentrates energy more efficiently for smooth signals. This makes it ideal for
compression—classic JPEG and MP3 (via Modified DCT) both exploit this property.

But both FFT and DCT have a fundamental limitation: they use **global basis functions**
that span the entire signal. A sine wave at 10 Hz in the FFT basis oscillates across the
whole signal—it can't tell us that a frequency appears only briefly. Let's explore wavelets,
which solve this problem.


## Wavelets - Time-Frequency Localization

Remember our chirp signal—frequency increasing from 5 to 50 Hz over time? The FFT told us
"this signal contains frequencies between 5 and 50 Hz," but it couldn't tell us WHEN each
frequency occurred. The spectrogram helped by windowing, but that was a workaround.

**Wavelets** provide time-frequency localization naturally by using basis functions that are
inherently localized in time. Instead of global sine waves, wavelets use small, localized
"wavelets" (hence the name!) that can detect features at specific times AND specific frequencies.


### Understanding Wavelets as Localized Decomposition

**Core Concept**: [Wavelets](https://en.wikipedia.org/wiki/Wavelet) decompose a signal using 
scaled and shifted basis functions.

Signal = a₁·ψ(t-1) + a₂·ψ(2t-1) + a₃·ψ(2t-2) + ...

**⚠️ Important**: Most wavelet transforms (Haar, Daubechies, Symlets) require **power-of-2
array sizes** (64, 128, 256, 512, etc.). This is because wavelets work by recursively
splitting signals in half. If your signal isn't a power of 2, you'll need to pad it.

We'll show the padding pattern in our examples below.

^kind/md
"**Padding to power-of-2 size**:

```clojure
;; Pad to next power of 2
(let [n (dtype/ecount signal)
      target-n (int (Math/pow 2 (Math/ceil (/ (Math/log n) (Math/log 2)))))]
  ;; ... pad signal to target-n ...)
```"

Where ψ is a localized wavelet function at different scales and positions.

See also: [Wavelet Transform](https://en.wikipedia.org/wiki/Wavelet_transform)


### The Key Difference: Global vs Local

**DFT/DCT**: Basis functions span entire signal

- Answer: "What frequencies are present?"
- Cannot tell WHERE events occur

**Wavelets**: Localized basis at multiple scales

- Answer: "What frequencies, and WHEN?"
- Perfect for time-varying signals


### Visualizing Wavelet Basis Functions

To understand the difference, let's visualize the actual basis functions.

Haar wavelet basis function (simplest wavelet)


::: {.sourceClojure}
```clojure
(defn haar-wavelet
  "Generate Haar wavelet at given position and scale."
  [t position scale]
  (let [t-scaled (/ (- t position) scale)]
    (cond
      (and (>= t-scaled 0) (< t-scaled 0.5)) 1.0
      (and (>= t-scaled 0.5) (< t-scaled 1.0)) -1.0
      :else 0.0)))
```
:::


Generate basis functions for comparison


::: {.sourceClojure}
```clojure
(def basis-comparison-data
  (let [n 200
        t-vals (dfn// (range n) n)]
    (concat
     ;; Sine basis (global)
     (map (fn [t] {:time t :amplitude (Math/sin (* 2 Math/PI 5 t)) :type "Sine (global)"})
          t-vals)
     ;; Cosine basis (global)
     (map (fn [t] {:time t :amplitude (Math/cos (* 2 Math/PI 5 t)) :type "Cosine (global)"})
          t-vals)
     ;; Haar wavelet at scale 0.1 (fine detail)
     (map (fn [t] {:time t :amplitude (haar-wavelet t 0.3 0.1) :type "Haar scale=0.1 (fine)"})
          t-vals)
     ;; Haar wavelet at scale 0.2 (coarse detail)
     (map (fn [t] {:time t :amplitude (haar-wavelet t 0.6 0.2) :type "Haar scale=0.2 (coarse)"})
          t-vals))))
```
:::



::: {.sourceClojure}
```clojure
(-> (tc/dataset basis-comparison-data)
    (plotly/base {:=x :time
                  :=y :amplitude
                  :=mark-color :type
                  :=x-title "Time"
                  :=y-title "Amplitude"
                  :=title "Basis Functions: Global (Sine/Cosine) vs Local (Haar Wavelets)"
                  :=width 700
                  :=height 350})
    (plotly/layer-line))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"type"},"lon":null,"lat":null,"x":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"text":null}], {"width":700,"height":350,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Time","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Amplitude","showgrid":true},"title":"Basis Functions: Global (Sine\/Cosine) vs Local (Haar Wavelets)"}, {});</script></div>
```


**Key Observation**: Sine and cosine extend across the entire time axis (global).
Haar wavelets are localized to specific time windows and can be scaled to
capture both fine details (small scale) and coarse features (large scale).


### Example: Localized Event Detection

Localized event signal: quiet, brief pulse, quiet


::: {.sourceClojure}
```clojure
(def event-signal
  (double-array
   (concat (repeat 25 0.0)
           (repeat 5 5.0)
           (repeat 20 0.0)
           (repeat 14 0.0))))
```
:::


FFT spreads event across all frequencies (global view)


::: {.sourceClojure}
```clojure
(def event-fft (t/forward-1d (t/transformer :real :fft) event-signal))
```
:::


Wavelet localizes event in time AND frequency


::: {.sourceClojure}
```clojure
(def haar (t/transformer :fast :haar))
```
:::



::: {.sourceClojure}
```clojure
(def event-wavelet (t/forward-1d haar event-signal))
```
:::


Compare: where is the energy?


::: {.sourceClojure}
```clojure
{:fft-view "Energy distributed across all frequencies - WHERE is unclear"
 :wavelet-view "Energy concentrated at specific time-scale location"
 :key-insight "Wavelets = localized basis functions at multiple scales"}
```
:::



::: {.printedClojure}
```clojure
{:fft-view
 "Energy distributed across all frequencies - WHERE is unclear",
 :wavelet-view "Energy concentrated at specific time-scale location",
 :key-insight "Wavelets = localized basis functions at multiple scales"}

```
:::



### Wavelet Families

Fastmath supports many wavelet families via [JWave](https://github.com/cscheiblich/JWave):

- [Haar](https://en.wikipedia.org/wiki/Haar_wavelet): `:haar`
- [Daubechies](https://en.wikipedia.org/wiki/Daubechies_wavelet): `:daubechies-4`, `:daubechies-8`
- [Symlets](https://en.wikipedia.org/wiki/Symlet): `:symlet-4`
- [Coiflets](https://en.wikipedia.org/wiki/Coiflet): `:coiflet-2`


::: {.sourceClojure}
```clojure
(defn compare-wavelets [signal]
  (let [;; Ensure signal is power of 2
        n (dtype/ecount signal)
        target-n (int (Math/pow 2 (Math/ceil (/ (Math/log n) (Math/log 2)))))

        ;; Functional padding: use original values or 0
        padded (dtype/emap
                (fn [i] (if (< i n)
                          (dtype/get-value signal i)
                          0.0))
                :float64
                (range target-n))

        wavelets {:haar :haar
                  :daubechies-4 :daubechies-4
                  :daubechies-8 :daubechies-8
                  :symlet-4 :symlet-4}]

    (for [[name wavelet-key] wavelets]
      (let [trans (t/transformer :fast wavelet-key)
            coeffs (t/forward-1d trans padded)
            ;; Sparsity = how many small coefficients
            sparsity (count (filter #(< (Math/abs %) 0.01) coeffs))]

        {:wavelet (clojure.core/name name)
         :sparsity-pct (format "%.0f%%" (* 100.0 (/ sparsity (alength coeffs))))
         :max-coeff (format "%.2f" (dfn/reduce-max (dfn/abs coeffs)))}))))
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>wavelet</th><th>sparsity-pct</th><th>max-coeff</th></tr></thead><tbody><tr><td>haar</td><td>23%</td><td>1.51</td></tr><tr><td>daubechies-4</td><td>17%</td><td>1.73</td></tr><tr><td>daubechies-8</td><td>19%</td><td>2.39</td></tr><tr><td>symlet-4</td><td>16%</td><td>1.89</td></tr></tbody></table>
```

:::


**Observation**: Different wavelets give different sparsity.
Smoother wavelets (Daubechies, Symlet) → more zeros → better compression!


### Wavelet Denoising


::: {.sourceClojure}
```clojure
(defn add-noise [signal noise-level]
  ;; Functional approach: generate noise and add to signal
  (let [n (dtype/ecount signal)
        noise (dtype/emap (fn [_] (* noise-level (- (rand) 0.5)))
                          :float64
                          (range n))]
    (dfn/+ signal noise)))
```
:::



::: {.sourceClojure}
```clojure
(def clean-sig (sig/oscillator->signal (sig/oscillator :sin 5.0 1.0 0.0) 128.0 1.0))
```
:::



::: {.sourceClojure}
```clojure
(def noisy-sig (add-noise clean-sig 0.3))
```
:::


Wavelet denoising: transform → threshold → inverse

**Important**: Denoising requires careful threshold tuning. The default threshold
may be too aggressive (removing signal) or too weak (leaving noise). In practice,
you'd analyze the wavelet coefficients and choose a threshold based on the noise
characteristics. This is an active area of research with methods like:

- Universal threshold: σ√(2 log N)
- SURE threshold (Stein's Unbiased Risk Estimate)
- Empirical Bayes methods


::: {.sourceClojure}
```clojure
(def db8 (t/transformer :fast :daubechies-8))
```
:::



::: {.sourceClojure}
```clojure
(def noisy-coeffs (t/forward-1d db8 noisy-sig))
```
:::



::: {.sourceClojure}
```clojure
(def denoised-coeffs (t/denoise db8 noisy-coeffs :soft))
```
:::



::: {.sourceClojure}
```clojure
(def denoised-sig (t/reverse-1d db8 denoised-coeffs))
```
:::


Quality comparison with dtype-next


::: {.sourceClojure}
```clojure
(defn signal-quality [clean noisy denoised]
  {:noisy-rmse (format "%.4f" (Math/sqrt (dfn/mean (dfn/sq (dfn/- clean noisy)))))
   :denoised-rmse (format "%.4f" (Math/sqrt (dfn/mean (dfn/sq (dfn/- clean denoised)))))
   :note "Denoising effectiveness depends on threshold tuning"})
```
:::



::: {.sourceClojure}
```clojure
(signal-quality clean-sig noisy-sig denoised-sig)
```
:::



::: {.printedClojure}
```clojure
{:noisy-rmse "0.0877",
 :denoised-rmse "0.4079",
 :note "Denoising effectiveness depends on threshold tuning"}

```
:::



### Round-Trip Testing for Wavelets


::: {.sourceClojure}
```clojure
(defn test-wavelet-roundtrip
  "Verify wavelet transform is invertible."
  [signal wavelet-type tolerance]
  (let [wavelet (t/transformer :fast wavelet-type)
        coeffs (t/forward-1d wavelet signal)
        recovered (t/reverse-1d wavelet coeffs)
        error (Math/sqrt (dfn/mean (dfn/sq (dfn/- signal recovered))))]

    {:wavelet wavelet-type
     :rmse error
     :passed? (< error tolerance)}))
```
:::



::: {.sourceClojure}
```clojure
(def wavelet-tests
  [(test-wavelet-roundtrip (take 64 (:signal (:smooth signals))) :haar 1e-10)
   (test-wavelet-roundtrip (take 64 (:signal (:smooth signals))) :daubechies-8 1e-10)
   (test-wavelet-roundtrip (take 64 (:signal (:smooth signals))) :symlet-4 1e-10)])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>wavelet</th><th>rmse</th><th>passed?</th></tr></thead><tbody><tr><td>haar</td><td>4.911240235747681E-16</td><td>true</td></tr><tr><td>daubechies-8</td><td>7.675184834973428E-12</td><td>true</td></tr><tr><td>symlet-4</td><td>9.536902080421727E-13</td><td>true</td></tr></tbody></table>
```

:::



## Other Transforms - DST and DHT


### Discrete Sine Transform (DST)

**Use case**: Solving [PDEs](https://en.wikipedia.org/wiki/Partial_differential_equation) with 
[Dirichlet boundary conditions](https://en.wikipedia.org/wiki/Dirichlet_boundary_condition) 
(signal = 0 at endpoints)

The [Discrete Sine Transform (DST)](https://en.wikipedia.org/wiki/Discrete_sine_transform) 
is like DCT but uses sine basis instead of cosine.
Implicitly assumes signal goes to zero at boundaries.


::: {.sourceClojure}
```clojure
(def dst (t/transformer :real :dst))
```
:::


Signal that naturally goes to zero at edges
Signal naturally zero at boundaries (t=0 and t=1)


::: {.sourceClojure}
```clojure
(def boundary-signal
  (let [n 64
        t (dfn// (range n) n)]
    (dfn/* (dfn/sin (dfn/* Math/PI t))
           (dfn/sin (dfn/* 5.0 Math/PI t)))))
```
:::



::: {.sourceClojure}
```clojure
(def dst-coeffs (t/forward-1d dst boundary-signal))
```
:::



::: {.sourceClojure}
```clojure
(def dst-reconstructed (t/reverse-1d dst dst-coeffs))
```
:::


Verify round-trip


::: {.sourceClojure}
```clojure
{:rmse (format "%.2e" (Math/sqrt (dfn/mean (dfn/sq (dfn/- boundary-signal dst-reconstructed)))))
 :passed? (< (Math/sqrt (dfn/mean (dfn/sq (dfn/- boundary-signal dst-reconstructed)))) 1e-10)}
```
:::



::: {.printedClojure}
```clojure
{:rmse "0.00e+00", :passed? true}

```
:::



### Discrete Hartley Transform (DHT)

**Use case**: Real-valued alternative to DFT for [convolution](https://en.wikipedia.org/wiki/Convolution)

The [Discrete Hartley Transform (DHT)](https://en.wikipedia.org/wiki/Discrete_Hartley_transform)
is similar to the DFT but output is real-valued (no complex numbers).
Useful for applications where you only care about real operations.


::: {.sourceClojure}
```clojure
(def dht (t/transformer :real :dht))
```
:::



::: {.sourceClojure}
```clojure
(def test-sig (take 64 (:signal (:pure-sine signals))))
```
:::



::: {.sourceClojure}
```clojure
(def dht-result (t/forward-1d dht test-sig))
```
:::


All real values (unlike FFT which has complex output)


::: {.sourceClojure}
```clojure
{:all-real? (every? #(not (Double/isNaN %)) dht-result)
 :invertible? (< (Math/sqrt (dfn/mean (dfn/sq (dfn/- test-sig (t/reverse-1d dht dht-result))))) 1e-10)}
```
:::



::: {.printedClojure}
```clojure
{:all-real? true, :invertible? true}

```
:::



### Transform Selection Guide

::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>transform</th><th>use-case</th><th>basis</th><th>output</th><th>algorithm</th></tr></thead><tbody><tr><td>DFT</td><td>Frequency analysis</td><td>Sine + Cosine</td><td>Complex</td><td>FFT</td></tr><tr><td>DCT</td><td>Compression (JPEG/MP3)</td><td>Cosine only</td><td>Real</td><td>Fast DCT</td></tr><tr><td>DST</td><td>PDEs, boundary problems</td><td>Sine only</td><td>Real</td><td>Fast DST</td></tr><tr><td>DHT</td><td>Real-valued convolution</td><td>Hartley</td><td>Real</td><td>Fast DHT</td></tr><tr><td>Wavelet</td><td>Time-frequency, denoising</td><td>Localized</td><td>Real</td><td>Fast Wavelet</td></tr></tbody></table>
```

:::



## 2D Transforms for Images


### Creating a 2D Signal


::: {.sourceClojure}
```clojure
(defn generate-2d-signal [rows cols]
  (let [data (make-array Double/TYPE rows cols)]
    (dotimes [i rows]
      (dotimes [j cols]
        ;; Create pattern: horizontal 3Hz + vertical 5Hz
        (aset data i j
              (+ (Math/sin (* 2 Math/PI 3.0 (/ j cols)))
                 (Math/sin (* 2 Math/PI 5.0 (/ i rows)))))))
    data))
```
:::



::: {.sourceClojure}
```clojure
(def signal-2d (generate-2d-signal 32 32))
```
:::


Visualize 2D signal


::: {.sourceClojure}
```clojure
(-> (tc/dataset (for [i (range 32) j (range 32)]
                  {:row i :col j :value (aget signal-2d i j)}))
    (plotly/base {:=x :col
                  :=y :row
                  :=mark-color :value
                  :=title "2D Signal: Horizontal 3Hz + Vertical 5Hz"
                  :=width 400
                  :=height 400})
    (plotly/layer-point {:=mark-symbol "square"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31],"r":null,"name":"","marker":{"color":"value","symbol":"square"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],"text":null}], {"width":400,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"col","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"row","showgrid":true},"title":"2D Signal: Horizontal 3Hz + Vertical 5Hz"}, {});</script></div>
```



### 2D FFT


::: {.sourceClojure}
```clojure
(def fft-2d (t/transformer :real :fft))
```
:::



::: {.sourceClojure}
```clojure
(def spectrum-2d (t/forward-2d fft-2d signal-2d))
```
:::


Compute 2D magnitude


::: {.sourceClojure}
```clojure
(defn magnitude-2d [spectrum]
  (let [rows (alength spectrum)
        cols (alength (aget spectrum 0))
        result (make-array Double/TYPE rows cols)]
    (dotimes [i rows]
      (dotimes [j cols]
        (aset result i j (Math/abs (aget spectrum i j)))))
    result))
```
:::



::: {.sourceClojure}
```clojure
(def mag-2d (magnitude-2d spectrum-2d))
```
:::


Visualize 2D spectrum (log scale for visibility)


::: {.sourceClojure}
```clojure
(-> (tc/dataset (for [i (range 32) j (range 32)]
                  {:row i :col j :value (Math/log (+ 1 (aget mag-2d i j)))}))
    (plotly/base {:=x :col
                  :=y :row
                  :=mark-color :value
                  :=x-title "Frequency X"
                  :=y-title "Frequency Y"
                  :=title "2D FFT Spectrum - Bright Spots Show Frequency Components"
                  :=width 400
                  :=height 400})
    (plotly/layer-point {:=mark-symbol "square"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31],"r":null,"name":"","marker":{"color":"value","symbol":"square"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],"text":null}], {"width":400,"height":400,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency X","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency Y","showgrid":true},"title":"2D FFT Spectrum - Bright Spots Show Frequency Components"}, {});</script></div>
```


**Interpretation**: Just like 1D FFT, 2D FFT decomposes image into
frequency components. The bright spots in the spectrum correspond to our
horizontal 3Hz and vertical 5Hz patterns!


### 2D DCT Basis Functions

Understanding how baseline JPEG compression works: visualizing the 8×8 DCT basis images.
Each 8×8 block in baseline JPEG is decomposed into a weighted sum of these 64 basis patterns.

2D DCT-II basis function


::: {.sourceClojure}
```clojure
(defn dct-2d-basis
  "Generate a single 2D DCT basis function for frequency (u, v)."
  [size u v]
  (let [data (make-array Double/TYPE size size)
        pi Math/PI
        cu (if (zero? u) (/ 1.0 (Math/sqrt 2.0)) 1.0)
        cv (if (zero? v) (/ 1.0 (Math/sqrt 2.0)) 1.0)]
    (dotimes [i size]
      (dotimes [j size]
        (aset data i j
              (* cu cv
                 (Math/cos (* (/ pi size) u (+ i 0.5)))
                 (Math/cos (* (/ pi size) v (+ j 0.5)))))))
    data))
```
:::


Generate a grid of low-frequency DCT basis images (like JPEG uses)


::: {.sourceClojure}
```clojure
(def dct-basis-grid
  (let [size 8
        grid-size 4]
    (for [u (range grid-size)
          v (range grid-size)
          i (range size)
          j (range size)]
      {:freq-u u
       :freq-v v
       :row i
       :col j
       :value (aget (dct-2d-basis size u v) i j)})))
```
:::


Visualize the first 16 DCT basis functions (0-3 in each direction)


::: {.sourceClojure}
```clojure
(-> (tc/dataset dct-basis-grid)
    (plotly/base {:=x :col
                  :=y :row
                  :=mark-color :value
                  :=facet-x :freq-u
                  :=facet-y :freq-v
                  :=title "2D DCT Basis Functions (Baseline JPEG uses these!)"
                  :=width 600
                  :=height 600})
    (plotly/layer-point {:=mark-symbol "square"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7],"r":null,"name":"","marker":{"color":"value","symbol":"square"},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7],"text":null}], {"width":600,"height":600,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"col","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"row","showgrid":true},"title":"2D DCT Basis Functions (Baseline JPEG uses these!)"}, {});</script></div>
```


**Key Insight**:

- Top-left (0,0) = DC component (constant, average brightness)
- Moving right → increasing horizontal frequency
- Moving down → increasing vertical frequency
- Baseline JPEG keeps low-frequency basis (top-left) and discards high-frequency (bottom-right)
- This is why JPEG compression works well for natural images (most energy in low frequencies)


## Practical Applications

Now that we understand the theory behind FFT, DCT, and wavelets, let's see how to apply
these transforms to solve real-world problems. We'll build practical tools for filtering,
compression, and spectral analysis.


### Application 1: Bandpass Filtering


::: {.sourceClojure}
```clojure
(defn bandpass-filter
  "Keep only frequencies in [low-freq, high-freq] range."
  [signal low-freq high-freq sample-rate]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        n (dtype/ecount signal)
        low-bin (int (* n (/ low-freq sample-rate)))
        high-bin (int (* n (/ high-freq sample-rate)))

        ;; Functional approach: keep frequencies in range, zero others
        filtered (dtype/emap
                  (fn [idx val]
                    (let [bin (quot idx 2)]
                      (if (and (>= bin low-bin) (<= bin high-bin))
                        val
                        0.0)))
                  :float64
                  (range (dtype/ecount spectrum))
                  spectrum)]

    (t/reverse-1d fft filtered)))
```
:::


Test: remove high frequency noise
Mixed signal: 8 Hz (signal) + 25 Hz (noise) + random noise


::: {.sourceClojure}
```clojure
(def mixed-signal
  (add-noise
   (sig/oscillator->signal
    (sig/oscillators-sum
     (sig/oscillator :sin 8.0 1.0 0.0)
     (sig/oscillator :sin 25.0 0.3 0.0))
    100.0 1.0)
   0.1))
```
:::



::: {.sourceClojure}
```clojure
(def filtered-signal (bandpass-filter mixed-signal 5.0 15.0 100.0))
```
:::



::: {.sourceClojure}
```clojure
{:original-dominant (find-dominant-frequency mixed-signal 100.0)
 :filtered-dominant (find-dominant-frequency filtered-signal 100.0)
 :interpretation "High frequency (25 Hz) successfully removed!"}
```
:::



::: {.printedClojure}
```clojure
{:original-dominant {:frequency 8.0, :magnitude 47.70621707998047},
 :filtered-dominant {:frequency 8.0, :magnitude 47.54533850136635},
 :interpretation "High frequency (25 Hz) successfully removed!"}

```
:::



### Application 2: Spectral Analysis


::: {.sourceClojure}
```clojure
(defn analyze-spectrum
  "Find all significant frequency components."
  [signal sample-rate threshold-ratio]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        mags (fft-magnitude spectrum)
        n (dtype/ecount signal)
        max-mag (dfn/reduce-max mags)
        threshold (* threshold-ratio max-mag)

        ;; Find all peaks above threshold
        peaks (filter #(> (dtype/get-value mags %) threshold) (range (dtype/ecount mags)))]

    {:frequencies (mapv #(* % (/ sample-rate n)) peaks)
     :magnitudes (mapv #(dtype/get-value mags %) peaks)
     :num-components (count peaks)}))
```
:::



::: {.sourceClojure}
```clojure
(analyze-spectrum (:signal (:two-tones signals)) sample-rate 0.1)
```
:::



::: {.printedClojure}
```clojure
{:frequencies [10.0 25.0 40.0],
 :magnitudes [45.19420884293811 19.611582314123716 4.805791157061837],
 :num-components 3}

```
:::



### Application 3: Compression Pipeline


::: {.sourceClojure}
```clojure
(defn compression-pipeline
  "Complete compression: signal → DCT → quantize → compress."
  [signal keep-ratio]
  (let [dct (t/transformer :real :dct)
        ;; Step 1: Transform to frequency domain
        coeffs (t/forward-1d dct signal)

        ;; Step 2: Sort by magnitude, keep largest
        indexed-coeffs (map-indexed vector coeffs)
        sorted-coeffs (sort-by #(- (Math/abs (second %))) indexed-coeffs)
        keep-n (int (* keep-ratio (count sorted-coeffs)))
        kept-indices (set (map first (take keep-n sorted-coeffs)))

        ;; Step 3: Functional approach - zero out small coefficients
        compressed (dtype/emap
                    (fn [idx val]
                      (if (kept-indices idx) val 0.0))
                    :float64
                    (range (dtype/ecount coeffs))
                    coeffs)]

    ;; Step 4: Inverse transform
    (t/reverse-1d dct compressed)))
```
:::


Compare compression strategies: sequential vs magnitude-based


::: {.sourceClojure}
```clojure
(def original (:signal (:smooth signals)))
```
:::



::: {.sourceClojure}
```clojure
(def compressed-sequential (compress-with-dct original 0.25))
```
:::



::: {.sourceClojure}
```clojure
(def compressed-magnitude (compression-pipeline original 0.25))
```
:::



::: {.sourceClojure}
```clojure
{:sequential-rmse (format "%.4f" (Math/sqrt (dfn/mean (dfn/sq (dfn/- original compressed-sequential)))))
 :magnitude-rmse (format "%.4f" (Math/sqrt (dfn/mean (dfn/sq (dfn/- original compressed-magnitude)))))
 :note "Keeping largest coefficients works better than keeping first N!"}
```
:::



::: {.printedClojure}
```clojure
{:sequential-rmse "0.0910",
 :magnitude-rmse "0.0297",
 :note
 "Keeping largest coefficients works better than keeping first N!"}

```
:::



## Testing and Validation Framework

Transform operations can seem like black boxes. How do we know they're working correctly?
This section builds a comprehensive testing framework to validate transform properties:
invertibility (can we get the original back?), stability across different signal sizes,
and mathematical correctness.


### Utility Functions


::: {.sourceClojure}
```clojure
(defn compute-rmse
  "Root mean square error using dtype-next."
  [signal1 signal2]
  (Math/sqrt (dfn/mean (dfn/sq (dfn/- signal1 signal2)))))
```
:::



::: {.sourceClojure}
```clojure
(defn generate-random-signal
  "Random signal with seeded RNG for reproducibility."
  [n seed]
  (let [rng (java.util.Random. seed)]
    (double-array (repeatedly n #(- (* 2.0 (.nextDouble rng)) 1.0)))))
```
:::



### Generic Round-Trip Test


::: {.sourceClojure}
```clojure
(defn test-transform-roundtrip
  "Generic test for any transform's invertibility."
  [signal transformer tolerance]
  (let [forward (t/forward-1d transformer signal)
        inverse (t/reverse-1d transformer forward)
        error (compute-rmse signal inverse)]

    {:signal-size (dtype/ecount signal)
     :rmse error
     :tolerance tolerance
     :passed? (< error tolerance)}))
```
:::



### Test Multiple Signal Types


::: {.sourceClojure}
```clojure
(defn test-all-signal-types
  "Test transform on various signal types."
  [transformer tolerance]
  (let [test-signals
        {:pure-sine (sig/oscillator->signal (sig/oscillator :sin 440.0 1.0 0.0) 1000.0 0.1)
         :composite (sig/oscillator->signal
                     (sig/oscillators-sum
                      (sig/oscillator :sin 220.0 1.0 0.0)
                      (sig/oscillator :sin 440.0 0.5 0.0))
                     1000.0 0.1)
         :square (sig/oscillator->signal (sig/oscillator :square 100.0 1.0 0.0) 1000.0 0.1)
         :noise (generate-random-signal 100 42)
         :chirp (:signal (:chirp signals))}]

    (into {}
          (for [[sig-type signal] test-signals]
            [sig-type (test-transform-roundtrip signal transformer tolerance)]))))
```
:::


Run comprehensive FFT tests


::: {.sourceClojure}
```clojure
(def fft-comprehensive (test-all-signal-types (t/transformer :real :fft) 1e-10))
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>signal</th><th>rmse</th><th>passed?</th><th>status</th></tr></thead><tbody><tr><td>pure-sine</td><td>2.20e-16</td><td>true</td><td>✓</td></tr><tr><td>composite</td><td>1.96e-16</td><td>true</td><td>✓</td></tr><tr><td>square</td><td>1.71e-16</td><td>true</td><td>✓</td></tr><tr><td>noise</td><td>1.17e-16</td><td>true</td><td>✓</td></tr><tr><td>chirp</td><td>1.93e-16</td><td>true</td><td>✓</td></tr></tbody></table>
```

:::



### Numerical Stability Test


::: {.sourceClojure}
```clojure
(defn test-numerical-stability
  "Test across wide range of amplitudes - verifies transform works equally
  well on tiny signals (1e-6) and huge signals (1e6)."
  [base-signal transformer scale-factors]
  (for [scale scale-factors]
    (let [scaled-signal (dfn/* scale base-signal)
          ;; Use relative tolerance - bigger signals need bigger error allowance
          tolerance (* 1e-10 scale)
          result (test-transform-roundtrip scaled-signal transformer tolerance)]
      (assoc result :scale-factor scale))))
```
:::



::: {.sourceClojure}
```clojure
(def stability-results
  (test-numerical-stability
   (take 100 (:signal (:pure-sine signals)))
   (t/transformer :real :fft)
   [1e-6 1e-3 1.0 1e3 1e6]))
```
:::


All should pass


::: {.sourceClojure}
```clojure
(every? :passed? stability-results)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Comprehensive Test Suite


::: {.sourceClojure}
```clojure
(defn comprehensive-test-suite
  "Run all tests and return boolean: true if all pass."
  []
  (let [fft (t/transformer :real :fft)
        dct (t/transformer :real :dct)
        haar (t/transformer :fast :haar)

        test-signal (take 64 (:signal (:smooth signals)))

        results
        {:fft-roundtrip (every? :passed? (vals (test-all-signal-types fft 1e-10)))
         :dct-roundtrip (every? :passed? (vals (test-all-signal-types dct 1e-10)))
         :wavelet-roundtrip (:passed? (test-wavelet-roundtrip test-signal :haar 1e-10))
         :numerical-stability (every? :passed? stability-results)
         :dct-energy-concentration (:passed? (test-dct-energy-concentration original-smooth 0.1 0.5))}]

    {:individual-results results
     :all-passed? (every? identity (vals results))}))
```
:::



::: {.sourceClojure}
```clojure
(def final-test-results (comprehensive-test-suite))
```
:::



::: {.sourceClojure}
```clojure
(:all-passed? final-test-results)
```
:::



::: {.printedClojure}
```clojure
true

```
:::



## Best Practices and Decision Guide


### dtype-next Best Practices Summary

**Key Functions Actually Used**:

::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>category</th><th>functions</th></tr></thead><tbody><tr><td>Element-wise</td><td>dfn/+, dfn/-, dfn/*, dfn//, dfn/sq, dfn/sqrt, dfn/cos, dfn/sin, dfn/abs</td></tr><tr><td>Reductions</td><td>dfn/sum, dfn/mean, dfn/standard-deviation, dfn/reduce-max, dfn/reduce-min</td></tr><tr><td>Functional</td><td>dtype/emap - map function over arrays</td></tr><tr><td>Array access</td><td>dtype/ecount, dtype/get-value, dtype/sub-buffer</td></tr><tr><td>Search</td><td>argops/argmax - find index of maximum</td></tr></tbody></table>
```

:::



### Common dtype-next Patterns - Quick Reference

Throughout the tutorial, you've seen these dtype-next patterns repeatedly. Here's a
quick reference with working examples you can use in your own code.

**Measuring signal difference** - compute how far apart two signals are:


::: {.sourceClojure}
```clojure
(defn compute-error [signal1 signal2]
  ;; This computes the "root mean square error" - square the differences,
  ;; average them, then take the square root. Smaller = more similar.
  (Math/sqrt (dfn/mean (dfn/sq (dfn/- signal1 signal2)))))
```
:::


Example: Compare original and noisy signal


::: {.sourceClojure}
```clojure
(let [original (range 100)
      noisy (dfn/+ original 0.1)]
  (compute-error original noisy))
```
:::



::: {.printedClojure}
```clojure
0.0999999999999986

```
:::


**Signal Energy** - total power in a signal:


::: {.sourceClojure}
```clojure
(defn signal-energy [signal]
  (dfn/sum (dfn/sq signal)))
```
:::


Example: Energy before and after filtering


::: {.sourceClojure}
```clojure
(signal-energy (:signal (:pure-sine signals)))
```
:::



::: {.printedClojure}
```clojure
50.0

```
:::


**Normalization** - scale signal to have average of zero and consistent spread:


::: {.sourceClojure}
```clojure
(defn normalize [signal]
  ;; Subtract the average (centers signal around zero)
  ;; Then divide by standard deviation (makes the spread consistent)
  ;; Useful for comparing signals with different scales
  (dfn// (dfn/- signal (dfn/mean signal))
         (dfn/standard-deviation signal)))
```
:::


Example: Normalize before processing


::: {.sourceClojure}
```clojure
(let [normalized (normalize (:signal (:two-tones signals)))]
  {:mean (dfn/mean normalized)
   :spread (dfn/standard-deviation normalized)})
```
:::



::: {.printedClojure}
```clojure
{:mean 3.552713678800501E-17, :spread 0.9999999999999997}

```
:::


**Signal-to-Noise Ratio ([SNR](https://en.wikipedia.org/wiki/Signal-to-noise_ratio)) in dB**:


::: {.sourceClojure}
```clojure
(defn snr-db [signal noise]
  ;; Measures signal quality: how much stronger is the signal than the noise?
  ;; Higher numbers = better quality. Measured in decibels (dB).
  ;; See: https://en.wikipedia.org/wiki/Signal-to-noise_ratio
  (* 20 (Math/log10 (/ (dfn/mean (dfn/sq signal))
                       (dfn/mean (dfn/sq noise))))))
```
:::


^kind/md
"**Example usage** - measuring compression quality:

```clojure
(let [signal (:signal (:smooth signals))
      noise (dfn/- signal compressed-signal)]
  (snr-db signal noise))
```"


### Transform Selection Flowchart


::: {.sourceClojure}
```clojure
(defn recommend-transform
  "Decision tree for transform selection."
  [signal-properties]
  (cond
    ;; Time-varying frequency
    (:time-varying-frequency signal-properties)
    {:transform :wavelet
     :reason "Frequency changes over time → need time-frequency localization"
     :recommended-type :daubechies-8}

    ;; Compression goal + smooth signal
    (and (:smooth signal-properties) (:compress signal-properties))
    {:transform :dct
     :reason "Smooth signal + compression → DCT energy concentration"
     :compression-ratio "10:1 to 100:1 typical"}

    ;; Frequency analysis with constant frequencies
    (:constant-frequencies signal-properties)
    {:transform :fft
     :reason "Constant frequencies → DFT (via FFT algorithm) is fastest and most accurate"
     :note "Use :real variant for real-valued signals (2x faster)"}

    ;; Denoising
    (:noisy signal-properties)
    {:transform :wavelet
     :reason "Noise removal → wavelet thresholding"
     :recommended-type :daubechies-8
     :threshold-method :soft}

    ;; Boundary conditions (PDEs)
    (:boundary-conditions signal-properties)
    {:transform :dst
     :reason "Signal must be zero at boundaries → use DST"
     :application "Finite element methods, heat equation"}

    ;; Default
    :else
    {:transform :fft
     :reason "General purpose - when in doubt, start with DFT (via FFT)"
     :note "Analyze spectrum first, then choose specialized transform"}))
```
:::


Examples:


::: {.sourceClojure}
```clojure
(recommend-transform #{:constant-frequencies})
```
:::



::: {.printedClojure}
```clojure
{:transform :fft,
 :reason
 "Constant frequencies → DFT (via FFT algorithm) is fastest and most accurate",
 :note "Use :real variant for real-valued signals (2x faster)"}

```
:::



::: {.sourceClojure}
```clojure
(recommend-transform #{:time-varying-frequency})
```
:::



::: {.printedClojure}
```clojure
{:transform :wavelet,
 :reason
 "Frequency changes over time → need time-frequency localization",
 :recommended-type :daubechies-8}

```
:::



::: {.sourceClojure}
```clojure
(recommend-transform #{:smooth :compress})
```
:::



::: {.printedClojure}
```clojure
{:transform :dct,
 :reason "Smooth signal + compression → DCT energy concentration",
 :compression-ratio "10:1 to 100:1 typical"}

```
:::



::: {.sourceClojure}
```clojure
(recommend-transform #{:noisy})
```
:::



::: {.printedClojure}
```clojure
{:transform :wavelet,
 :reason "Noise removal → wavelet thresholding",
 :recommended-type :daubechies-8,
 :threshold-method :soft}

```
:::



### Performance Tips

::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>tip</th><th>reason</th><th>example</th><th>speedup</th></tr></thead><tbody><tr><td>Use :real transforms</td><td>2x faster than complex for real-valued signals</td><td>(t/transformer :real :fft)</td><td></td></tr><tr><td>Reuse transformers</td><td>Pre-computes lookup tables in constructor</td><td>(def fft (t/transformer :real :fft))</td><td></td></tr><tr><td>Power-of-2 sizes</td><td>Enables fastest split-radix algorithm</td><td></td><td>~2-3x vs non-power-of-2</td></tr><tr><td>Use dtype-next</td><td>Vectorized operations, avoids boxing</td><td></td><td>Often 10-100x vs boxed seq operations</td></tr><tr><td>Avoid boxing</td><td>Type hints for primitive arrays</td><td>^doubles or use dtype-next</td><td></td></tr></tbody></table>
```

:::



### Common Pitfalls

::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>pitfall</th><th>solution</th><th>symptom</th></tr></thead><tbody><tr><td>Forgetting to scale inverse FFT</td><td>Use scaled=true or divide by N manually</td><td>Results N× too large</td></tr><tr><td>Non-power-of-2 for wavelets</td><td>Pad signal to next power of 2</td><td>Exception or wrong results</td></tr><tr><td>Using seqs for array math</td><td>Use dtype-next functional operations</td><td>Slow performance, high memory</td></tr><tr><td>Interpreting FFT magnitude wrong</td><td>Remember interleaved [real, imag] format</td><td>Incorrect frequency peaks</td></tr><tr><td>Not testing round-trip</td><td>Always verify transform → inverse recovers original</td><td>Lossy operations when expecting lossless</td></tr></tbody></table>
```

:::



### Recipe Collection

**Recipe 1: Find dominant frequency**


::: {.sourceClojure}
```clojure
(defn recipe-find-frequency [signal sample-rate]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        mags (fft-magnitude spectrum)
        max-idx (inc (argops/argmax (dtype/sub-buffer mags 1 (dec (dtype/ecount mags)))))
        freq (* max-idx (/ sample-rate (dtype/ecount signal)))]
    freq))
```
:::


**Recipe 2: Remove frequency**


::: {.sourceClojure}
```clojure
(defn recipe-notch-filter [signal sample-rate target-freq bandwidth]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        n (dtype/ecount signal)

        ;; Functional filtering: zero out target frequency band
        filtered (dtype/emap
                  (fn [idx val]
                    (let [freq (* (quot idx 2) (/ sample-rate n))]
                      (if (< (Math/abs (- freq target-freq)) bandwidth)
                        0.0
                        val)))
                  :float64
                  (range (dtype/ecount spectrum))
                  spectrum)]

    (t/reverse-1d fft filtered)))
```
:::


**Recipe 3: Compress with quality target**


::: {.sourceClojure}
```clojure
(defn recipe-compress-to-quality [signal target-snr-db]
  ;; Compress signal until we reach a target quality level (measured in dB)
  ;; Higher target-snr-db = better quality = less compression
  ;; Example: 30 dB is good quality, 20 dB is acceptable, 10 dB is poor
  (let [dct (t/transformer :real :dct)
        coeffs (t/forward-1d dct signal)]

    (loop [keep-ratio 0.9]
      (let [compressed (compress-with-dct signal keep-ratio)
            error (Math/sqrt (dfn/mean (dfn/sq (dfn/- signal compressed))))
            signal-power (Math/sqrt (dfn/mean (dfn/sq signal)))
            snr-db (* 20 (Math/log10 (/ signal-power error)))]

        (if (or (>= snr-db target-snr-db) (< keep-ratio 0.05))
          {:keep-ratio keep-ratio :snr-db snr-db :compressed compressed}
          (recur (- keep-ratio 0.05)))))))
```
:::


**Recipe 4: Denoise signal**


::: {.sourceClojure}
```clojure
(defn recipe-denoise [signal]
  (let [;; Pad to power of 2
        n (dtype/ecount signal)
        padded-n (int (Math/pow 2 (Math/ceil (/ (Math/log n) (Math/log 2)))))

        ;; Functional padding
        padded (dtype/emap
                (fn [i] (if (< i n)
                          (dtype/get-value signal i)
                          0.0))
                :float64
                (range padded-n))

        ;; Wavelet denoise
        wavelet (t/transformer :fast :daubechies-8)
        coeffs (t/forward-1d wavelet padded)
        denoised-coeffs (t/denoise wavelet coeffs :soft)
        denoised-full (t/reverse-1d wavelet denoised-coeffs)]

    ;; Return only original length
    (dtype/sub-buffer denoised-full 0 n)))
```
:::


**Recipe 5: Spectral analysis with thresholding**


::: {.sourceClojure}
```clojure
(defn recipe-find-all-frequencies [signal sample-rate min-magnitude]
  (let [fft (t/transformer :real :fft)
        spectrum (t/forward-1d fft signal)
        mags (fft-magnitude spectrum)
        n (dtype/ecount signal)

        peaks (filter #(> (dtype/get-value mags %) min-magnitude)
                      (range 1 (dtype/ecount mags)))]

    (map (fn [idx]
           {:frequency (* idx (/ sample-rate n))
            :magnitude (dtype/get-value mags idx)})
         peaks)))
```
:::



## Summary and Next Steps


### What We Learned

We used **dtype-next** for efficient array operations, leveraging vectorization and functional
patterns for clean, performant code.

The **core transforms** each serve different purposes. The **DFT** (via FFT) provides frequency
analysis using global sine/cosine basis functions. The **DCT** excels at compression with its
cosine-only basis and energy concentration properties. **Wavelets** offer time-frequency
localization with localized basis functions, perfect for denoising.

We also explored specialized transforms: the **DST** for boundary problems with sine-only basis,
the **DHT** as a real-valued alternative for convolution, and **2D transforms** for image processing
and frequency analysis.

**Applications** included bandpass filtering, lossy compression with quality metrics, wavelet
denoising, and spectral analysis. We validated everything through **round-trip testing**,
**stability testing** across tiny and huge signals (1e-6 to 1e6), and **property testing**
for characteristics like energy concentration and linearity.


### Key Takeaways

::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>concept</th><th>insight</th></tr></thead><tbody><tr><td>Linear Decomposition</td><td>All transforms express signals as weighted sums of basis functions</td></tr><tr><td>dtype-next First</td><td>Use vectorized operations for performance and clarity</td></tr><tr><td>Global vs Local</td><td>DFT/DCT see whole signal, wavelets see time AND frequency</td></tr><tr><td>Test-Driven</td><td>Always validate with round-trip tests</td></tr><tr><td>Choose Wisely</td><td>Match transform to signal properties and use case</td></tr></tbody></table>
```

:::



### Next Steps

1. **Experiment**: Try these transforms on your own signals
2. **Extend**: Implement spectrograms (sliding window FFT)
3. **Optimize**: Profile dtype-next vs traditional approaches
4. **Apply**: Build audio visualizer, image compressor, or signal processor
5. **Deep Dive**: Explore transform theory, basis functions, and mathematics


### Further Resources


- **dtype-next Guide**: https://cnuernber.github.io/dtype-next/
- **Fastmath Transform**: https://generateme.github.io/fastmath/clay/transform.html
- **JTransforms**: https://github.com/wendykierp/JTransforms
- **Clay Documentation**: https://scicloj.github.io/clay/

---
**End of Comprehensive Tutorial**

You now have: theory, practice, validation, and recipes.
Go forth and transform signals with confidence! 🌊📈


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/ClojureCivitas/clojurecivitas.github.io/blob/main/src/dsp/transforms_comprehensive.clj">src/dsp/transforms_comprehensive.clj</a></small></small></pre></div>
```