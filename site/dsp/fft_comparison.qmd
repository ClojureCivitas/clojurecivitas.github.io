---
author:
  name: Daniel Slutsky
  image: https://avatars.githubusercontent.com/u/5673102?v=4
  url: https://scicloj.github.io/contributors/daslu/
  affiliation:
  - {name: Scicloj, url: 'https://scicloj.github.io/'}
  - {name: Endor Global, url: 'https://endor.global'}
  links:
  - {icon: github, href: 'https://github.com/daslu'}
draft: true
type: post
date: '2025-12-14'
category: data
tags: [dsp, fft, performance, benchmarks, jtransforms, fastmath, apache-commons]
format:
  html: {title: Comparing FFT Implementations in Clojure}

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.20.0/plotly.min.js" type="text/javascript"></script>
**Exploration from the [Scicloj DSP Study Group](https://scicloj.github.io/docs/community/groups/dsp-study/)**

Welcome! This exploration comes from our DSP study group, where we're learning digital signal processing together using Clojure. We're following the excellent book [**Think DSP** by Allen B. Downey](https://greenteapress.com/wp/think-dsp/) (available free online).


# Introduction

The [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) (FFT) is fundamental to signal processing, audio analysis, image compression, and scientific computing. If you're working with frequency analysis in Clojure, you have several Java FFT libraries to choose from.

This post compares four approaches:


- **Apache Commons Math** - Mature library with general mathematical transforms
- **JDSP** - Digital signal processing library (uses Apache Commons Math internally)
- **JTransforms** - First multithreaded, pure-Java FFT library
- **Fastmath** - Clojure math library (wraps JTransforms with idiomatic API)

We'll compute the FFT of the same test signal using each library, measure performance, and discuss their trade-offs.


## The Libraries


### Apache Commons Math

[Apache Commons Math](https://commons.apache.org/proper/commons-math/) is a comprehensive mathematical library for Java. It provides [`FastFourierTransformer`](https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/transform/FastFourierTransformer.html) with various transform types and [normalization](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Normalization) options.

**Key features:**

- Part of Apache Commons (widely used, stable, maintained)
- Supports multiple normalization conventions
- 1D FFT, [DCT](https://en.wikipedia.org/wiki/Discrete_cosine_transform)/[DST](https://en.wikipedia.org/wiki/Discrete_sine_transform), [Hadamard](https://en.wikipedia.org/wiki/Hadamard_transform) transforms
- Requires signal length to be a [power of 2](https://en.wikipedia.org/wiki/Power_of_two)
- Returns [`Complex[]`](https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/complex/Complex.html) arrays (allocation overhead)


### JDSP

[JDSP](https://jdsp.dev) by [Sambit Paul](https://github.com/psambit9791) is a Java [Digital Signal Processing](https://en.wikipedia.org/wiki/Digital_signal_processing) library providing [filters](https://en.wikipedia.org/wiki/Digital_filter), transforms, [peak detection](https://en.wikipedia.org/wiki/Peak_detection), and more. It uses Apache Commons Math internally for FFT computation.

**Key features:**

- Convenient wrapper around Apache Commons Math
- Simple API: [`new FastFourier(signal).transform()`](https://javadoc.io/doc/com.github.psambit9791/jdsp/latest/com/github/psambit9791/jdsp/transform/FastFourier.html)
- Includes comprehensive DSP utilities ([filters](https://en.wikipedia.org/wiki/Digital_filter), [wavelets](https://en.wikipedia.org/wiki/Wavelet), [convolution](https://en.wikipedia.org/wiki/Convolution), [STFT](https://en.wikipedia.org/wiki/Short-time_Fourier_transform))
- Good for projects needing broader DSP functionality beyond FFT


### JTransforms

[JTransforms](https://github.com/wendykierp/JTransforms) by [Piotr Wendykier](https://github.com/wendykierp) is the first open-source, multithreaded FFT library written in pure Java. It's optimized for performance with [parallel processing](https://en.wikipedia.org/wiki/Parallel_computing) support.

**Key features:**

- **Parallelized** [split-radix](https://en.wikipedia.org/wiki/Split-radix_FFT_algorithm) and [mixed-radix](https://en.wikipedia.org/wiki/Mixed-radix) algorithms
- Supports **1D, 2D, and 3D** transforms (FFT, [DCT](https://en.wikipedia.org/wiki/Discrete_cosine_transform), [DST](https://en.wikipedia.org/wiki/Discrete_sine_transform), [DHT](https://en.wikipedia.org/wiki/Discrete_Hartley_transform))
- [In-place mutations](https://en.wikipedia.org/wiki/In-place_algorithm) (efficient but not functional)
- Mixed-radix support: works with arbitrary sizes (not just power-of-2)
- Used internally by Fastmath and dtype-next


### Fastmath

[fastmath](https://github.com/generateme/fastmath) (version 3.x) by [Tomasz Sulej](https://github.com/genmeblog) is a Clojure library for fast primitive-based mathematics. Its [`fastmath.transform`](https://generateme.github.io/fastmath/fastmath.transform.html) namespace wraps JTransforms with an idiomatic Clojure API.

**Key features:**

- Immutable, [functional](https://en.wikipedia.org/wiki/Functional_programming) API (no in-place mutations)
- Leverages JTransforms' parallelized performance and mixed-radix algorithms
- [Protocol-based](https://clojure.org/reference/protocols) design: `transformer` → `forward-1d`/`reverse-1d`
- Supports **1D and 2D** transforms, multiple transform types (FFT, DCT, DST, DHT)
- Additional signal processing utilities ([wavelets](https://en.wikipedia.org/wiki/Wavelet), oscillators, envelopes, noise)


## Test Signal: Two-Tone Sine Wave

We'll create a simple test signal: a combination of two [sine waves](https://en.wikipedia.org/wiki/Sine_wave) at 5 Hz and 12 Hz, [sampled](https://en.wikipedia.org/wiki/Sampling_(signal_processing)) at 100 Hz for 1 second.

Hz


::: {.sourceClojure}
```clojure
(def sample-rate 100.0)
```
:::


seconds


::: {.sourceClojure}
```clojure
(def duration 1.0)
```
:::


Power of 2 (required by Apache Commons Math)


::: {.sourceClojure}
```clojure
(def n-samples 128)
```
:::



::: {.sourceClojure}
```clojure
(def time-points
  (dfn/* (range n-samples) (/ duration n-samples)))
```
:::



::: {.sourceClojure}
```clojure
(defn generate-test-signal
  "Generate a two-tone sine wave (5 Hz + 12 Hz) test signal.
  Returns a Java double array suitable for FFT libraries."
  [n-samples]
  ;; Time vector in seconds: [0, 1/sample-rate, 2/sample-rate, ...]
  (let [t (dfn/* (range n-samples) (/ 1.0 sample-rate))]
    (dtype/->double-array
     (dfn/+ (dfn/sin (dfn/* 2.0 Math/PI 5.0 t))
            (dfn/sin (dfn/* 2.0 Math/PI 12.0 t))))))
```
:::


Convert to Java double array for FFT libraries
(dtype-next functional ops work on sequences, but Java FFT expects double[])


::: {.sourceClojure}
```clojure
(def signal (generate-test-signal n-samples))
```
:::


Let's visualize the signal:


::: {.sourceClojure}
```clojure
(-> (tc/dataset {:time (take 128 time-points)
                 :amplitude (take 128 signal)})
    (plotly/base {:=x :time
                  :=y :amplitude
                  :=x-title "Time (s)"
                  :=y-title "Amplitude"
                  :=title "Test Signal: 5 Hz + 12 Hz"
                  :=width 700
                  :=height 300})
    (plotly/layer-line {:=mark-color "steelblue"}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.0,0.9935641003036362,1.5858119807207447,1.5795302371507367,1.0763897498594577,0.412214747707527,-0.03123073443353508,-0.03531093112706751,0.33909536512761873,0.7907706684766624,0.9510565162951536,0.5958100580910728,-0.21966069960779505,-1.1771415470596245,-1.8558835687611732,-1.9510565162951536,-1.4328101903968684,-0.5603271072100929,0.25654267320954127,0.6732702563537409,0.5877852522924734,0.18368376081064425,-0.182727990483315,-0.18900973405332433,0.2665094103664649,0.9999999999999992,1.6356036222238413,1.8070437228032192,1.3582984950682622,0.4343502279392557,-0.5877852522924721,-1.2913042451036354,-1.4321131777944873,-1.0577068815398016,-0.4693028421934384,-0.04894348370484569,-0.04622946382913351,-0.44089244169026737,-0.9559098049771517,-1.2138440468409673,-0.9510565162951544,-0.1727366797267652,0.8364751394573249,1.6533449198769623,1.933343767023843,1.5877852522924742,0.825723282730848,0.038503751599154645,-0.410241476135798,-0.37553011155374383,-8.572527594031471E-16,0.3755301115537411,0.41024147613579875,-0.03850375159915875,-0.8257232827308518,-1.5877852522924718,-1.9333437670238427,-1.6533449198769596,-0.8364751394573356,0.1727366797267615,0.9510565162951522,1.213844046840967,0.9559098049771535,0.4408924416902704,0.04622946382913273,0.0489434837048458,0.4693028421934394,1.0577068815398052,1.4321131777944887,1.291304245103635,0.5877852522924664,-0.43435022793924283,-1.3582984950682593,-1.8070437228032175,-1.6356036222238455,-1.0000000000000022,-0.2665094103664647,0.18900973405332444,0.1827279904833159,-0.18368376081064436,-0.5877852522924722,-0.6732702563537405,-0.25654267320953816,0.560327107210099,1.432810190396864,1.9510565162951505,1.8558835687611732,1.1771415470596307,0.21966069960780377,-0.5958100580910735,-0.9510565162951533,-0.7907706684766694,-0.33909536512761457,0.035310931127066625,0.031230734433532747,-0.4122147477075303,-1.0763897498594583,-1.5795302371507356,-1.5858119807207463,-0.993564100303638,-4.1637991171010006E-15,0.9935641003036313,1.585811980720747,1.579530237150736,1.0763897498594632,0.41221474770752364,-0.031230734433535745,-0.03531093112707251,0.3390953651276246,0.7907706684766632,0.9510565162951503,0.5958100580910655,-0.21966069960779627,-1.1771415470596371,-1.8558835687611772,-1.9510565162951523,-1.4328101903968822,-0.5603271072101014,0.25654267320953306,0.6732702563537407,0.5877852522924746,0.18368376081065124,-0.18272799048331245,-0.18900973405332622,0.2665094103664597,0.9999999999999892,1.635603622223841,1.8070437228032206],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"steelblue"},"lon":null,"lat":null,"x":[0.0,0.0078125,0.015625,0.0234375,0.03125,0.0390625,0.046875,0.0546875,0.0625,0.0703125,0.078125,0.0859375,0.09375,0.1015625,0.109375,0.1171875,0.125,0.1328125,0.140625,0.1484375,0.15625,0.1640625,0.171875,0.1796875,0.1875,0.1953125,0.203125,0.2109375,0.21875,0.2265625,0.234375,0.2421875,0.25,0.2578125,0.265625,0.2734375,0.28125,0.2890625,0.296875,0.3046875,0.3125,0.3203125,0.328125,0.3359375,0.34375,0.3515625,0.359375,0.3671875,0.375,0.3828125,0.390625,0.3984375,0.40625,0.4140625,0.421875,0.4296875,0.4375,0.4453125,0.453125,0.4609375,0.46875,0.4765625,0.484375,0.4921875,0.5,0.5078125,0.515625,0.5234375,0.53125,0.5390625,0.546875,0.5546875,0.5625,0.5703125,0.578125,0.5859375,0.59375,0.6015625,0.609375,0.6171875,0.625,0.6328125,0.640625,0.6484375,0.65625,0.6640625,0.671875,0.6796875,0.6875,0.6953125,0.703125,0.7109375,0.71875,0.7265625,0.734375,0.7421875,0.75,0.7578125,0.765625,0.7734375,0.78125,0.7890625,0.796875,0.8046875,0.8125,0.8203125,0.828125,0.8359375,0.84375,0.8515625,0.859375,0.8671875,0.875,0.8828125,0.890625,0.8984375,0.90625,0.9140625,0.921875,0.9296875,0.9375,0.9453125,0.953125,0.9609375,0.96875,0.9765625,0.984375,0.9921875],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Time (s)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Amplitude","showgrid":true},"title":"Test Signal: 5 Hz + 12 Hz"}, {});</script></div>
```



## Visualization Helper

To visualize FFT results throughout this post, we'll use a helper function:


::: {.sourceClojure}
```clojure
(defn plot-fft-spectrum
  "Plot FFT magnitude spectrum.
  
  Parameters:

  - magnitudes: sequence of magnitude values
  - title: plot title
  - color: line color (e.g., 'darkgreen', 'darkorange')
  
  Returns Plotly visualization."
  [magnitudes title color]
  (let [n-bins (count magnitudes)
        freq-bins (dfn/* (range n-bins) (/ sample-rate n-samples))]
    (-> (tc/dataset {:frequency freq-bins
                     :magnitude magnitudes})
        (plotly/base {:=x :frequency
                      :=y :magnitude
                      :=x-title "Frequency (Hz)"
                      :=y-title "Magnitude"
                      :=title title
                      :=width 700
                      :=height 300})
        (plotly/layer-line {:=mark-color color}))))
```
:::



## FFT Implementation #1: Apache Commons Math

Apache Commons Math requires creating a [`FastFourierTransformer`](https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/transform/FastFourierTransformer.html) with a [normalization](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Normalization) type, then calling `transform` with the signal.


::: {.sourceClojure}
```clojure
(defn fft-apache-commons
  "Compute FFT using Apache Commons Math."
  [^doubles signal]
  (let [transformer (FastFourierTransformer. DftNormalization/STANDARD)]
    ; Result is Complex[] array
    (.transform transformer signal TransformType/FORWARD)))
```
:::


Let's run it and measure time:


::: {.sourceClojure}
```clojure
(def commons-result
  (time (fft-apache-commons signal)))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 1.746427 msecs"

```
:::


The output is an array of [`Complex`](https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/complex/Complex.html) objects. To extract [magnitudes](https://en.wikipedia.org/wiki/Magnitude_(mathematics)#Euclidean_vector_space):


::: {.sourceClojure}
```clojure
(defn complex-magnitude
  "Compute magnitude from Apache Commons Math Complex."
  [^Complex c]
  (.abs c))
```
:::



::: {.sourceClojure}
```clojure
(def commons-magnitudes
  (mapv complex-magnitude commons-result))
```
:::


Visualize the first half (positive frequencies):


::: {.sourceClojure}
```clojure
(plot-fft-spectrum
 (take (quot (count commons-magnitudes) 2) commons-magnitudes)
 "FFT Spectrum (Apache Commons Math)"
 "darkgreen")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[7.099523102364518,7.26238995205225,7.800672692331721,8.909665923051353,11.1726390548781,16.894396691896432,51.5131149759004,29.123703824784247,8.767061751490655,3.8279699015027715,1.3363645130937454,0.6833732259222697,2.555632191000765,5.3323272432947855,11.402765484104386,49.297201670630194,30.517572218051942,12.805648828561784,8.427025727351454,6.409252283838707,5.234845203154721,4.46040514931483,3.9084289441003053,3.493628013981118,3.169755254090811,2.909469746237538,2.6955228768770465,2.516467993331453,2.364394535096177,2.2336512794638925,2.1200879521111373,2.0205845625703116,1.9327482963405136,1.8547120383193303,1.7849967354218437,1.7224150967690732,1.6660027837758042,1.6149683168746438,1.5686559954756025,1.5265180372219098,1.4880933601533555,1.4529912253057748,1.4208784855324719,1.3914695443513299,1.3645183753701506,1.339812125542559,1.3171659481068922,1.296418799235348,1.2774299966208145,1.2600763854912556,1.2442499927174773,1.2298560761103488,1.2168114960556753,1.2050433519823702,1.1944878380073707,1.185089281322887,1.1767993341302163,1.1695762956568814,1.163384545362686,1.1581940721342558,1.1539800872655896,1.1507227114994156,1.1484067284734862,1.147021398675422],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"darkgreen"},"lon":null,"lat":null,"x":[0.0,0.78125,1.5625,2.34375,3.125,3.90625,4.6875,5.46875,6.25,7.03125,7.8125,8.59375,9.375,10.15625,10.9375,11.71875,12.5,13.28125,14.0625,14.84375,15.625,16.40625,17.1875,17.96875,18.75,19.53125,20.3125,21.09375,21.875,22.65625,23.4375,24.21875,25.0,25.78125,26.5625,27.34375,28.125,28.90625,29.6875,30.46875,31.25,32.03125,32.8125,33.59375,34.375,35.15625,35.9375,36.71875,37.5,38.28125,39.0625,39.84375,40.625,41.40625,42.1875,42.96875,43.75,44.53125,45.3125,46.09375,46.875,47.65625,48.4375,49.21875],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Magnitude","showgrid":true},"title":"FFT Spectrum (Apache Commons Math)"}, {});</script></div>
```


**Note:** You'll notice the peaks around 5 Hz and 12 Hz aren't perfectly sharp—energy spreads to neighboring frequency bins.
This is called [spectral leakage](https://en.wikipedia.org/wiki/Spectral_leakage), which occurs when signal frequencies don't align exactly with FFT bin frequencies.
We'll explore windowing techniques to address this in a future post.


## FFT Implementation #2: JDSP

JDSP provides a wrapper around Apache Commons Math with a simpler API.


::: {.sourceClojure}
```clojure
(defn fft-jdsp
  "Compute FFT using JDSP."
  [signal]
  (let [fft (FastFourier. signal)]
    (.transform fft)
    ; Get magnitude values (positive frequencies only)
    (.getMagnitude fft true)))
```
:::



::: {.sourceClojure}
```clojure
(def jdsp-result
  (time (fft-jdsp signal)))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 1.454826 msecs"

```
:::


Visualize


::: {.sourceClojure}
```clojure
(plot-fft-spectrum
 jdsp-result
 "FFT Spectrum (JDSP)"
 "darkorange")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[7.099523102364518,7.26238995205225,7.800672692331721,8.909665923051353,11.1726390548781,16.894396691896432,51.5131149759004,29.123703824784247,8.767061751490655,3.8279699015027715,1.3363645130937454,0.6833732259222697,2.555632191000765,5.3323272432947855,11.402765484104386,49.297201670630194,30.517572218051942,12.805648828561784,8.427025727351454,6.409252283838707,5.234845203154721,4.46040514931483,3.9084289441003053,3.493628013981118,3.169755254090811,2.909469746237538,2.6955228768770465,2.516467993331453,2.364394535096177,2.2336512794638925,2.1200879521111373,2.0205845625703116,1.9327482963405136,1.8547120383193303,1.7849967354218437,1.7224150967690732,1.6660027837758042,1.6149683168746438,1.5686559954756025,1.5265180372219098,1.4880933601533555,1.4529912253057748,1.4208784855324719,1.3914695443513299,1.3645183753701506,1.339812125542559,1.3171659481068922,1.296418799235348,1.2774299966208145,1.2600763854912556,1.2442499927174773,1.2298560761103488,1.2168114960556753,1.2050433519823702,1.1944878380073707,1.185089281322887,1.1767993341302163,1.1695762956568814,1.163384545362686,1.1581940721342558,1.1539800872655896,1.1507227114994156,1.1484067284734862,1.147021398675422,1.1465603295393674],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"darkorange"},"lon":null,"lat":null,"x":[0.0,0.78125,1.5625,2.34375,3.125,3.90625,4.6875,5.46875,6.25,7.03125,7.8125,8.59375,9.375,10.15625,10.9375,11.71875,12.5,13.28125,14.0625,14.84375,15.625,16.40625,17.1875,17.96875,18.75,19.53125,20.3125,21.09375,21.875,22.65625,23.4375,24.21875,25.0,25.78125,26.5625,27.34375,28.125,28.90625,29.6875,30.46875,31.25,32.03125,32.8125,33.59375,34.375,35.15625,35.9375,36.71875,37.5,38.28125,39.0625,39.84375,40.625,41.40625,42.1875,42.96875,43.75,44.53125,45.3125,46.09375,46.875,47.65625,48.4375,49.21875,50.0],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Magnitude","showgrid":true},"title":"FFT Spectrum (JDSP)"}, {});</script></div>
```



## FFT Implementation #3: JTransforms (Direct)

JTransforms mutates the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm). The [`realForward`](https://wendykierp.github.io/JTransforms/apidocs/org/jtransforms/fft/DoubleFFT_1D.html#realForward-double:A-) method transforms the array into interleaved `[real0, imag0, real1, imag1, ...]` format.


::: {.sourceClojure}
```clojure
(defn fft-jtransforms
  "Compute FFT using JTransforms directly."
  [signal]
  ; Copy signal to avoid mutating original
  (let [fft-obj (DoubleFFT_1D. (long (count signal)))
        signal-copy (double-array signal)]
    (.realForward fft-obj signal-copy)
    signal-copy))
```
:::



::: {.sourceClojure}
```clojure
(def jtransforms-result
  (time (fft-jtransforms signal)))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 4.079134 msecs"

```
:::


Extract magnitudes from interleaved format:


::: {.sourceClojure}
```clojure
(defn jtransforms-magnitude
  "Compute magnitudes from JTransforms interleaved [real, imag, ...] format."
  [spectrum]
  (let [n-bins (quot (count spectrum) 2)]
    (mapv (fn [i]
            (let [real (nth spectrum (* 2 i))
                  imag (nth spectrum (inc (* 2 i)))]
              (Math/sqrt (+ (* real real) (* imag imag)))))
          (range n-bins))))
```
:::



::: {.sourceClojure}
```clojure
(def jtransforms-magnitudes
  (jtransforms-magnitude jtransforms-result))
```
:::


Visualize


::: {.sourceClojure}
```clojure
(plot-fft-spectrum
 jtransforms-magnitudes
 "FFT Spectrum (JTransforms)"
 "purple")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[7.1915108892555315,7.262389952052249,7.800672692331718,8.909665923051355,11.172639054878097,16.894396691896432,51.51311497590039,29.123703824784233,8.767061751490656,3.8279699015027684,1.3363645130937476,0.6833732259222631,2.555632191000762,5.332327243294781,11.40276548410438,49.297201670630194,30.517572218051935,12.805648828561766,8.427025727351442,6.409252283838697,5.234845203154721,4.460405149314829,3.9084289441003066,3.4936280139811204,3.169755254090813,2.9094697462375483,2.695522876877025,2.516467993331443,2.3643945350961717,2.2336512794638876,2.120087952111136,2.020584562570312,1.932748296340516,1.854712038319328,1.7849967354218428,1.7224150967690706,1.6660027837758045,1.6149683168746425,1.5686559954756003,1.5265180372219127,1.4880933601533552,1.4529912253057755,1.4208784855324725,1.3914695443513325,1.3645183753701526,1.339812125542561,1.3171659481068916,1.2964187992353464,1.277429996620824,1.2600763854912478,1.244249992717476,1.2298560761103485,1.216811496055675,1.2050433519823702,1.1944878380073742,1.1850892813228848,1.1767993341302172,1.1695762956568918,1.163384545362662,1.158194072134246,1.153980087265584,1.1507227114994139,1.1484067284734818,1.1470213986754192],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"purple"},"lon":null,"lat":null,"x":[0.0,0.78125,1.5625,2.34375,3.125,3.90625,4.6875,5.46875,6.25,7.03125,7.8125,8.59375,9.375,10.15625,10.9375,11.71875,12.5,13.28125,14.0625,14.84375,15.625,16.40625,17.1875,17.96875,18.75,19.53125,20.3125,21.09375,21.875,22.65625,23.4375,24.21875,25.0,25.78125,26.5625,27.34375,28.125,28.90625,29.6875,30.46875,31.25,32.03125,32.8125,33.59375,34.375,35.15625,35.9375,36.71875,37.5,38.28125,39.0625,39.84375,40.625,41.40625,42.1875,42.96875,43.75,44.53125,45.3125,46.09375,46.875,47.65625,48.4375,49.21875],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Magnitude","showgrid":true},"title":"FFT Spectrum (JTransforms)"}, {});</script></div>
```



## FFT Implementation #4: Fastmath

Fastmath provides the most Clojure-idiomatic API. Create a transformer, then use `forward-1d`.


::: {.sourceClojure}
```clojure
(defn fft-fastmath
  "Compute FFT using fastmath."
  [signal]
  (let [transformer (fm-transform/transformer :real :fft)]
    (fm-transform/forward-1d transformer signal)))
```
:::



::: {.sourceClojure}
```clojure
(def fastmath-result
  (time (fft-fastmath signal)))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 0.246719 msecs"

```
:::


Extract magnitudes (Fastmath uses JTransforms format internally):


::: {.sourceClojure}
```clojure
(defn fastmath-magnitude
  "Compute magnitudes from fastmath FFT output."
  [spectrum]
  (let [n-bins (quot (dtype/ecount spectrum) 2)]
    (mapv (fn [i]
            (let [real (dtype/get-value spectrum (* 2 i))
                  imag (dtype/get-value spectrum (inc (* 2 i)))]
              (Math/sqrt (+ (* real real) (* imag imag)))))
          (range n-bins))))
```
:::



::: {.sourceClojure}
```clojure
(def fastmath-magnitudes
  (fastmath-magnitude fastmath-result))
```
:::


Visualize


::: {.sourceClojure}
```clojure
(plot-fft-spectrum
 fastmath-magnitudes
 "FFT Spectrum (Fastmath)"
 "crimson")
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[7.1915108892555315,7.262389952052249,7.800672692331718,8.909665923051355,11.172639054878097,16.894396691896432,51.51311497590039,29.123703824784233,8.767061751490656,3.8279699015027684,1.3363645130937476,0.6833732259222631,2.555632191000762,5.332327243294781,11.40276548410438,49.297201670630194,30.517572218051935,12.805648828561766,8.427025727351442,6.409252283838697,5.234845203154721,4.460405149314829,3.9084289441003066,3.4936280139811204,3.169755254090813,2.9094697462375483,2.695522876877025,2.516467993331443,2.3643945350961717,2.2336512794638876,2.120087952111136,2.020584562570312,1.932748296340516,1.854712038319328,1.7849967354218428,1.7224150967690706,1.6660027837758045,1.6149683168746425,1.5686559954756003,1.5265180372219127,1.4880933601533552,1.4529912253057755,1.4208784855324725,1.3914695443513325,1.3645183753701526,1.339812125542561,1.3171659481068916,1.2964187992353464,1.277429996620824,1.2600763854912478,1.244249992717476,1.2298560761103485,1.216811496055675,1.2050433519823702,1.1944878380073742,1.1850892813228848,1.1767993341302172,1.1695762956568918,1.163384545362662,1.158194072134246,1.153980087265584,1.1507227114994139,1.1484067284734818,1.1470213986754192],"r":null,"name":"","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"crimson"},"lon":null,"lat":null,"x":[0.0,0.78125,1.5625,2.34375,3.125,3.90625,4.6875,5.46875,6.25,7.03125,7.8125,8.59375,9.375,10.15625,10.9375,11.71875,12.5,13.28125,14.0625,14.84375,15.625,16.40625,17.1875,17.96875,18.75,19.53125,20.3125,21.09375,21.875,22.65625,23.4375,24.21875,25.0,25.78125,26.5625,27.34375,28.125,28.90625,29.6875,30.46875,31.25,32.03125,32.8125,33.59375,34.375,35.15625,35.9375,36.71875,37.5,38.28125,39.0625,39.84375,40.625,41.40625,42.1875,42.96875,43.75,44.53125,45.3125,46.09375,46.875,47.65625,48.4375,49.21875],"text":null}], {"width":700,"height":300,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Frequency (Hz)","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Magnitude","showgrid":true},"title":"FFT Spectrum (Fastmath)"}, {});</script></div>
```



## Performance Comparison

To properly compare these libraries, we'll use [criterium](https://github.com/hugoduncan/criterium) for rigorous JVM benchmarking.
Criterium handles JVM warmup, runs multiple iterations, and provides statistical analysis.

We'll test two signal sizes: 128 samples (small, 2^7) and 131,072 samples (large, 2^17).


::: {.sourceClojure}
```clojure
(defn benchmark-library
  "Benchmark an FFT function using criterium."
  [fft-fn signal]
  (let [result (crit/quick-benchmark* (fn [] (fft-fn signal)) {})]
    {:mean-ms (* (first (:mean result)) 1e3)
     :lower-q-ms (* (first (:lower-q result)) 1e3)
     :upper-q-ms (* (first (:upper-q result)) 1e3)}))
```
:::


Run benchmarks for both sizes


::: {.sourceClojure}
```clojure
(def library-benchmarks
  (for [size [128 131072]
        [lib-name fft-fn] [["Apache Commons Math" fft-apache-commons]
                           ["JDSP" fft-jdsp]
                           ["JTransforms" fft-jtransforms]
                           ["Fastmath" fft-fastmath]]]
    (let [sig (generate-test-signal size)
          result (benchmark-library fft-fn sig)]
      (assoc result
             :library lib-name
             :size size))))
```
:::


Display results


::: {.sourceClojure}
```clojure
(kind/table
 (map (fn [{:keys [library size mean-ms lower-q-ms upper-q-ms]}]
        {:library library
         :size (if (= size 128) "128 (2^7)" "131K (2^17)")
         :mean-time (format "%.6f ms" mean-ms)
         :range (format "%.6f - %.6f ms" lower-q-ms upper-q-ms)})
      library-benchmarks))
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>library</th><th>size</th><th>mean-time</th><th>range</th></tr></thead><tbody><tr><td>Apache Commons Math</td><td>128 (2^7)</td><td>0.001687 ms</td><td>0.001246 - 0.002398 ms</td></tr><tr><td>JDSP</td><td>128 (2^7)</td><td>0.002086 ms</td><td>0.001500 - 0.003128 ms</td></tr><tr><td>JTransforms</td><td>128 (2^7)</td><td>0.002488 ms</td><td>0.001832 - 0.003684 ms</td></tr><tr><td>Fastmath</td><td>128 (2^7)</td><td>0.002575 ms</td><td>0.001884 - 0.003591 ms</td></tr><tr><td>Apache Commons Math</td><td>131K (2^17)</td><td>3.592679 ms</td><td>3.422478 - 3.875740 ms</td></tr><tr><td>JDSP</td><td>131K (2^17)</td><td>3.873716 ms</td><td>3.546291 - 4.500101 ms</td></tr><tr><td>JTransforms</td><td>131K (2^17)</td><td>2.961984 ms</td><td>2.223287 - 4.067186 ms</td></tr><tr><td>Fastmath</td><td>131K (2^17)</td><td>2.923237 ms</td><td>2.323596 - 4.119916 ms</td></tr></tbody></table>
```

:::



## Exploring Parallelization: An Experiment

JTransforms advertises [parallel processing](https://en.wikipedia.org/wiki/Parallel_processing) support, which sounds promising for large FFTs. But does it actually help? Let's explore.

**Disclaimer:** This section documents an exploratory experiment with uncertain conclusions. We're learning as we go, and the results are puzzling!


### How JTransforms Works: Three Algorithm Plans

Looking at the [JTransforms source code](https://github.com/wendykierp/JTransforms/blob/master/src/main/java/org/jtransforms/fft/DoubleFFT_1D.java), we discovered it uses **three different execution plans**:

1. **SPLIT_RADIX** ([Cooley-Tukey variant](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)) - Used for power-of-2 sizes, supports multithreading
2. **MIXED_RADIX** (Cooley-Tukey variant) - Used for factorable sizes (divisible by 2, 3, 4, 5), primarily sequential
3. **BLUESTEIN** ([Chirp Z-transform](https://en.wikipedia.org/wiki/Chirp_Z-transform#Bluestein's_algorithm)) - Used for arbitrary sizes with large prime factors, supports 1-4 threads

The plan is automatically selected in the constructor based on signal size:

- Power-of-2 → SPLIT_RADIX (fastest, our benchmarks use this)
- Factorable by small primes → MIXED_RADIX
- Large prime factors (remainder ≥ 211) → BLUESTEIN

This explains why arbitrary sizes like 100, 127, 1000 work—they use MIXED_RADIX or BLUESTEIN!

The [JTransforms paper (Wendykier & Nagy 2008)](https://www.math.emory.edu/technical-reports/techrep-00127.pdf) discusses these implementations,
noting that 1D transforms can use at most 2 or 4 threads due to the algorithm's structure.


### Testing Thread Performance

Let's test with power-of-2 sizes to ensure we're using the fast SPLIT_RADIX plan.
We'll use [criterium](https://github.com/hugoduncan/criterium) for proper JVM benchmarking (warmup, statistics, GC handling):


::: {.sourceClojure}
```clojure
(import 'pl.edu.icm.jlargearrays.ConcurrencyUtils
        'org.jtransforms.utils.CommonUtils)
```
:::



::: {.printedClojure}
```clojure
org.jtransforms.utils.CommonUtils

```
:::



::: {.sourceClojure}
```clojure
(defn benchmark-with-threads
  "Benchmark FFT at specific thread count using criterium for statistical analysis."
  [n-threads signal]
  (let [previous-threads (ConcurrencyUtils/getNumberOfThreads)]
    (try
      (ConcurrencyUtils/setNumberOfThreads n-threads)
      ;; Use criterium's quick-bench for proper JVM warmup and statistics
      (let [result (crit/quick-benchmark* (fn [] (fft-fastmath signal)) {})]
        {:threads n-threads
         ;; Criterium returns [value (lower-ci upper-ci)] for each metric
         :mean-ms (* (first (:mean result)) 1e3) ; Convert seconds to milliseconds
         :variance-ms (* (first (:variance result)) 1e6) ; Variance in ms^2
         :lower-q-ms (* (first (:lower-q result)) 1e3)
         :upper-q-ms (* (first (:upper-q result)) 1e3)})
      (finally
        (ConcurrencyUtils/setNumberOfThreads previous-threads)))))
```
:::


We'll test multiple power-of-2 signal sizes and various thread counts (including 8 and 16, which the paper says are unsupported for 1D)

**Experiment setup:**

- Signal sizes: 16384 (2^14), 65536 (2^16), 131072 (2^17), 262144 (2^18)
- Thread counts: 1, 2, 4, 8, 16
- Each configuration benchmarked with criterium (JVM warmup, multiple samples, statistical analysis)


::: {.sourceClojure}
```clojure
(def threading-experiment
  (for [size [16384 65536 131072 262144]
        threads [1 2 4 8 16]]
    (let [sig (generate-test-signal size)
          result (benchmark-with-threads threads sig)]
      (assoc result :size size))))
```
:::


Let's visualize the results:


::: {.sourceClojure}
```clojure
(-> (tc/dataset threading-experiment)
    (plotly/base {:=x :threads
                  :=y :mean-ms
                  :=color :size
                  :=color-type :nominal
                  :=title "FFT Performance vs Thread Count (Fastmath/JTransforms)"
                  :=x-title "Number of Threads"
                  :=y-title "Mean Time per FFT (ms)"
                  :=width 800
                  :=height 500})
    (plotly/layer-point {:=mark-size 10})
    (plotly/layer-line {:=mark-opacity 0.6}))
```
:::



```{=html}
<div style="height:auto;width:100%;"><script>Plotly.newPlot(document.currentScript.parentElement, [{"y":[0.3655132686375322,0.3780481164251208,0.39125373168498173,0.33332981963470326,0.39898399901960785],"r":null,"name":"16384","marker":{"color":"#1B9E77","size":10},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[1.4944454068100361,1.553588069148936,1.4566298691756276,1.5120159060283687,1.528311771929825],"r":null,"name":"65536","marker":{"color":"#D95F02","size":10},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[2.9996736985815606,3.000770451388889,2.617296619047619,2.561582072916667,3.0359948794326246],"r":null,"name":"131072","marker":{"color":"#7570B3","size":10},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[6.332124340909091,6.157582405797102,6.278519659090909,6.064242253623189,6.100504855072463],"r":null,"name":"262144","marker":{"color":"#E7298A","size":10},"fill":null,"mode":"markers","width":null,"type":"scatter","theta":null,"z":null,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[0.3655132686375322,0.3780481164251208,0.39125373168498173,0.33332981963470326,0.39898399901960785],"r":null,"name":"16384","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"#1B9E77"},"opacity":0.6,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[1.4944454068100361,1.553588069148936,1.4566298691756276,1.5120159060283687,1.528311771929825],"r":null,"name":"65536","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"#D95F02"},"opacity":0.6,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[2.9996736985815606,3.000770451388889,2.617296619047619,2.561582072916667,3.0359948794326246],"r":null,"name":"131072","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"#7570B3"},"opacity":0.6,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null},{"y":[6.332124340909091,6.157582405797102,6.278519659090909,6.064242253623189,6.100504855072463],"r":null,"name":"262144","fill":null,"mode":"lines","width":null,"type":"scatter","theta":null,"z":null,"line":{"color":"#E7298A"},"opacity":0.6,"lon":null,"lat":null,"x":[1,2,4,8,16],"text":null}], {"width":800,"height":500,"margin":{"t":25},"automargin":false,"plot_bgcolor":"rgb(235,235,235)","xaxis":{"gridcolor":"rgb(255,255,255)","title":"Number of Threads","showgrid":true},"yaxis":{"gridcolor":"rgb(255,255,255)","title":"Mean Time per FFT (ms)","showgrid":true},"title":"FFT Performance vs Thread Count (Fastmath\/JTransforms)"}, {});</script></div>
```



### What We Found (Spoiler: It's Confusing!)

Looking at the visualization above, we see:

- **No consistent speedup** from adding threads
- Performance is similar across all thread counts for each signal size
- Performance scales linearly with signal size (not with thread count)
- Sometimes 1 thread is fastest, sometimes 2 or 4, sometimes even 16!
- The paper said 1D can only use 2-4 threads, but 8 and 16 threads work (they just don't help)

**Key observation:** Thread count makes little practical difference for 1D FFT at these sizes.


### Why Doesn't Threading Help?

We're honestly not sure! Here are some hypotheses:

**1. Memory Bandwidth Bottleneck**

FFT is likely [memory-bound](https://en.wikipedia.org/wiki/Memory_bound), not compute-bound. The algorithm reads and writes the entire array multiple times. All threads compete for the same [memory bus](https://en.wikipedia.org/wiki/Bus_(computing)#Memory_bus), which doesn't scale with CPU cores.

**2. Signal Sizes Too Small**

Even our largest test (262K samples, 2^18) might be below the threshold where parallelization becomes effective. The overhead of thread coordination could outweigh any benefits.

**3. 1D FFT Algorithm Limitations**

The Cooley-Tukey algorithm for 1D FFT has log₂(n) stages that must execute sequentially. For 131K samples, that's only 17 stages—not much to parallelize. [Amdahl's Law](https://en.wikipedia.org/wiki/Amdahl%27s_law) limits speedup when much of the work is sequential.

**4. JVM/JIT Complexity**

Despite using criterium for proper warmup, there may be JIT compilation differences between thread configurations, or thread pool initialization effects we're not accounting for.


### Practical Takeaway

Based on our experiments: **Don't worry about thread count for 1D FFT**. Use the default (typically matching your CPU cores), or even just 1 thread. The performance difference is negligible for typical signal sizes, and single-threaded is more predictable.

If you need good performance, focus on:

- Using power-of-2 signal sizes (triggers fast SPLIT_RADIX plan)
- Choosing an appropriate library (JTransforms/Fastmath are typically fastest for 1D, though differences aren't huge)
- Optimizing your overall algorithm to minimize FFT calls

**Note:** 2D and 3D FFTs may benefit more from parallelization since they have more work to distribute. We only tested 1D here.


## Machine Configuration and Reproducibility

Performance results depend heavily on your hardware. Here's how to inspect your environment:


::: {.sourceClojure}
```clojure
(def machine-info
  {:jvm-version (System/getProperty "java.version")
   :jvm-vendor (System/getProperty "java.vendor")
   :jvm-name (System/getProperty "java.vm.name")
   :heap-max-mb (/ (.maxMemory (Runtime/getRuntime)) 1024.0 1024.0)
   :heap-total-mb (/ (.totalMemory (Runtime/getRuntime)) 1024.0 1024.0)
   :os-name (System/getProperty "os.name")
   :os-arch (System/getProperty "os.arch")
   :os-version (System/getProperty "os.version")
   :available-processors (.availableProcessors (Runtime/getRuntime))
   :clojure-version (clojure-version)})
```
:::



::: {.sourceClojure}
```clojure
(kind/table
 [(assoc machine-info :property "Machine Configuration")])
```
:::


::: {.clay-table}

```{=html}
<table class="table table-hover table-responsive clay-table"><thead><tr><th>jvm-vendor</th><th>available-processors</th><th>jvm-version</th><th>heap-max-mb</th><th>property</th><th>jvm-name</th><th>os-version</th><th>clojure-version</th><th>os-name</th><th>os-arch</th><th>heap-total-mb</th></tr></thead><tbody><tr><td>Ubuntu</td><td>22</td><td>21.0.9</td><td>15936.0</td><td>Machine Configuration</td><td>OpenJDK 64-Bit Server VM</td><td>6.14.0-36-generic</td><td>1.12.3</td><td>Linux</td><td>amd64</td><td>480.0</td></tr></tbody></table>
```

:::


**This benchmark ran on:**

- **CPU**: 22 cores (Linux 6.14.0-36-generic, amd64)
- **JVM**: OpenJDK 21.0.9 (Ubuntu)
- **Heap**: 15,936 MB max
- **Clojure**: 1.12.3


## Signal Size Requirements

Different libraries have different requirements for signal lengths:


### Apache Commons Math: Power-of-2 Required

Apache Commons Math **strictly requires** signal length to be a [power of 2](https://en.wikipedia.org/wiki/Power_of_two) (128, 256, 512, 1024, etc.). This is because it only implements the classic [Cooley-Tukey algorithm](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm).


### JTransforms/Fastmath: Flexible (with caveats)

Based on our source code investigation (see the threading section above), JTransforms uses **three execution plans**:

1. **SPLIT_RADIX** (Cooley-Tukey variant) - Fast, multithreaded, requires power-of-2
2. **MIXED_RADIX** (Cooley-Tukey variant) - For factorable sizes, primarily sequential
3. **BLUESTEIN** (Chirp Z-transform) - For arbitrary sizes with large prime factors, supports 1-4 threads

When you provide a non-power-of-2 size, JTransforms uses MIXED_RADIX or BLUESTEIN depending on the size's prime factorization. This means:

- ✅ It works with any size (we tested 100, 127, 1000 successfully)
- ⚠️ Performance may be slower for non-power-of-2 sizes
- ⚠️ MIXED_RADIX is primarily sequential; BLUESTEIN supports limited parallelization

**Recommendation:** Use power-of-2 sizes when possible for best performance (triggers SPLIT_RADIX). If your data doesn't fit, zero-pad to the next power of 2, or use JTransforms/Fastmath with the understanding that a different plan will be selected.


## Related Functionality

Each library offers additional capabilities beyond basic FFT:


### Apache Commons Math

- [Inverse FFT](https://en.wikipedia.org/wiki/Fast_Fourier_transform#Inverse_FFT)
- [DCT](https://en.wikipedia.org/wiki/Discrete_cosine_transform)/[DST](https://en.wikipedia.org/wiki/Discrete_sine_transform)
- [Hadamard transform](https://en.wikipedia.org/wiki/Hadamard_transform)
- [Complex number](https://en.wikipedia.org/wiki/Complex_number) arithmetic
- Statistical analysis, [linear algebra](https://en.wikipedia.org/wiki/Linear_algebra), [optimization](https://en.wikipedia.org/wiki/Mathematical_optimization)


### JDSP

- [Butterworth](https://en.wikipedia.org/wiki/Butterworth_filter), [Chebyshev](https://en.wikipedia.org/wiki/Chebyshev_filter), [Bessel filters](https://en.wikipedia.org/wiki/Bessel_filter)
- [Peak detection](https://en.wikipedia.org/wiki/Peak_detection)
- [Continuous](https://en.wikipedia.org/wiki/Continuous_wavelet_transform)/[Discrete wavelet transforms](https://en.wikipedia.org/wiki/Discrete_wavelet_transform)
- [Short-time Fourier transform](https://en.wikipedia.org/wiki/Short-time_Fourier_transform) (STFT)
- [Hilbert transform](https://en.wikipedia.org/wiki/Hilbert_transform)
- [Convolution](https://en.wikipedia.org/wiki/Convolution), [correlation](https://en.wikipedia.org/wiki/Cross-correlation)


### JTransforms

- 1D, 2D, and 3D FFT
- [DCT](https://en.wikipedia.org/wiki/Discrete_cosine_transform) (Discrete Cosine Transform)
- [DST](https://en.wikipedia.org/wiki/Discrete_sine_transform) (Discrete Sine Transform)
- [DHT](https://en.wikipedia.org/wiki/Discrete_Hartley_transform) (Discrete Hartley Transform)
- [Multithreaded](https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)) variants for all transforms


### Fastmath

- [Protocol-based](https://clojure.org/reference/protocols) transform system
- All JTransforms transforms (FFT, DCT, DST, DHT)
- [Wavelet transforms](https://en.wikipedia.org/wiki/Wavelet) (Haar, Daubechies, Coiflet, Symlet)
- Vector operations, statistics, [random number generation](https://en.wikipedia.org/wiki/Random_number_generation)
- Signal processing utilities ([oscillators](https://en.wikipedia.org/wiki/Electronic_oscillator), [envelopes](https://en.wikipedia.org/wiki/Envelope_(waves)))
- [Noise generation](https://en.wikipedia.org/wiki/Colors_of_noise), [interpolation](https://en.wikipedia.org/wiki/Interpolation)


## Conclusions and Recommendations

After comparing these libraries, here are my recommendations:

**For most Clojure projects: Fastmath 3**

Fastmath provides a good balance of performance and developer experience:

- Idiomatic Clojure API (functional, immutable)
- Leverages JTransforms' performance
- Rich ecosystem (transforms, signal processing, statistics)
- Actively maintained

The `fastmath.transform` namespace makes FFT feel natural in Clojure:

Round-trip example


::: {.sourceClojure}
```clojure
(comment
  (let [fft (fm-transform/transformer :real :fft)]
    (-> signal
        (fm-transform/forward-1d fft)
        (fm-transform/reverse-1d fft))))
```
:::


**For direct Java interop: JTransforms**

If you want to use JTransforms directly and don't mind mutation:

- Use `DoubleFFT_1D` directly
- In-place mutations avoid allocations
- May be slightly faster than Fastmath wrapper in some cases
- Good for real-time audio processing or when you need fine-grained control

**For broader DSP needs: JDSP**

If you need filters, wavelets, peak detection, and FFT in one package:

- Convenient, batteries-included library
- Simple API
- Good documentation
- Note: FFT performance is somewhat slower than JTransforms/Fastmath

**Apache Commons Math: Consider alternatives**

While Commons Math is excellent for general mathematics, for FFT specifically you might prefer other options:

- Somewhat slower than JTransforms/Fastmath
- Returns boxed `Complex[]` objects (allocation overhead)
- Still a reasonable choice if you're already using Commons Math for other features


## Summary

The Clojure ecosystem offers several good FFT options through Java interop. For typical signal processing tasks, **Fastmath 3** is a solid choice: JTransforms' performance wrapped in a Clojure-friendly API. For direct control, use **JTransforms directly**. And if you need comprehensive DSP utilities beyond FFT, **JDSP** is worth exploring.


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/ClojureCivitas/clojurecivitas.github.io/blob/main/src/dsp/fft_comparison.clj">src/dsp/fft_comparison.clj</a></small></small></pre></div>
```